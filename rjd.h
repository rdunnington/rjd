#pragma once

////////////////////////////////////////////////////////////////////////////////
// autogenerated rjd.h
////////////////////////////////////////////////////////////////////////////////

#include <stdint.h>
#include <float.h>
#include <stddef.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>
#include <stdarg.h>
#include <xmmintrin.h> // SSE2
#include <pmmintrin.h> // SSE3
#include <smmintrin.h> // SSE4

#if RJD_IMPL
	#include <stdlib.h>
	#include <stdio.h>
#endif

////////////////////////////////////////////////////////////////////////////////
// rjd_platform.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_PLATFORM_H 1

// Platforms
#if _WIN32 || __CYGWIN__
	#define RJD_PLATFORM_WINDOWS 1
	#define RJD_PLATFORM_OSX 0
#elif __APPLE__ && __MACH__
	#define RJD_PLATFORM_OSX 1
	#define RJD_PLATFORM_WINDOWS 0
#else
	#error Unknown platform.
#endif

// Compilers
#ifdef _MSC_VER
	#define RJD_COMPILER_MSVC 1
#elif __clang__
	#define RJD_COMPILER_CLANG 1
#elif __GNUC__
	#define RJD_COMPILER_GCC 1
#else
	#error Unknown compiler.
#endif

#if RJD_COMPILER_MSVC
	#define RJD_FORCE_INLINE __forceinline
	#define RJD_FORCE_ALIGN(alignment, type) __declspec(align(alignment)) type
	#define restrict __restrict
#elif RJD_COMPILER_GCC || RJD_COMPILER_CLANG
	#define RJD_FORCE_INLINE static inline __attribute__((always_inline))
	#define RJD_FORCE_ALIGN(alignment, type) type __attribute__((aligned(alignment)))
#else
	#error Unhandled compiler
#endif

#if RJD_COMPILER_MSVC
	#if defined(_M_X86) || defined(_M_X64)
		#define RJD_ARCH_64 1
	#elif defined(_M_IX86)
		#define RJD_ARCH_32 1
	#else
		#error Unknown architecture
	#endif
#elif RJD_COMPILER_GCC
	#if defined(__x86_64) || defined(__x86_64__)
		#define RJD_ARCH_64 1
	#elif defined(i386) || defined(__i386) || defined(__i386__)
		#define RJD_ARCH_32 1
	#else
		#error Unknown architecture
	#endif
#elif RJD_COMPILER_CLANG
    #if defined(__x86_64) || defined(__x86_64__)
        #define RJD_ARCH_64 1
    #elif defined(i386) || defined(__i386) || defined(__i386__)
        #define RJD_ARCH_32 1
    #else
        #error Unknown architecture
    #endif
#else
	#error Unhandled compiler
#endif

#if RJD_COMPILER_MSVC
	#define RJD_COMPILER_MSVC_ONLY(code) code
	#define RJD_COMPILER_GCC_ONLY(code)
	#define RJD_COMPILER_CLANG_ONLY(code)
#elif RJD_COMPILER_GCC
	#define RJD_COMPILER_MSVC_ONLY(code)
	#define RJD_COMPILER_GCC_ONLY(code) code
	#define RJD_COMPILER_CLANG_ONLY(code)
#elif RJD_COMPILER_CLANG
	#define RJD_COMPILER_MSVC_ONLY(code)
	#define RJD_COMPILER_GCC_ONLY(code)
	#define RJD_COMPILER_CLANG_ONLY(code) code
#else
	#define RJD_COMPILER_MSVC_ONLY(code)
	#define RJD_COMPILER_GCC_ONLY(code)
	#define RJD_COMPILER_CLANG_ONLY(code)
#endif

#if RJD_COMPILER_MSVC
	#pragma warning(disable:4204) // nonstandard extension used: non-constant aggregate initializer (this is ok in C99)
	#pragma warning(disable:4201) // nonstandard extension used: nameless struct/union (gcc and clang support this)
	#pragma warning(disable:4221) // nonstandard extension used: initializing struct with address of local variable (gcc and clang support this)

#elif RJD_COMPILER_CLANG
	#pragma clang diagnostic ignored "-Wmissing-braces" // clang is paranoid about zero-init for nested structs
#endif

#if defined(__OBJC__)
	#define RJD_LANG_OBJC 1
#else
	#define RJD_LANG_OBJC 0
#endif

#if defined(__cplusplus)
	#define RJD_LANG_CPP 1
#else
	#define RJD_LANG_CPP 0
#endif

#if RJD_IMPL 
#if RJD_PLATFORM_WINDOWS 
	#define WIN32_LEAN_AND_MEAN
	#define WIN32_EXTRA_LEAN
	#define NOMINMAX
	#include <windows.h>
	#include <combaseapi.h>
#endif // RJD_PLATFORM_WINDOWS
#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_debug.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_DEBUG_H 1

enum rjd_log_verbosity
{
	RJD_LOG_VERBOSITY_LOW,
	RJD_LOG_VERBOSITY_MED,
	RJD_LOG_VERBOSITY_HIGH,
};

struct rjd_logchannel
{
	enum rjd_log_verbosity verbosity;
	bool enabled;
	const char* name;
	void (*hook)(const char* formatted, size_t length);
};

#if RJD_ENABLE_LOGGING
	#define RJD_LOG_CHANNEL(channel, verbosity, ...) rjd_log_impl(__FILE__, __LINE__, channel, verbosity, __VA_ARGS__)
	#define RJD_LOG(...) RJD_LOG_CHANNEL(g_rjd_global_logchannel, RJD_LOG_VERBOSITY_MED, __VA_ARGS__)
#else
	#define RJD_LOG_CHANNEL(channel, ...)
	#define RJD_LOG(...)
#endif


#define RJD_NAMEGEN2(a, b) a##b
#define RJD_NAMEGEN(a, b) RJD_NAMEGEN2(a, b)

#if RJD_COMPILER_MSVC
	#define RJD_STATIC_ASSERTMSG(condition, message) typedef int RJD_NAMEGEN(rjd_staticassert_fail, __COUNTER__)[(condition) ? 1 : -1]
#else
	#define RJD_STATIC_ASSERTMSG(condition, message) _Static_assert(condition, message)
#endif
#define RJD_STATIC_ASSERT(condition) RJD_STATIC_ASSERTMSG(condition, #condition)

#if RJD_COMPILER_CLANG || RJD_COMPILER_GCC
	#define RJD_SAME_TYPE_TEST(a, b) (__builtin_types_compatible_p(__typeof__(a), __typeof__(b)))
#else
	#define RJD_SAME_TYPE_TEST(a, b) (1)
#endif
#define RJD_STATIC_TEST(a) (sizeof(int[(a)?1:-1]) * 0)
#define RJD_MUST_BE_SAME_TYPE_TEST(a,b) RJD_STATIC_TEST(RJD_SAME_TYPE_TEST(a,b))

#if RJD_COMPILER_MSVC
	#define RJD_TRAP() __debugbreak()
#elif RJD_COMPILER_GCC || RJD_COMPILER_CLANG
	#define RJD_TRAP() __builtin_trap()
#endif

#if RJD_ENABLE_ASSERT
	#define RJD_ASSERT(condition) RJD_ASSERTMSG(condition, #condition)
	#define RJD_ASSERTMSG(condition, ...) if (!(condition)) { RJD_LOG(__VA_ARGS__); RJD_TRAP(); }
	#define RJD_ASSERTFAIL(...) { RJD_LOG(__VA_ARGS__); RJD_TRAP(); }
#else
	#define RJD_ASSERT(condition, ...) 
	#define RJD_ASSERTMSG(condition, ...) 
	#define RJD_ASSERTFAIL(...)
#endif

#define RJD_UNUSED_PARAM(param) ((void)(param))

void rjd_log_impl(const char* file, unsigned line, const struct rjd_logchannel* channel, enum rjd_log_verbosity verbosity, const char* format, ...);
void rjd_log_resetglobal(void);

extern const struct rjd_logchannel* g_rjd_global_logchannel;

#if RJD_IMPL

const struct rjd_logchannel rjd_global_logchannel = {
	.verbosity = RJD_LOG_VERBOSITY_MED,
	.enabled = true,
	.name = "Default Global",
};
const struct rjd_logchannel* g_rjd_global_logchannel = &rjd_global_logchannel;

void rjd_log_impl(const char* file, unsigned line, const struct rjd_logchannel* channel, enum rjd_log_verbosity verbosity, const char* format, ...)
{
	if (!channel || !channel->enabled) {
		return;
	}

	if (verbosity > channel->verbosity) {
		return;
	}

	va_list args;
	va_start(args, format);

	char rawMessage[4096];

	int written = vsnprintf(rawMessage, sizeof(rawMessage), format, args);
	va_end(args);

	if (written < 0)
	{
		printf("Failed to format message.\n");
		RJD_TRAP();
	}

	static const char* formattedLog = "%s(%u): %s\n";
	static const uint32_t logLength = sizeof("%s(%u): %s\n");
	
	char formatted[4096];

	if (sizeof(formatted) <= logLength + written)
	{
		printf("Static buffer not large enough.\n");
		RJD_TRAP();
	}

	const int size = sprintf(formatted, formattedLog, file, line, rawMessage);

	if (channel->hook) {
		channel->hook(formatted, size);
	} else {
		RJD_COMPILER_MSVC_ONLY(OutputDebugString(formatted));
		fwrite(formatted, 1, size, stdout);
		fflush(stdout);
	}
}

void rjd_log_resetglobal()
{
	g_rjd_global_logchannel = &rjd_global_logchannel;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_result.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_RESULT_H 1

struct rjd_result
{
	const char* error;
};

static inline bool rjd_result_isok(struct rjd_result result) {
	return result.error == NULL;
}

// TODO static assert that message is a compile-time string
#define RJD_RESULT(message) ((struct rjd_result){message})
#define RJD_RESULT_OK() RJD_RESULT(NULL)
#define RJD_RESULT_CHECK(validation_condition, message) if (!(validation_condition)) { return RJD_RESULT(message); }
#define RJD_RESULT_PROMOTE(result) if (!rjd_result_isok(result)) { return result; }

////////////////////////////////////////////////////////////////////////////////
// rjd_enum.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_ENUM_H 1

// TODO support RJD_ENABLE_ENUM_TYPEDEF

// To use these macros, you need to define an xmacro list, then the use the appropriate *DECLARE
// in a header and *DEFINE in source files. By using these macros, you get:
// * The enum definition (as if you defined it yourself)
// * A count of members in the enum named k_<enumname>_count
// * An enumname_tostring() function that takes the enum and returns a static string (no mem allocation)
// * An enumname_parse() function that takes a const char* and pointer to enum and returns success/fail
// * An array of the enum values' string representation
//
// For example, let's define a Result enum with the values Success and Fail. Note to not forget the 
// backslash for extending the macro in the real version.
//
//	#define MY_ENUM_LIST(macro)
//		macro(RESULT_FAIL)
//		macro(RESULT_SUCCESS)
//	RJD_ENUM_DECLARE(Result, MY_ENUM_LIST);
//	RJD_ENUM_DEFINE(Result, MY_ENUM_LIST);
//
//	The generated interface for the Result enum above would be:
//		enum Result { RESULT_FAIL, RESULT_SUCCESS };
//		enum { k_Result_count = 2 };
//		const char* Result_tostring(enum Result v);
//		bool Result_parse(const char* s, enum Result v);
//		const char* s_Result_strings[] = { "RESULT_FAIL", "RESULT_SUCCESS" };
//
//	You can also specify custom strings if you want to override the default tostring/parse:
//
//	#define MY_ENUM_LIST2(macro)
//		macro(MY_ENUM_LIST2_V1, "CustomStringRep1")
//		macro(MY_ENUM_LIST2_V2, "CustomStringRep2")
//		macro(MY_ENUM_LIST2_V3, "CustomStringRep3")
//	RJD_ENUM_DECLARE_WITH_STRINGS(CoolEnum, MY_ENUM_LIST);
//	RJD_ENUM_DEFINE_WITH_STRINGS(CoolEnum, MY_ENUM_LIST);
//

#define RJD_ENUM_IMPL_TOSTRING(name) name ## _tostring
#define RJD_ENUM_IMPL_COUNT(name) k_ ## name ## _count
#define RJD_ENUM_IMPL_PARSE(name) name ## _parse
#define RJD_ENUM_IMPL_STRINGS(name) s_ ## name ## _strings

#define RJD_ENUM_IMPL_MEMBER(item) item,
#define RJD_ENUM_IMPL_SUM(item) 1 +
#define RJD_ENUM_IMPL_TOSTRING_ITEM(item) #item,
#define RJD_ENUM_IMPL_TOSTRING_CASE(item) case item: return #item;

#define RJD_ENUM_IMPL_MEMBER_WITH_STRING(item, str) item,
#define RJD_ENUM_IMPL_SUM_WITH_STRING(item, str) 1 +
#define RJD_ENUM_IMPL_WITH_STRING_ITEM(item, str) str,
#define RJD_ENUM_IMPL_WITH_STRING_CASE(item, str) case item: return str;

#define RJD_ENUM_DECLARE(name, macrolist)											\
	enum name {																		\
		macrolist(RJD_ENUM_IMPL_MEMBER)												\
	};																				\
	enum { RJD_ENUM_IMPL_COUNT(name) = macrolist(RJD_ENUM_IMPL_SUM) 0 };			\
	const char* RJD_ENUM_IMPL_TOSTRING(name)(enum name v);							\
	bool RJD_ENUM_IMPL_PARSE(name)(const char* s, enum name* out);					\
	extern const char* RJD_ENUM_IMPL_STRINGS(name)[]

#define RJD_ENUM_DEFINE(name, macrolist)											\
	const char* RJD_ENUM_IMPL_TOSTRING(name)(enum name v) {							\
		switch(v) {																	\
			macrolist(RJD_ENUM_IMPL_TOSTRING_CASE)									\
		}																			\
		return "invalid value";														\
	}																				\
	bool RJD_ENUM_IMPL_PARSE(name)(const char* s, enum name* out) {					\
		RJD_ASSERT(out);															\
		for (size_t i = 0; i < RJD_ENUM_IMPL_COUNT(name); ++i) {					\
			if (!strcmp(RJD_ENUM_IMPL_STRINGS(name)[i], s)) {						\
				*out = (enum name)i;												\
				return true;														\
			}																		\
		}																			\
		return false;																\
	}																				\
	const char* RJD_ENUM_IMPL_STRINGS(name)[] = {									\
		macrolist(RJD_ENUM_IMPL_TOSTRING_ITEM)										\
	}

#define RJD_ENUM_DECLARE_WITH_STRINGS(name, macrolist)								\
	enum name {																		\
		macrolist(RJD_ENUM_IMPL_MEMBER_WITH_STRING)									\
	};																				\
	enum { RJD_ENUM_IMPL_COUNT(name) = macrolist(RJD_ENUM_IMPL_SUM_WITH_STRING) 0 };\
	const char* RJD_ENUM_IMPL_TOSTRING(name)(enum name v);							\
	bool RJD_ENUM_IMPL_PARSE(name)(const char* s, enum name* out);					\
	extern const char* RJD_ENUM_IMPL_STRINGS(name)[]

#define RJD_ENUM_DEFINE_WITH_STRINGS(name, macrolist)								\
	const char* RJD_ENUM_IMPL_TOSTRING(name)(enum name v) {							\
		switch(v) {																	\
			macrolist(RJD_ENUM_IMPL_WITH_STRING_CASE)								\
		}																			\
		return "invalid value";														\
	}																				\
	bool RJD_ENUM_IMPL_PARSE(name)(const char* s, enum name* out) {					\
		RJD_ASSERT(out);															\
		for (size_t i = 0; i < RJD_ENUM_IMPL_COUNT(name); ++i) {					\
			if (!strcmp(RJD_ENUM_IMPL_STRINGS(name)[i], s)) {						\
				*out = (enum name)i;												\
				return true;														\
			}																		\
		}																			\
		return false;																\
	}																				\
	const char* RJD_ENUM_IMPL_STRINGS(name)[] = {									\
		macrolist(RJD_ENUM_IMPL_WITH_STRING_ITEM)									\
	}


////////////////////////////////////////////////////////////////////////////////
// rjd_hash.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_HASH_H 1

struct rjd_hash32
{
	uint32_t value;
};

struct rjd_hash64
{
	uint64_t value;
};

enum
{
	RJD_HASH_NULLTERMINATED_BUFFER = -1,
};

extern const struct rjd_hash32 RJD_HASH32_INVALID;
extern const struct rjd_hash64 RJD_HASH64_INVALID;

// You can pass -1 as the length to indicate a NULL-terminated buffer (e.g. c-style string)
struct rjd_hash32 rjd_hash32_data(const uint8_t* key, int length);
struct rjd_hash64 rjd_hash64_data(const uint8_t* key, int length);
static inline struct rjd_hash32 rjd_hash32_str(const char* key);
static inline struct rjd_hash64 rjd_hash64_str(const char* key);
bool rjd_hash32_valid(struct rjd_hash32 hash);
bool rjd_hash64_valid(struct rjd_hash64 hash);

////////////////////////////////////////////////////////////////////////////////
// Inline implementation

static inline struct rjd_hash32 rjd_hash32_str(const char* key)
{
	const void* data = key;
	return rjd_hash32_data(data, -1);
}

static inline struct rjd_hash64 rjd_hash64_str(const char* key)
{
	const void* data = key;
	return rjd_hash64_data(data, -1);
}

#if RJD_IMPL

const struct rjd_hash32 RJD_HASH32_INVALID = {0};
const struct rjd_hash64 RJD_HASH64_INVALID = {0};

// Code derived from:
// Copyright (c) 2011 Stephan Brumme. All rights reserved.
// see http://create.stephan-brumme.com/disclaimer.html
//
// originally developed by Fowler, Noll and Vo
// http://isthe.com/chongo/tech/comp/fnv/
//
// prime/seed from http://isthe.com/chongo/tech/comp/fnv/

struct rjd_hash32 rjd_hash32_data(const uint8_t* key, int length)
{
	RJD_ASSERT(length >= -1);

	if (key == NULL || length == 0 || (length == -1 && *key == '\0')) {
		struct rjd_hash32 hash = {0};
		return hash;
	}

	const uint32_t PRIME = 16777619;
	const uint32_t SEED  = 2166136261;

	struct rjd_hash32 hash = { SEED };
	if (length == -1) {
		while (*key) {
			hash.value = (*key++ ^ hash.value) * PRIME;
		}
	} else {
		while (length > 0)
		{
			--length;
			hash.value = (uint32_t)((*key++ ^ hash.value) * PRIME);
		}
	}
	return hash;
}

struct rjd_hash64 rjd_hash64_data(const uint8_t* key, int length)
{
	RJD_ASSERT(length >= -1);

	if (key == NULL || length == 0 || (length == -1 && *key == '\0')) {
		struct rjd_hash64 hash = {0};
		return hash;
	}

	const uint64_t PRIME = 1099511628211ull;
	const uint64_t SEED  = 14695981039346656037ull;

	struct rjd_hash64 hash = { SEED };
	if (length == -1) {
		while (*key) {
			hash.value = (*key++ ^ hash.value) * PRIME;
		}
	} else {
		while (length > 0)
		{
			--length;
			hash.value = (*key++ ^ hash.value) * PRIME;
		}
	}
	return hash;
}

bool rjd_hash32_valid(struct rjd_hash32 hash)
{
	return hash.value != 0;
}

bool rjd_hash64_valid(struct rjd_hash64 hash)
{
	return hash.value != 0;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_atomic.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

// Uniform interface for low-level atomic operations. Ideally you could just use stdatomic but MSVC doesn't support it.
// Note that these functions all return the _new_ value stored in the atomic.

struct rjd_atomic_int64  { char impl[8]; };
struct rjd_atomic_int32  { char impl[4]; };
struct rjd_atomic_int16  { char impl[2]; };
struct rjd_atomic_int8   { char impl[1]; };
struct rjd_atomic_uint64 { char impl[8]; };
struct rjd_atomic_uint32 { char impl[4]; };
struct rjd_atomic_uint16 { char impl[2]; };
struct rjd_atomic_uint8  { char impl[1]; };

RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_int64) == sizeof(int64_t));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_int32) == sizeof(int32_t));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_int16) == sizeof(int16_t));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_int8) == sizeof(int8_t));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_uint64) == sizeof(uint64_t));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_uint32) == sizeof(uint32_t));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_uint16) == sizeof(uint16_t));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_uint8) == sizeof(uint8_t));

struct rjd_atomic_int64 rjd_atomic_int64_init (int64_t  value);
int64_t rjd_atomic_int64_get(struct rjd_atomic_int64* atomic);
int64_t rjd_atomic_int64_set(struct rjd_atomic_int64* atomic, int64_t value);
int64_t rjd_atomic_int64_add(struct rjd_atomic_int64* atomic, int64_t value);
int64_t rjd_atomic_int64_sub(struct rjd_atomic_int64* atomic, int64_t value);
int64_t rjd_atomic_int64_inc(struct rjd_atomic_int64* atomic);
int64_t rjd_atomic_int64_dec(struct rjd_atomic_int64* atomic);
bool rjd_atomic_int64_compare_exchange(struct rjd_atomic_int64* atomic, int64_t* expected, int64_t desired);

struct rjd_atomic_int32 rjd_atomic_int32_init (int32_t  value);
int32_t rjd_atomic_int32_get(struct rjd_atomic_int32* atomic);
int32_t rjd_atomic_int32_set(struct rjd_atomic_int32* atomic, int32_t value);
int32_t rjd_atomic_int32_add(struct rjd_atomic_int32* atomic, int32_t value);
int32_t rjd_atomic_int32_sub(struct rjd_atomic_int32* atomic, int32_t value);
int32_t rjd_atomic_int32_inc(struct rjd_atomic_int32* atomic);
int32_t rjd_atomic_int32_dec(struct rjd_atomic_int32* atomic);
bool rjd_atomic_int32_compare_exchange(struct rjd_atomic_int32* atomic, int32_t* expected, int32_t desired);

struct rjd_atomic_int16 rjd_atomic_int16_init (int16_t  value);
int16_t rjd_atomic_int16_get(struct rjd_atomic_int16* atomic);
int16_t rjd_atomic_int16_set(struct rjd_atomic_int16* atomic, int16_t value);
int16_t rjd_atomic_int16_add(struct rjd_atomic_int16* atomic, int16_t value);
int16_t rjd_atomic_int16_sub(struct rjd_atomic_int16* atomic, int16_t value);
int16_t rjd_atomic_int16_inc(struct rjd_atomic_int16* atomic);
int16_t rjd_atomic_int16_dec(struct rjd_atomic_int16* atomic);
bool rjd_atomic_int16_compare_exchange(struct rjd_atomic_int16* atomic, int16_t* expected, int16_t desired);

struct rjd_atomic_int8 rjd_atomic_int8_init (int8_t  value);
int8_t rjd_atomic_int8_get(struct rjd_atomic_int8* atomic);
int8_t rjd_atomic_int8_set(struct rjd_atomic_int8* atomic, int8_t value);
int8_t rjd_atomic_int8_add(struct rjd_atomic_int8* atomic, int8_t value);
int8_t rjd_atomic_int8_sub(struct rjd_atomic_int8* atomic, int8_t value);
int8_t rjd_atomic_int8_inc(struct rjd_atomic_int8* atomic);
int8_t rjd_atomic_int8_dec(struct rjd_atomic_int8* atomic);
bool rjd_atomic_int8_compare_exchange(struct rjd_atomic_int8* atomic, int8_t* expected, int8_t desired);

struct rjd_atomic_uint64 rjd_atomic_uint64_init (uint64_t  value);
uint64_t rjd_atomic_uint64_get(struct rjd_atomic_uint64* atomic);
uint64_t rjd_atomic_uint64_set(struct rjd_atomic_uint64* atomic, uint64_t value);
uint64_t rjd_atomic_uint64_add(struct rjd_atomic_uint64* atomic, uint64_t value);
uint64_t rjd_atomic_uint64_sub(struct rjd_atomic_uint64* atomic, uint64_t value);
uint64_t rjd_atomic_uint64_inc(struct rjd_atomic_uint64* atomic);
uint64_t rjd_atomic_uint64_dec(struct rjd_atomic_uint64* atomic);
bool rjd_atomic_uint64_compare_exchange(struct rjd_atomic_uint64* atomic, uint64_t* expected, uint64_t desired);

struct rjd_atomic_uint32 rjd_atomic_uint32_init (uint32_t  value);
uint32_t rjd_atomic_uint32_get(struct rjd_atomic_uint32* atomic);
uint32_t rjd_atomic_uint32_set(struct rjd_atomic_uint32* atomic, uint32_t value);
uint32_t rjd_atomic_uint32_add(struct rjd_atomic_uint32* atomic, uint32_t value);
uint32_t rjd_atomic_uint32_sub(struct rjd_atomic_uint32* atomic, uint32_t value);
uint32_t rjd_atomic_uint32_inc(struct rjd_atomic_uint32* atomic);
uint32_t rjd_atomic_uint32_dec(struct rjd_atomic_uint32* atomic);
bool rjd_atomic_uint32_compare_exchange(struct rjd_atomic_uint32* atomic, uint32_t* expected, uint32_t desired);

struct rjd_atomic_uint16 rjd_atomic_uint16_init (uint16_t  value);
uint16_t rjd_atomic_uint16_get(struct rjd_atomic_uint16* atomic);
uint16_t rjd_atomic_uint16_set(struct rjd_atomic_uint16* atomic, uint16_t value);
uint16_t rjd_atomic_uint16_add(struct rjd_atomic_uint16* atomic, uint16_t value);
uint16_t rjd_atomic_uint16_sub(struct rjd_atomic_uint16* atomic, uint16_t value);
uint16_t rjd_atomic_uint16_inc(struct rjd_atomic_uint16* atomic);
uint16_t rjd_atomic_uint16_dec(struct rjd_atomic_uint16* atomic);
bool rjd_atomic_uint16_compare_exchange(struct rjd_atomic_uint16* atomic, uint16_t* expected, uint16_t desired);

struct rjd_atomic_uint8 rjd_atomic_uint8_init (uint8_t  value);
uint8_t rjd_atomic_uint8_get(struct rjd_atomic_uint8* atomic);
uint8_t rjd_atomic_uint8_set(struct rjd_atomic_uint8* atomic, uint8_t value);
uint8_t rjd_atomic_uint8_add(struct rjd_atomic_uint8* atomic, uint8_t value);
uint8_t rjd_atomic_uint8_sub(struct rjd_atomic_uint8* atomic, uint8_t value);
uint8_t rjd_atomic_uint8_inc(struct rjd_atomic_uint8* atomic);
uint8_t rjd_atomic_uint8_dec(struct rjd_atomic_uint8* atomic);
bool rjd_atomic_uint8_compare_exchange(struct rjd_atomic_uint8* atomic, uint8_t* expected, uint8_t desired);

#if RJD_IMPL

// MSVC doesn't support stdatomic.h :(
#if RJD_COMPILER_MSVC

inline uint64_t rjd_reinterpret_i64_as_u64(int64_t value)
{
	union { int64_t s; uint64_t u; } caster;
	caster.s = value;
	return caster.u;
}

inline int64_t rjd_reinterpret_u64_as_i64(uint64_t value)
{
	union { int64_t s; uint64_t u; } caster;
	caster.u = value;
	return caster.s;
}

inline uint32_t rjd_reinterpret_i32_as_u32(int32_t value)
{
	union { int32_t s; int32_t u; } caster;
	caster.s = value;
	return caster.u;
}

inline int32_t rjd_reinterpret_u32_as_i32(uint32_t value)
{
	union { int32_t s; int32_t u; } caster;
	caster.u = value;
	return caster.s;
}

inline uint16_t rjd_reinterpret_i16_as_u16(int16_t value)
{
	union { int16_t s; int16_t u; } caster;
	caster.s = value;
	return caster.u;
}

inline int16_t rjd_reinterpret_u16_as_i16(uint16_t value)
{
	union { int16_t s; int16_t u; } caster;
	caster.u = value;
	return caster.s;
}

inline uint8_t rjd_reinterpret_i8_as_u8(int8_t value)
{
	union { int8_t s; int8_t u; } caster;
	caster.s = value;
	return caster.u;
}

inline int8_t rjd_reinterpret_u8_as_i8(uint8_t value)
{
	union { int8_t s; int8_t u; } caster;
	caster.u = value;
	return caster.s;
}

struct rjd_atomic_int64_msvc  { union { volatile __int64 value_signed; volatile uint64_t value_unsigned; }; };
struct rjd_atomic_int32_msvc  { union { volatile long value_signed; volatile long value_unsigned; }; };
struct rjd_atomic_int16_msvc  { union { volatile short value_signed; volatile short value_unsigned; }; };
struct rjd_atomic_int8_msvc   { union { volatile char value_signed; volatile char value_unsigned; }; };
struct rjd_atomic_uint64_msvc { struct rjd_atomic_int64 atomic; };
struct rjd_atomic_uint32_msvc { struct rjd_atomic_int32 atomic; };
struct rjd_atomic_uint16_msvc { struct rjd_atomic_int16 atomic; };
struct rjd_atomic_uint8_msvc  { struct rjd_atomic_int8 atomic; };

RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_int64_msvc) <= sizeof(struct rjd_atomic_int64));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_int32_msvc) <= sizeof(struct rjd_atomic_int32));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_int16_msvc) <= sizeof(struct rjd_atomic_int16));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_int8_msvc) <= sizeof(struct rjd_atomic_int8));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_uint64_msvc) <= sizeof(struct rjd_atomic_uint64));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_uint32_msvc) <= sizeof(struct rjd_atomic_uint32));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_uint16_msvc) <= sizeof(struct rjd_atomic_uint16));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_uint8_msvc) <= sizeof(struct rjd_atomic_uint8));

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_int64 rjd_atomic_int64_init(int64_t value)
{
	struct rjd_atomic_int64 out = {0};
	struct rjd_atomic_int64_msvc* atomic_msvc = (struct rjd_atomic_int64_msvc*)&out;
	atomic_msvc->value_signed = value;
	return out;
}

int64_t rjd_atomic_int64_get(struct rjd_atomic_int64* atomic)
{
	struct rjd_atomic_int64_msvc* atomic_msvc = (struct rjd_atomic_int64_msvc*)atomic;
	return atomic_msvc->value_signed;
}

int64_t rjd_atomic_int64_set(struct rjd_atomic_int64* atomic, int64_t value)
{
	struct rjd_atomic_int64_msvc* atomic_msvc = (struct rjd_atomic_int64_msvc*)atomic;
	atomic_msvc->value_signed = value;
	return value;
}

int64_t rjd_atomic_int64_add(struct rjd_atomic_int64* atomic, int64_t value)
{
	struct rjd_atomic_int64_msvc* atomic_msvc = (struct rjd_atomic_int64_msvc*)atomic;
	return InterlockedExchangeAdd64(&atomic_msvc->value_signed, value) + value;
}

int64_t rjd_atomic_int64_sub(struct rjd_atomic_int64* atomic, int64_t value)
{
	return rjd_atomic_int64_add(atomic, -value);
}

int64_t rjd_atomic_int64_inc(struct rjd_atomic_int64* atomic)
{
	struct rjd_atomic_int64_msvc* atomic_msvc = (struct rjd_atomic_int64_msvc*)atomic;
	return InterlockedIncrement64(&atomic_msvc->value_signed);
}

int64_t rjd_atomic_int64_dec(struct rjd_atomic_int64* atomic)
{
	struct rjd_atomic_int64_msvc* atomic_msvc = (struct rjd_atomic_int64_msvc*)atomic;
	return InterlockedDecrement64(&atomic_msvc->value_signed);
}

bool rjd_atomic_int64_compare_exchange(struct rjd_atomic_int64* atomic, int64_t* expected, int64_t desired)
{
	struct rjd_atomic_int64_msvc* atomic_msvc = (struct rjd_atomic_int64_msvc*)atomic;
	return InterlockedCompareExchange64(&atomic_msvc->value_signed, desired, *expected);
}

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_int32 rjd_atomic_int32_init(int32_t value)
{
	struct rjd_atomic_int32 out = {0};
	struct rjd_atomic_int32_msvc* atomic_msvc = (struct rjd_atomic_int32_msvc*)&out;
	atomic_msvc->value_signed = value;
	return out;
}

int32_t rjd_atomic_int32_get(struct rjd_atomic_int32* atomic)
{
	struct rjd_atomic_int32_msvc* atomic_msvc = (struct rjd_atomic_int32_msvc*)atomic;
	return atomic_msvc->value_signed;
}

int32_t rjd_atomic_int32_set(struct rjd_atomic_int32* atomic, int32_t value)
{
	struct rjd_atomic_int32_msvc* atomic_msvc = (struct rjd_atomic_int32_msvc*)atomic;
	atomic_msvc->value_signed = value;
	return value;
}

int32_t rjd_atomic_int32_add(struct rjd_atomic_int32* atomic, int32_t value)
{
	struct rjd_atomic_int32_msvc* atomic_msvc = (struct rjd_atomic_int32_msvc*)atomic;
	return InterlockedExchangeAdd(&atomic_msvc->value_signed, value) + value;
}

int32_t rjd_atomic_int32_sub(struct rjd_atomic_int32* atomic, int32_t value)
{
	return rjd_atomic_int32_add(atomic, -value);
}

int32_t rjd_atomic_int32_inc(struct rjd_atomic_int32* atomic)
{
	struct rjd_atomic_int32_msvc* atomic_msvc = (struct rjd_atomic_int32_msvc*)atomic;
	return InterlockedIncrement(&atomic_msvc->value_signed);
}

int32_t rjd_atomic_int32_dec(struct rjd_atomic_int32* atomic)
{
	struct rjd_atomic_int32_msvc* atomic_msvc = (struct rjd_atomic_int32_msvc*)atomic;
	return InterlockedDecrement(&atomic_msvc->value_signed);
}

bool rjd_atomic_int32_compare_exchange(struct rjd_atomic_int32* atomic, int32_t* expected, int32_t desired)
{
	struct rjd_atomic_int32_msvc* atomic_msvc = (struct rjd_atomic_int32_msvc*)atomic;
	return InterlockedCompareExchange(&atomic_msvc->value_signed, desired, *expected);
}

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_int16 rjd_atomic_int16_init(int16_t value)
{
	struct rjd_atomic_int16 out = {0};
	struct rjd_atomic_int16_msvc* atomic_msvc =  (struct rjd_atomic_int16_msvc*)&out;
	atomic_msvc->value_signed = value;
	return out;
}

int16_t rjd_atomic_int16_get(struct rjd_atomic_int16* atomic)
{
	struct rjd_atomic_int16_msvc* atomic_msvc = (struct rjd_atomic_int16_msvc*)atomic;
	return atomic_msvc->value_signed;
}

int16_t rjd_atomic_int16_set(struct rjd_atomic_int16* atomic, int16_t value)
{
	struct rjd_atomic_int16_msvc* atomic_msvc = (struct rjd_atomic_int16_msvc*)atomic;
	atomic_msvc->value_signed = value;
	return value;
}

int16_t rjd_atomic_int16_add(struct rjd_atomic_int16* atomic, int16_t value)
{
	struct rjd_atomic_int16_msvc* atomic_msvc = (struct rjd_atomic_int16_msvc*)atomic;

	int16_t expected;
	int16_t desired;
	do
	{
		expected = atomic_msvc->value_signed;
		desired = atomic_msvc->value_signed + value;
	} while (InterlockedCompareExchange16(&atomic_msvc->value_signed, desired, expected) != expected);
	return desired;
}

int16_t rjd_atomic_int16_sub(struct rjd_atomic_int16* atomic, int16_t value)
{
	return rjd_atomic_int16_add(atomic, -value);
}

int16_t rjd_atomic_int16_inc(struct rjd_atomic_int16* atomic)
{
	struct rjd_atomic_int16_msvc* atomic_msvc = (struct rjd_atomic_int16_msvc*)atomic;
	return InterlockedIncrement16(&atomic_msvc->value_signed);
}

int16_t rjd_atomic_int16_dec(struct rjd_atomic_int16* atomic)
{
	struct rjd_atomic_int16_msvc* atomic_msvc = (struct rjd_atomic_int16_msvc*)atomic;
	return InterlockedDecrement16(&atomic_msvc->value_signed);
}

bool rjd_atomic_int16_compare_exchange(struct rjd_atomic_int16* atomic, int16_t* expected, int16_t desired)
{
	struct rjd_atomic_int16_msvc* atomic_msvc = (struct rjd_atomic_int16_msvc*)atomic;
	return InterlockedCompareExchange16(&atomic_msvc->value_signed, desired, *expected);
}

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_int8 rjd_atomic_int8_init (int8_t value)
{
	struct rjd_atomic_int8 out = {0};
	struct rjd_atomic_int8_msvc* atomic_msvc =  (struct rjd_atomic_int8_msvc*)&out;
	atomic_msvc->value_signed = value;
	return out;
}

int8_t rjd_atomic_int8_get(struct rjd_atomic_int8* atomic)
{
	struct rjd_atomic_int8_msvc* atomic_msvc = (struct rjd_atomic_int8_msvc*)atomic;
	return atomic_msvc->value_signed;
}

int8_t rjd_atomic_int8_set(struct rjd_atomic_int8* atomic, int8_t value)
{
	struct rjd_atomic_int8_msvc* atomic_msvc = (struct rjd_atomic_int8_msvc*)atomic;
	atomic_msvc->value_signed = value;
	return value;
}

int8_t rjd_atomic_int8_add(struct rjd_atomic_int8* atomic, int8_t value)
{
	struct rjd_atomic_int8_msvc* atomic_msvc = (struct rjd_atomic_int8_msvc*)atomic;

	int8_t expected;
	int8_t desired;
	do
	{
		expected = atomic_msvc->value_signed;
		desired = atomic_msvc->value_signed + value;
	} while (_InterlockedCompareExchange8(&atomic_msvc->value_signed, desired, expected) != expected);
	return desired;
}

int8_t rjd_atomic_int8_sub(struct rjd_atomic_int8* atomic, int8_t value)
{
	return rjd_atomic_int8_add(atomic, -value);
}

int8_t rjd_atomic_int8_inc(struct rjd_atomic_int8* atomic)
{
	return rjd_atomic_int8_add(atomic, 1);
}

int8_t rjd_atomic_int8_dec(struct rjd_atomic_int8* atomic)
{
	return rjd_atomic_int8_add(atomic, -1);
}

bool rjd_atomic_int8_compare_exchange(struct rjd_atomic_int8* atomic, int8_t* expected, int8_t desired)
{
	struct rjd_atomic_int8_msvc* atomic_msvc = (struct rjd_atomic_int8_msvc*)atomic;
	return _InterlockedCompareExchange8(&atomic_msvc->value_signed, desired, *expected);
}

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_uint64 rjd_atomic_uint64_init(uint64_t value)
{
	struct rjd_atomic_uint64 out = {0};
	struct rjd_atomic_uint64_msvc* atomic_msvc = (struct rjd_atomic_uint64_msvc*)&out;
	struct rjd_atomic_int64_msvc* atomic_signed_msvc = (struct rjd_atomic_int64_msvc*)&atomic_msvc->atomic;
	atomic_signed_msvc->value_unsigned = value;
	return out;
}

uint64_t rjd_atomic_uint64_get(struct rjd_atomic_uint64* atomic)
{
	struct rjd_atomic_uint64_msvc* atomic_msvc = (struct rjd_atomic_uint64_msvc*)atomic;
	struct rjd_atomic_int64_msvc* atomic_signed_msvc = (struct rjd_atomic_int64_msvc*)&atomic_msvc->atomic;
	return atomic_signed_msvc->value_unsigned;
}

uint64_t rjd_atomic_uint64_set(struct rjd_atomic_uint64* atomic, uint64_t value)
{
	struct rjd_atomic_uint64_msvc* atomic_msvc = (struct rjd_atomic_uint64_msvc*)atomic;
	struct rjd_atomic_int64_msvc* atomic_signed_msvc = (struct rjd_atomic_int64_msvc*)&atomic_msvc->atomic;
	atomic_signed_msvc->value_unsigned = value;
	return value;
}

uint64_t rjd_atomic_uint64_add(struct rjd_atomic_uint64* atomic, uint64_t value)
{
	struct rjd_atomic_uint64_msvc* atomic_msvc = (struct rjd_atomic_uint64_msvc*)atomic;
	int64_t result = rjd_atomic_int64_add(&atomic_msvc->atomic, rjd_reinterpret_u64_as_i64(value));
	return rjd_reinterpret_i64_as_u64(result);
}

uint64_t rjd_atomic_uint64_sub(struct rjd_atomic_uint64* atomic, uint64_t value)
{
	struct rjd_atomic_uint64_msvc* atomic_msvc = (struct rjd_atomic_uint64_msvc*)atomic;
	int64_t result = rjd_atomic_int64_add(&atomic_msvc->atomic, -rjd_reinterpret_u64_as_i64(value));
	return rjd_reinterpret_i64_as_u64(result);
}

uint64_t rjd_atomic_uint64_inc(struct rjd_atomic_uint64* atomic)
{
	struct rjd_atomic_uint64_msvc* atomic_msvc = (struct rjd_atomic_uint64_msvc*)atomic;
	int64_t result = rjd_atomic_int64_inc(&atomic_msvc->atomic);
	return rjd_reinterpret_i64_as_u64(result);
}

uint64_t rjd_atomic_uint64_dec(struct rjd_atomic_uint64* atomic)
{
	struct rjd_atomic_uint64_msvc* atomic_msvc = (struct rjd_atomic_uint64_msvc*)atomic;
	int64_t result = rjd_atomic_int64_dec(&atomic_msvc->atomic);
	return rjd_reinterpret_i64_as_u64(result);
}

bool rjd_atomic_uint64_compare_exchange(struct rjd_atomic_uint64* atomic, uint64_t* expected, uint64_t desired)
{
	struct rjd_atomic_uint64_msvc* atomic_msvc = (struct rjd_atomic_uint64_msvc*)atomic;
	return rjd_atomic_int64_compare_exchange(&atomic_msvc->atomic, (int64_t*)expected, rjd_reinterpret_u64_as_i64(desired));
}

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_uint32 rjd_atomic_uint32_init(uint32_t value)
{
	struct rjd_atomic_uint32 out = {0};
	struct rjd_atomic_uint32_msvc* atomic_msvc = (struct rjd_atomic_uint32_msvc*)&out;
	struct rjd_atomic_int32_msvc* atomic_signed_msvc = (struct rjd_atomic_int32_msvc*)&atomic_msvc->atomic;
	atomic_signed_msvc->value_unsigned = value;
	return out;
}

uint32_t rjd_atomic_uint32_get(struct rjd_atomic_uint32* atomic)
{
	struct rjd_atomic_uint32_msvc* atomic_msvc = (struct rjd_atomic_uint32_msvc*)atomic;
	struct rjd_atomic_int32_msvc* atomic_signed_msvc = (struct rjd_atomic_int32_msvc*)&atomic_msvc->atomic;
	return atomic_signed_msvc->value_unsigned;
}

uint32_t rjd_atomic_uint32_set(struct rjd_atomic_uint32* atomic, uint32_t value)
{
	struct rjd_atomic_uint32_msvc* atomic_msvc = (struct rjd_atomic_uint32_msvc*)atomic;
	struct rjd_atomic_int32_msvc* atomic_signed_msvc = (struct rjd_atomic_int32_msvc*)&atomic_msvc->atomic;
	atomic_signed_msvc->value_unsigned = value;
	return value;
}

uint32_t rjd_atomic_uint32_add(struct rjd_atomic_uint32* atomic, uint32_t value)
{
	struct rjd_atomic_uint32_msvc* atomic_msvc = (struct rjd_atomic_uint32_msvc*)atomic;
	int32_t result = rjd_atomic_int32_add(&atomic_msvc->atomic, rjd_reinterpret_u32_as_i32(value));
	return rjd_reinterpret_i32_as_u32(result);
}

uint32_t rjd_atomic_uint32_sub(struct rjd_atomic_uint32* atomic, uint32_t value)
{
	struct rjd_atomic_uint32_msvc* atomic_msvc = (struct rjd_atomic_uint32_msvc*)atomic;
	int32_t result = rjd_atomic_int32_add(&atomic_msvc->atomic, -rjd_reinterpret_u32_as_i32(value));
	return rjd_reinterpret_i32_as_u32(result);
}

uint32_t rjd_atomic_uint32_inc(struct rjd_atomic_uint32* atomic)
{
	struct rjd_atomic_uint32_msvc* atomic_msvc = (struct rjd_atomic_uint32_msvc*)atomic;
	int32_t result = rjd_atomic_int32_inc(&atomic_msvc->atomic);
	return rjd_reinterpret_i32_as_u32(result);
}

uint32_t rjd_atomic_uint32_dec(struct rjd_atomic_uint32* atomic)
{
	struct rjd_atomic_uint32_msvc* atomic_msvc = (struct rjd_atomic_uint32_msvc*)atomic;
	int32_t result = rjd_atomic_int32_dec(&atomic_msvc->atomic);
	return rjd_reinterpret_i32_as_u32(result);
}

bool rjd_atomic_uint32_compare_exchange(struct rjd_atomic_uint32* atomic, uint32_t* expected, uint32_t desired)
{
	struct rjd_atomic_uint32_msvc* atomic_msvc = (struct rjd_atomic_uint32_msvc*)atomic;
	return rjd_atomic_int32_compare_exchange(&atomic_msvc->atomic, (int32_t*)expected, rjd_reinterpret_u32_as_i32(desired));
}

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_uint16 rjd_atomic_uint16_init(uint16_t value)
{
	struct rjd_atomic_uint16 out = {0};
	struct rjd_atomic_uint16_msvc* atomic_msvc = (struct rjd_atomic_uint16_msvc*)&out;
	struct rjd_atomic_int16_msvc* atomic_signed_msvc = (struct rjd_atomic_int16_msvc*)&atomic_msvc->atomic;
	atomic_signed_msvc->value_unsigned = value;
	return out;
}

uint16_t rjd_atomic_uint16_get(struct rjd_atomic_uint16* atomic)
{
	struct rjd_atomic_uint16_msvc* atomic_msvc = (struct rjd_atomic_uint16_msvc*)atomic;
	struct rjd_atomic_int16_msvc* atomic_signed_msvc = (struct rjd_atomic_int16_msvc*)&atomic_msvc->atomic;
	return atomic_signed_msvc->value_unsigned;
}

uint16_t rjd_atomic_uint16_set(struct rjd_atomic_uint16* atomic, uint16_t value)
{
	struct rjd_atomic_uint16_msvc* atomic_msvc = (struct rjd_atomic_uint16_msvc*)atomic;
	struct rjd_atomic_int16_msvc* atomic_signed_msvc = (struct rjd_atomic_int16_msvc*)&atomic_msvc->atomic;
	atomic_signed_msvc->value_unsigned = value;
	return value;
}

uint16_t rjd_atomic_uint16_add(struct rjd_atomic_uint16* atomic, uint16_t value)
{
	struct rjd_atomic_uint16_msvc* atomic_msvc = (struct rjd_atomic_uint16_msvc*)atomic;
	int16_t result = rjd_atomic_int16_add(&atomic_msvc->atomic, rjd_reinterpret_u16_as_i16(value));
	return rjd_reinterpret_i16_as_u16(result);
}

uint16_t rjd_atomic_uint16_sub(struct rjd_atomic_uint16* atomic, uint16_t value)
{
	struct rjd_atomic_uint16_msvc* atomic_msvc = (struct rjd_atomic_uint16_msvc*)atomic;
	int16_t result = rjd_atomic_int16_add(&atomic_msvc->atomic, -rjd_reinterpret_u16_as_i16(value));
	return rjd_reinterpret_i16_as_u16(result);
}

uint16_t rjd_atomic_uint16_inc(struct rjd_atomic_uint16* atomic)
{
	struct rjd_atomic_uint16_msvc* atomic_msvc = (struct rjd_atomic_uint16_msvc*)atomic;
	int16_t result = rjd_atomic_int16_inc(&atomic_msvc->atomic);
	return rjd_reinterpret_i16_as_u16(result);
}

uint16_t rjd_atomic_uint16_dec(struct rjd_atomic_uint16* atomic)
{
	struct rjd_atomic_uint16_msvc* atomic_msvc = (struct rjd_atomic_uint16_msvc*)atomic;
	int16_t result = rjd_atomic_int16_dec(&atomic_msvc->atomic);
	return rjd_reinterpret_i16_as_u16(result);
}

bool rjd_atomic_uint16_compare_exchange(struct rjd_atomic_uint16* atomic, uint16_t* expected, uint16_t desired)
{
	struct rjd_atomic_uint16_msvc* atomic_msvc = (struct rjd_atomic_uint16_msvc*)atomic;
	return rjd_atomic_int16_compare_exchange(&atomic_msvc->atomic, (int16_t*)expected, rjd_reinterpret_u16_as_i16(desired));
}

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_uint8 rjd_atomic_uint8_init(uint8_t value)
{
	struct rjd_atomic_uint8 out = {0};
	struct rjd_atomic_uint8_msvc* atomic_msvc = (struct rjd_atomic_uint8_msvc*)&out;
	struct rjd_atomic_int8_msvc* atomic_signed_msvc = (struct rjd_atomic_int8_msvc*)&atomic_msvc->atomic;
	atomic_signed_msvc->value_unsigned = value;
	return out;
}

uint8_t rjd_atomic_uint8_get(struct rjd_atomic_uint8* atomic)
{
	struct rjd_atomic_uint8_msvc* atomic_msvc = (struct rjd_atomic_uint8_msvc*)atomic;
	struct rjd_atomic_int8_msvc* atomic_signed_msvc = (struct rjd_atomic_int8_msvc*)&atomic_msvc->atomic;
	return atomic_signed_msvc->value_unsigned;
}

uint8_t rjd_atomic_uint8_set(struct rjd_atomic_uint8* atomic, uint8_t value)
{
	struct rjd_atomic_uint8_msvc* atomic_msvc = (struct rjd_atomic_uint8_msvc*)atomic;
	struct rjd_atomic_int8_msvc* atomic_signed_msvc = (struct rjd_atomic_int8_msvc*)&atomic_msvc->atomic;
	atomic_signed_msvc->value_unsigned = value;
	return value;
}

uint8_t rjd_atomic_uint8_add(struct rjd_atomic_uint8* atomic, uint8_t value)
{
	struct rjd_atomic_uint8_msvc* atomic_msvc = (struct rjd_atomic_uint8_msvc*)atomic;
	int8_t result = rjd_atomic_int8_add(&atomic_msvc->atomic, rjd_reinterpret_u8_as_i8(value));
	return rjd_reinterpret_i8_as_u8(result);
}

uint8_t rjd_atomic_uint8_sub(struct rjd_atomic_uint8* atomic, uint8_t value)
{
	struct rjd_atomic_uint8_msvc* atomic_msvc = (struct rjd_atomic_uint8_msvc*)atomic;
	int8_t result = rjd_atomic_int8_add(&atomic_msvc->atomic, -rjd_reinterpret_u8_as_i8(value));
	return rjd_reinterpret_i8_as_u8(result);
}

uint8_t rjd_atomic_uint8_inc(struct rjd_atomic_uint8* atomic)
{
	struct rjd_atomic_uint8_msvc* atomic_msvc = (struct rjd_atomic_uint8_msvc*)atomic;
	int8_t result = rjd_atomic_int8_inc(&atomic_msvc->atomic);
	return rjd_reinterpret_i8_as_u8(result);
}

uint8_t rjd_atomic_uint8_dec(struct rjd_atomic_uint8* atomic)
{
	struct rjd_atomic_uint8_msvc* atomic_msvc = (struct rjd_atomic_uint8_msvc*)atomic;
	int8_t result = rjd_atomic_int8_dec(&atomic_msvc->atomic);
	return rjd_reinterpret_i8_as_u8(result);
}

bool rjd_atomic_uint8_compare_exchange(struct rjd_atomic_uint8* atomic, uint8_t* expected, uint8_t desired)
{
	struct rjd_atomic_uint8_msvc* atomic_msvc = (struct rjd_atomic_uint8_msvc*)atomic;
	return rjd_atomic_int8_compare_exchange(&atomic_msvc->atomic, (int8_t*)expected, rjd_reinterpret_u8_as_i8(desired));
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

#elif RJD_COMPILER_GCC || RJD_COMPILER_CLANG
#include <stdatomic.h>

struct rjd_atomic_int64_c11  { _Atomic int64_t value; };
struct rjd_atomic_int32_c11  { _Atomic int32_t value; };
struct rjd_atomic_int16_c11  { _Atomic int16_t value; };
struct rjd_atomic_int8_c11   { _Atomic int8_t value; };
struct rjd_atomic_uint64_c11 { _Atomic uint64_t value; };
struct rjd_atomic_uint32_c11 { _Atomic uint32_t value; };
struct rjd_atomic_uint16_c11 { _Atomic uint16_t value; };
struct rjd_atomic_uint8_c11  { _Atomic uint8_t value; };

RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_int64_c11) <= sizeof(struct rjd_atomic_int64));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_int32_c11) <= sizeof(struct rjd_atomic_int32));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_int16_c11) <= sizeof(struct rjd_atomic_int16));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_int8_c11) <= sizeof(struct rjd_atomic_int8));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_uint64_c11) <= sizeof(struct rjd_atomic_uint64));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_uint32_c11) <= sizeof(struct rjd_atomic_uint32));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_uint16_c11) <= sizeof(struct rjd_atomic_uint16));
RJD_STATIC_ASSERT(sizeof(struct rjd_atomic_uint8_c11) <= sizeof(struct rjd_atomic_uint8));

////////////////////////////////////////////////////////////////////////////////
// Implementation

struct rjd_atomic_int64 rjd_atomic_int64_init(int64_t value)
{
	struct rjd_atomic_int64 atomic;
	struct rjd_atomic_int64_c11* atomic_c11 = (struct rjd_atomic_int64_c11*)&atomic;
	atomic_store(&atomic_c11->value, value);
	return atomic;
}

int64_t rjd_atomic_int64_get(struct rjd_atomic_int64* atomic)
{
	struct rjd_atomic_int64_c11* atomic_c11 = (struct rjd_atomic_int64_c11*)atomic;
	return atomic_load(&atomic_c11->value);
}

int64_t rjd_atomic_int64_set(struct rjd_atomic_int64* atomic, int64_t value)
{
	struct rjd_atomic_int64_c11* atomic_c11 = (struct rjd_atomic_int64_c11*)atomic;
	atomic_store(&atomic_c11->value, value);
	return value;
}

int64_t rjd_atomic_int64_add(struct rjd_atomic_int64* atomic, int64_t value)
{
	struct rjd_atomic_int64_c11* atomic_c11 = (struct rjd_atomic_int64_c11*)atomic;
	return atomic_fetch_add(&atomic_c11->value, value) + value;
}

int64_t rjd_atomic_int64_sub(struct rjd_atomic_int64* atomic, int64_t value)
{
	struct rjd_atomic_int64_c11* atomic_c11 = (struct rjd_atomic_int64_c11*)atomic;
	return atomic_fetch_sub(&atomic_c11->value, value) - value;
}

int64_t rjd_atomic_int64_inc(struct rjd_atomic_int64* atomic)
{
	return rjd_atomic_int64_add(atomic, 1);
}

int64_t rjd_atomic_int64_dec(struct rjd_atomic_int64* atomic)
{
	return rjd_atomic_int64_sub(atomic, 1);
}

bool rjd_atomic_int64_compare_exchange(struct rjd_atomic_int64* atomic, int64_t* expected, int64_t desired)
{
	struct rjd_atomic_int64_c11* atomic_c11 = (struct rjd_atomic_int64_c11*)atomic;
	return atomic_compare_exchange_strong(&atomic_c11->value, expected, desired);
}

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_int32 rjd_atomic_int32_init(int32_t value)
{
	struct rjd_atomic_int32 atomic;
	struct rjd_atomic_int32_c11* atomic_c11 = (struct rjd_atomic_int32_c11*)&atomic;
	atomic_store(&atomic_c11->value, value);
	return atomic;
}

int32_t rjd_atomic_int32_get(struct rjd_atomic_int32* atomic)
{
	struct rjd_atomic_int32_c11* atomic_c11 = (struct rjd_atomic_int32_c11*)atomic;
	return atomic_load(&atomic_c11->value);
}

int32_t rjd_atomic_int32_set(struct rjd_atomic_int32* atomic, int32_t value)
{
	struct rjd_atomic_int32_c11* atomic_c11 = (struct rjd_atomic_int32_c11*)atomic;
	atomic_store(&atomic_c11->value, value);
	return value;
}

int32_t rjd_atomic_int32_add(struct rjd_atomic_int32* atomic, int32_t value)
{
	struct rjd_atomic_int32_c11* atomic_c11 = (struct rjd_atomic_int32_c11*)atomic;
	return atomic_fetch_add(&atomic_c11->value, value) + value;
}

int32_t rjd_atomic_int32_sub(struct rjd_atomic_int32* atomic, int32_t value)
{
	struct rjd_atomic_int32_c11* atomic_c11 = (struct rjd_atomic_int32_c11*)atomic;
	return atomic_fetch_sub(&atomic_c11->value, value) - value;
}

int32_t rjd_atomic_int32_inc(struct rjd_atomic_int32* atomic)
{
	return rjd_atomic_int32_add(atomic, 1);
}

int32_t rjd_atomic_int32_dec(struct rjd_atomic_int32* atomic)
{
	return rjd_atomic_int32_sub(atomic, 1);
}

bool rjd_atomic_int32_compare_exchange(struct rjd_atomic_int32* atomic, int32_t* expected, int32_t desired)
{
	struct rjd_atomic_int32_c11* atomic_c11 = (struct rjd_atomic_int32_c11*)atomic;
	return atomic_compare_exchange_strong(&atomic_c11->value, expected, desired);
}

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_int16 rjd_atomic_int16_init(int16_t value)
{
	struct rjd_atomic_int16 atomic;
	struct rjd_atomic_int16_c11* atomic_c11 = (struct rjd_atomic_int16_c11*)&atomic;
	atomic_store(&atomic_c11->value, value);
	return atomic;
}

int16_t rjd_atomic_int16_get(struct rjd_atomic_int16* atomic)
{
	struct rjd_atomic_int16_c11* atomic_c11 = (struct rjd_atomic_int16_c11*)atomic;
	return atomic_load(&atomic_c11->value);
}

int16_t rjd_atomic_int16_set(struct rjd_atomic_int16* atomic, int16_t value)
{
	struct rjd_atomic_int16_c11* atomic_c11 = (struct rjd_atomic_int16_c11*)atomic;
	atomic_store(&atomic_c11->value, value);
	return value;
}

int16_t rjd_atomic_int16_add(struct rjd_atomic_int16* atomic, int16_t value)
{
	struct rjd_atomic_int16_c11* atomic_c11 = (struct rjd_atomic_int16_c11*)atomic;
	return atomic_fetch_add(&atomic_c11->value, value) + value;
}

int16_t rjd_atomic_int16_sub(struct rjd_atomic_int16* atomic, int16_t value)
{
	struct rjd_atomic_int16_c11* atomic_c11 = (struct rjd_atomic_int16_c11*)atomic;
	return atomic_fetch_sub(&atomic_c11->value, value) - value;
}

int16_t rjd_atomic_int16_inc(struct rjd_atomic_int16* atomic)
{
	return rjd_atomic_int16_add(atomic, 1);
}

int16_t rjd_atomic_int16_dec(struct rjd_atomic_int16* atomic)
{
	return rjd_atomic_int16_sub(atomic, 1);
}

bool rjd_atomic_int16_compare_exchange(struct rjd_atomic_int16* atomic, int16_t* expected, int16_t desired)
{
	struct rjd_atomic_int16_c11* atomic_c11 = (struct rjd_atomic_int16_c11*)atomic;
	return atomic_compare_exchange_strong(&atomic_c11->value, expected, desired);
}

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_int8 rjd_atomic_int8_init(int8_t value)
{
	struct rjd_atomic_int8 atomic;
	struct rjd_atomic_int8_c11* atomic_c11 = (struct rjd_atomic_int8_c11*)&atomic;
	atomic_store(&atomic_c11->value, value);
	return atomic;
}

int8_t rjd_atomic_int8_get(struct rjd_atomic_int8* atomic)
{
	struct rjd_atomic_int8_c11* atomic_c11 = (struct rjd_atomic_int8_c11*)atomic;
	return atomic_load(&atomic_c11->value);
}

int8_t rjd_atomic_int8_set(struct rjd_atomic_int8* atomic, int8_t value)
{
	struct rjd_atomic_int8_c11* atomic_c11 = (struct rjd_atomic_int8_c11*)atomic;
	atomic_store(&atomic_c11->value, value);
	return value;
}

int8_t rjd_atomic_int8_add(struct rjd_atomic_int8* atomic, int8_t value)
{
	struct rjd_atomic_int8_c11* atomic_c11 = (struct rjd_atomic_int8_c11*)atomic;
	return atomic_fetch_add(&atomic_c11->value, value) + value;
}

int8_t rjd_atomic_int8_sub(struct rjd_atomic_int8* atomic, int8_t value)
{
	struct rjd_atomic_int8_c11* atomic_c11 = (struct rjd_atomic_int8_c11*)atomic;
	return atomic_fetch_sub(&atomic_c11->value, value) - value;
}

int8_t rjd_atomic_int8_inc(struct rjd_atomic_int8* atomic)
{
	return rjd_atomic_int8_add(atomic, 1);
}

int8_t rjd_atomic_int8_dec(struct rjd_atomic_int8* atomic)
{
	return rjd_atomic_int8_sub(atomic, 1);
}

bool rjd_atomic_int8_compare_exchange(struct rjd_atomic_int8* atomic, int8_t* expected, int8_t desired)
{
	struct rjd_atomic_int8_c11* atomic_c11 = (struct rjd_atomic_int8_c11*)atomic;
	return atomic_compare_exchange_strong(&atomic_c11->value, expected, desired);
}

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_uint64 rjd_atomic_uint64_init(uint64_t value)
{
	struct rjd_atomic_uint64 atomic;
	struct rjd_atomic_uint64_c11* atomic_c11 = (struct rjd_atomic_uint64_c11*)&atomic;
	atomic_store(&atomic_c11->value, value);
	return atomic;
}

uint64_t rjd_atomic_uint64_get(struct rjd_atomic_uint64* atomic)
{
	struct rjd_atomic_uint64_c11* atomic_c11 = (struct rjd_atomic_uint64_c11*)atomic;
	return atomic_load(&atomic_c11->value);
}

uint64_t rjd_atomic_uint64_set(struct rjd_atomic_uint64* atomic, uint64_t value)
{
	struct rjd_atomic_uint64_c11* atomic_c11 = (struct rjd_atomic_uint64_c11*)atomic;
	atomic_store(&atomic_c11->value, value);
	return value;
}

uint64_t rjd_atomic_uint64_add(struct rjd_atomic_uint64* atomic, uint64_t value)
{
	struct rjd_atomic_uint64_c11* atomic_c11 = (struct rjd_atomic_uint64_c11*)atomic;
	return atomic_fetch_add(&atomic_c11->value, value) + value;
}

uint64_t rjd_atomic_uint64_sub(struct rjd_atomic_uint64* atomic, uint64_t value)
{
	struct rjd_atomic_uint64_c11* atomic_c11 = (struct rjd_atomic_uint64_c11*)atomic;
	return atomic_fetch_sub(&atomic_c11->value, value) - value;
}

uint64_t rjd_atomic_uint64_inc(struct rjd_atomic_uint64* atomic)
{
	return rjd_atomic_uint64_add(atomic, 1);
}

uint64_t rjd_atomic_uint64_dec(struct rjd_atomic_uint64* atomic)
{
	return rjd_atomic_uint64_sub(atomic, 1);
}

bool rjd_atomic_uint64_compare_exchange(struct rjd_atomic_uint64* atomic, uint64_t* expected, uint64_t desired)
{
	struct rjd_atomic_uint64_c11* atomic_c11 = (struct rjd_atomic_uint64_c11*)atomic;
	return atomic_compare_exchange_strong(&atomic_c11->value, expected, desired);
}

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_uint32 rjd_atomic_uint32_init(uint32_t value)
{
	struct rjd_atomic_uint32 atomic;
	struct rjd_atomic_uint32_c11* atomic_c11 = (struct rjd_atomic_uint32_c11*)&atomic;
	atomic_store(&atomic_c11->value, value);
	return atomic;
}

uint32_t rjd_atomic_uint32_get(struct rjd_atomic_uint32* atomic)
{
	struct rjd_atomic_uint32_c11* atomic_c11 = (struct rjd_atomic_uint32_c11*)atomic;
	return atomic_load(&atomic_c11->value);
}

uint32_t rjd_atomic_uint32_set(struct rjd_atomic_uint32* atomic, uint32_t value)
{
	struct rjd_atomic_uint32_c11* atomic_c11 = (struct rjd_atomic_uint32_c11*)atomic;
	atomic_store(&atomic_c11->value, value);
	return value;
}

uint32_t rjd_atomic_uint32_add(struct rjd_atomic_uint32* atomic, uint32_t value)
{
	struct rjd_atomic_uint32_c11* atomic_c11 = (struct rjd_atomic_uint32_c11*)atomic;
	return atomic_fetch_add(&atomic_c11->value, value) + value;
}

uint32_t rjd_atomic_uint32_sub(struct rjd_atomic_uint32* atomic, uint32_t value)
{
	struct rjd_atomic_uint32_c11* atomic_c11 = (struct rjd_atomic_uint32_c11*)atomic;
	return atomic_fetch_sub(&atomic_c11->value, value) - value;
}

uint32_t rjd_atomic_uint32_inc(struct rjd_atomic_uint32* atomic)
{
	return rjd_atomic_uint32_add(atomic, 1);
}

uint32_t rjd_atomic_uint32_dec(struct rjd_atomic_uint32* atomic)
{
	return rjd_atomic_uint32_sub(atomic, 1);
}

bool rjd_atomic_uint32_compare_exchange(struct rjd_atomic_uint32* atomic, uint32_t* expected, uint32_t desired)
{
	struct rjd_atomic_uint32_c11* atomic_c11 = (struct rjd_atomic_uint32_c11*)atomic;
	return atomic_compare_exchange_strong(&atomic_c11->value, expected, desired);
}

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_uint16 rjd_atomic_uint16_init(uint16_t value)
{
	struct rjd_atomic_uint16 atomic;
	struct rjd_atomic_uint16_c11* atomic_c11 = (struct rjd_atomic_uint16_c11*)&atomic;
	atomic_store(&atomic_c11->value, value);
	return atomic;
}

uint16_t rjd_atomic_uint16_get(struct rjd_atomic_uint16* atomic)
{
	struct rjd_atomic_uint16_c11* atomic_c11 = (struct rjd_atomic_uint16_c11*)atomic;
	return atomic_load(&atomic_c11->value);
}

uint16_t rjd_atomic_uint16_set(struct rjd_atomic_uint16* atomic, uint16_t value)
{
	struct rjd_atomic_uint16_c11* atomic_c11 = (struct rjd_atomic_uint16_c11*)atomic;
	atomic_store(&atomic_c11->value, value);
	return value;
}

uint16_t rjd_atomic_uint16_add(struct rjd_atomic_uint16* atomic, uint16_t value)
{
	struct rjd_atomic_uint16_c11* atomic_c11 = (struct rjd_atomic_uint16_c11*)atomic;
	return atomic_fetch_add(&atomic_c11->value, value) + value;
}

uint16_t rjd_atomic_uint16_sub(struct rjd_atomic_uint16* atomic, uint16_t value)
{
	struct rjd_atomic_uint16_c11* atomic_c11 = (struct rjd_atomic_uint16_c11*)atomic;
	return atomic_fetch_sub(&atomic_c11->value, value) - value;
}

uint16_t rjd_atomic_uint16_inc(struct rjd_atomic_uint16* atomic)
{
	return rjd_atomic_uint16_add(atomic, 1);
}

uint16_t rjd_atomic_uint16_dec(struct rjd_atomic_uint16* atomic)
{
	return rjd_atomic_uint16_sub(atomic, 1);
}

bool rjd_atomic_uint16_compare_exchange(struct rjd_atomic_uint16* atomic, uint16_t* expected, uint16_t desired)
{
	struct rjd_atomic_uint16_c11* atomic_c11 = (struct rjd_atomic_uint16_c11*)atomic;
	return atomic_compare_exchange_strong(&atomic_c11->value, expected, desired);
}

////////////////////////////////////////////////////////////////////////////////

struct rjd_atomic_uint8 rjd_atomic_uint8_init(uint8_t value)
{
	struct rjd_atomic_uint8 atomic;
	struct rjd_atomic_uint8_c11* atomic_c11 = (struct rjd_atomic_uint8_c11*)&atomic;
	atomic_store(&atomic_c11->value, value);
	return atomic;
}

uint8_t rjd_atomic_uint8_get(struct rjd_atomic_uint8* atomic)
{
	struct rjd_atomic_uint8_c11* atomic_c11 = (struct rjd_atomic_uint8_c11*)atomic;
	return atomic_load(&atomic_c11->value);
}

uint8_t rjd_atomic_uint8_set(struct rjd_atomic_uint8* atomic, uint8_t value)
{
	struct rjd_atomic_uint8_c11* atomic_c11 = (struct rjd_atomic_uint8_c11*)atomic;
	atomic_store(&atomic_c11->value, value);
	return value;
}

uint8_t rjd_atomic_uint8_add(struct rjd_atomic_uint8* atomic, uint8_t value)
{
	struct rjd_atomic_uint8_c11* atomic_c11 = (struct rjd_atomic_uint8_c11*)atomic;
	return atomic_fetch_add(&atomic_c11->value, value) + value;
}

uint8_t rjd_atomic_uint8_sub(struct rjd_atomic_uint8* atomic, uint8_t value)
{
	struct rjd_atomic_uint8_c11* atomic_c11 = (struct rjd_atomic_uint8_c11*)atomic;
	return atomic_fetch_sub(&atomic_c11->value, value) - value;
}

uint8_t rjd_atomic_uint8_inc(struct rjd_atomic_uint8* atomic)
{
	return rjd_atomic_uint8_add(atomic, 1);
}

uint8_t rjd_atomic_uint8_dec(struct rjd_atomic_uint8* atomic)
{
	return rjd_atomic_uint8_sub(atomic, 1);
}

bool rjd_atomic_uint8_compare_exchange(struct rjd_atomic_uint8* atomic, uint8_t* expected, uint8_t desired)
{
	struct rjd_atomic_uint8_c11* atomic_c11 = (struct rjd_atomic_uint8_c11*)atomic;
	return atomic_compare_exchange_strong(&atomic_c11->value, expected, desired);
}

#endif // RJD_PLATFORM
#endif // RJD_IMPL

////////////////////////////////////////////////////////////////////////////////
// rjd_mem.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_MEM_H 1

#if RJD_COMPILER_MSVC
	#include <malloc.h> // _alloca
#else
	#include <alloca.h>
#endif

struct rjd_mem_allocator_stats // TODO use atomics
{
	struct rjd_atomic_uint64 total_size;
	struct {
		struct rjd_atomic_uint64 used;
		struct rjd_atomic_uint64 overhead;
		struct rjd_atomic_uint64 peak;
		struct rjd_atomic_uint64 unused;
		struct rjd_atomic_uint64 allocs;
		struct rjd_atomic_uint64 frees;
	} current;
	struct {
		struct rjd_atomic_uint64 peak;
		struct rjd_atomic_uint64 allocs;
		struct rjd_atomic_uint64 frees;
		struct rjd_atomic_uint64 resets;
	} lifetime;
};

enum
{
	RJD_KB = 1024,
	RJD_MB = 1024 * 1024,
	RJD_GB = 1024 * 1024 * 1024,
};

// TODO realloc
typedef const char* (*rjd_mem_allocator_type_func)(void);
typedef void* (*rjd_mem_allocator_alloc_func)(size_t size, void* optional_heap);
typedef void (*rjd_mem_allocator_free_func)(void* memory);
typedef void (*rjd_mem_allocator_reset_func)(void* optional_heap);

struct rjd_mem_allocator
{
	rjd_mem_allocator_type_func type_func; // must return a static string
	rjd_mem_allocator_alloc_func alloc_func;
	rjd_mem_allocator_free_func free_func;
	rjd_mem_allocator_reset_func reset_func; // optional
	void* optional_heap;

	struct rjd_mem_allocator_stats stats;

	uint32_t debug_sentinel;
};

struct rjd_mem_allocator rjd_mem_allocator_init_default(void);
struct rjd_mem_allocator rjd_mem_allocator_init_linear(void* memblock, size_t size);

const char* rjd_mem_allocator_type(struct rjd_mem_allocator* allocator);
bool rjd_mem_allocator_reset(struct rjd_mem_allocator* allocator);
struct rjd_mem_allocator_stats rjd_mem_allocator_getstats(const struct rjd_mem_allocator* allocator);

void rjd_mem_free(const void* mem);
void rjd_mem_swap(void* restrict mem1, void* restrict mem2, size_t size);

#define rjd_mem_alloc(type, allocator) ((type*)rjd_mem_alloc_impl(sizeof(type), (allocator), 8, true))
#define rjd_mem_alloc_noclear(type, allocator) ((type*)rjd_mem_alloc_impl(sizeof(type), (allocator), 8, false))
#define rjd_mem_alloc_aligned(type, allocator, alignment) ((type*)rjd_mem_alloc_impl(sizeof(type), allocator, alignment, true))
#define rjd_mem_alloc_array(type, count, allocator) ((type*)rjd_mem_alloc_impl(sizeof(type) * count, allocator, 8, true))
#define rjd_mem_alloc_array_noclear(type, count, allocator) ((type*)rjd_mem_alloc_impl(sizeof(type) * count, allocator, 8, false))
#define rjd_mem_alloc_array_aligned(type, count, allocator, alignment) ((type*)rjd_mem_alloc_impl(sizeof(type) * count, allocator, alignment, true))
#define rjd_mem_alloc_array_aligned_noclear(type, count, allocator, alignment) ((type*)rjd_mem_alloc_impl(sizeof(type) * count, allocator, alignment, false))

#if RJD_COMPILER_MSVC
	#define rjd_mem_alloc_stack_noclear(type) (type*)_alloca(sizeof(type))
	#define rjd_mem_alloc_stack_array_noclear(type, count) (type*)_alloca(sizeof(type) * count)
#else
	#define rjd_mem_alloc_stack_noclear(type) (type*)alloca(sizeof(type))
	#define rjd_mem_alloc_stack_array_noclear(type, count) (type*)alloca(sizeof(type) * count)
#endif

#define RJD_MEM_ISALIGNED(p, align) (((uintptr_t)(p) & ((align)-1)) == 0)
#define RJD_MEM_ALIGN(size, align) ((size) + (RJD_MEM_ISALIGNED(size, align) ? 0 : ((align) - ((size) & ((align)-1)))))

void* rjd_mem_alloc_impl(size_t size, struct rjd_mem_allocator* allocator, uint32_t alignment, bool clear);

////////////////////////////////////////////////////////////////////////////////

#if RJD_IMPL

struct rjd_mem_heap_linear
{
	void* base;
	void* next;
	size_t size;
	uint32_t debug_sentinel;
};

struct rjd_mem_allocation_header
{
	struct rjd_mem_allocator* allocator;
	uint16_t offset_to_block_begin_from_user;
	uint32_t total_blocksize;
	uint32_t debug_sentinel;
};

static const char* rjd_mem_allocator_global_type(void);
static void* rjd_mem_allocator_global_alloc(size_t size, void* heap);
static void rjd_mem_allocator_global_free(void* mem);

static const char* rjd_mem_allocator_linear_type(void);
static void* rjd_mem_allocator_linear_alloc(size_t size, void* heap);
static void rjd_mem_allocator_linear_reset(void* heap);

const uint32_t RJD_MEM_DEBUG_DEFAULT_SENTINEL32 = 0xA7A7A7A7u;
const uint32_t RJD_MEM_DEBUG_LINEAR_SENTINEL32 = 0xA8A8A8A8u;
const uint32_t RJD_MEM_STATS_UNKNOWN_UPPERBOUND = UINT32_MAX;

struct rjd_mem_allocator rjd_mem_allocator_init_default()
{
	struct rjd_mem_allocator allocator = {
		.type_func = rjd_mem_allocator_global_type,
		.alloc_func = NULL,
		.free_func = NULL,
		.reset_func = NULL,
		.optional_heap = NULL,
		.debug_sentinel = RJD_MEM_DEBUG_DEFAULT_SENTINEL32,
	};

	rjd_atomic_uint64_set(&allocator.stats.total_size, RJD_MEM_STATS_UNKNOWN_UPPERBOUND);
	rjd_atomic_uint64_set(&allocator.stats.current.unused, RJD_MEM_STATS_UNKNOWN_UPPERBOUND);

	// MSVC has a slightly different signature for malloc/free so to avoid platform-specific
	// code, we just wrap them for all platforms here
	allocator.alloc_func = rjd_mem_allocator_global_alloc;
	allocator.free_func = rjd_mem_allocator_global_free;

	return allocator;
}

struct rjd_mem_allocator rjd_mem_allocator_init_linear(void* memblock, size_t size)
{
	RJD_ASSERT(memblock);

	struct rjd_mem_heap_linear* heap = (struct rjd_mem_heap_linear*)RJD_MEM_ALIGN((uintptr_t)memblock, 64);
	uint32_t usable_size = 0;
	{
		char* usable_memory_start = (char*)RJD_MEM_ALIGN((uintptr_t)heap + sizeof(struct rjd_mem_heap_linear), 64);
		char* usable_memory_end = (char*)memblock + size;
		RJD_ASSERTMSG(usable_memory_start < usable_memory_end, 
			"Given size was not large enough to make a heap. You need at least 128 bytes...");

		usable_size = (uint32_t)(usable_memory_end - usable_memory_start);

		struct rjd_mem_heap_linear copy = { 
			.base = usable_memory_start, 
			.next = usable_memory_start, 
			.size = usable_size, 
			.debug_sentinel = RJD_MEM_DEBUG_LINEAR_SENTINEL32 
		};
		*heap = copy;
	}

	struct rjd_mem_allocator allocator = {
		.type_func = rjd_mem_allocator_linear_type,
		.alloc_func = rjd_mem_allocator_linear_alloc,
		.free_func = NULL,
		.reset_func = rjd_mem_allocator_linear_reset,
		.optional_heap = heap,
		.debug_sentinel = RJD_MEM_DEBUG_LINEAR_SENTINEL32,
	};

	rjd_atomic_uint64_set(&allocator.stats.total_size, usable_size);
	rjd_atomic_uint64_set(&allocator.stats.current.unused, usable_size);

	return allocator;
}

const char* rjd_mem_allocator_type(struct rjd_mem_allocator* allocator)
{
	RJD_ASSERT(allocator);
	return allocator->type_func();
}

bool rjd_mem_allocator_reset(struct rjd_mem_allocator* allocator)
{
	RJD_ASSERT(allocator);

	rjd_atomic_uint64_set(&allocator->stats.current.used, 0);
	rjd_atomic_uint64_set(&allocator->stats.current.overhead, 0);
	rjd_atomic_uint64_set(&allocator->stats.current.peak, 0);
	rjd_atomic_uint64_set(&allocator->stats.current.unused, rjd_atomic_uint64_get(&allocator->stats.total_size));
	rjd_atomic_uint64_set(&allocator->stats.current.allocs, 0);
	rjd_atomic_uint64_set(&allocator->stats.current.frees, 0);
	rjd_atomic_uint64_inc(&allocator->stats.lifetime.resets);

	if (allocator->reset_func) {
		allocator->reset_func(allocator->optional_heap);
		return true;
	}
	return false;
}

struct rjd_mem_allocator_stats rjd_mem_allocator_getstats(const struct rjd_mem_allocator* allocator)
{
	RJD_ASSERT(allocator);
	return allocator->stats;
}

void* rjd_mem_alloc_impl(size_t size, struct rjd_mem_allocator* allocator, uint32_t alignment, bool clear)
{
	RJD_ASSERT(allocator);
	RJD_ASSERT(alignment >= 8);

	if (size == 0) {
		size = 8;
	}

	const uint32_t header_size = sizeof(struct rjd_mem_allocation_header);
    const uint32_t alignment_padding = alignment * 2;
	const uint32_t total_size = (uint32_t)size + header_size + alignment_padding;
    
   	char* raw = allocator->alloc_func(total_size, allocator->optional_heap);
	if (raw == NULL) {
		return raw;
	}

	if (clear) {
		memset(raw, 0, total_size);
	}

	uintptr_t aligned_user = RJD_MEM_ALIGN((uintptr_t)raw + alignment + header_size, alignment);

    const ptrdiff_t offset_to_block_begin_from_user = aligned_user - (uintptr_t)raw;
    RJD_ASSERT(offset_to_block_begin_from_user < UINT16_MAX);
    
	struct rjd_mem_allocation_header* header = (void*)(aligned_user - header_size);
	header->allocator = allocator;
	header->total_blocksize = (uint32_t)total_size;
    header->offset_to_block_begin_from_user = (uint16_t)offset_to_block_begin_from_user;
	header->debug_sentinel = allocator->debug_sentinel;

	// stats tracking
	{
		rjd_atomic_uint64_add(&allocator->stats.current.used, total_size);
		rjd_atomic_uint64_add(&allocator->stats.current.overhead, total_size - size);

		while (true) {
			uint64_t old_peak = rjd_atomic_uint64_get(&allocator->stats.current.peak);
			uint64_t new_peak = rjd_atomic_uint64_get(&allocator->stats.current.used);

			if (new_peak <= old_peak || 
				rjd_atomic_uint64_compare_exchange(&allocator->stats.current.peak, &old_peak, new_peak)) {
				break;
			}
		}

		while (true) {
			uint64_t old_peak = rjd_atomic_uint64_get(&allocator->stats.lifetime.peak);
			uint64_t new_peak = rjd_atomic_uint64_get(&allocator->stats.current.used);

			if (new_peak <= old_peak || 
				rjd_atomic_uint64_compare_exchange(&allocator->stats.lifetime.peak,  &old_peak, new_peak)) {
				break;
			}
		}

		uint64_t unused = rjd_atomic_uint64_get(&allocator->stats.current.unused);
		if (unused != RJD_MEM_STATS_UNKNOWN_UPPERBOUND) {
			RJD_ASSERT(unused >= total_size);
			rjd_atomic_uint64_sub(&allocator->stats.current.unused, total_size);
		}

		rjd_atomic_uint64_inc(&allocator->stats.current.allocs);
		rjd_atomic_uint64_inc(&allocator->stats.lifetime.allocs);
	}

	return (void*)aligned_user;
}

void rjd_mem_free(const void* mem)
{
	if (!mem) {
		return;
	}

	char* raw = (void*)mem;
	struct rjd_mem_allocation_header* header = (void*)(raw - sizeof(struct rjd_mem_allocation_header));
	struct rjd_mem_allocator* allocator = header->allocator;

	RJD_ASSERTMSG(header->debug_sentinel == allocator->debug_sentinel, "This memory was not allocated with rjd_mem_alloc.");

	if (allocator->free_func) {
		{
			uint64_t used = rjd_atomic_uint64_get(&allocator->stats.current.used);
			RJD_ASSERTMSG(used >= header->total_blocksize, "Allocator used (%llu) must be >= block size (%llu)", used, header->total_blocksize);
		}
		rjd_atomic_uint64_sub(&allocator->stats.current.used, header->total_blocksize);

		if (rjd_atomic_uint64_get(&allocator->stats.current.unused) != RJD_MEM_STATS_UNKNOWN_UPPERBOUND) {
			rjd_atomic_uint64_add(&allocator->stats.current.unused, header->total_blocksize);
		}
		rjd_atomic_uint64_inc(&allocator->stats.current.frees);
		rjd_atomic_uint64_inc(&allocator->stats.lifetime.frees);
        
        char* begin = raw - header->offset_to_block_begin_from_user;
        allocator->free_func(begin);
	}
}

void rjd_mem_swap(void* restrict mem1, void* restrict mem2, size_t size)
{
	uint8_t tmp[1024];
	RJD_ASSERTMSG(size < (uint32_t)sizeof(tmp), "Increase size of static buffer to at least %u", size);

	memcpy(tmp, mem1, size);
	memcpy(mem1, mem2, size);
	memcpy(mem2, tmp, size);
}

////////////////////////////////////////////////////////////////////////////////
// local helper definitions

const char* rjd_mem_allocator_global_type(void)
{
	return "rjd_global";
}

void* rjd_mem_allocator_global_alloc(size_t size, void* unused_heap)
{
	RJD_UNUSED_PARAM(unused_heap);

	return malloc(size);
}

void rjd_mem_allocator_global_free(void* mem)
{
	free(mem);
}

const char* rjd_mem_allocator_linear_type(void)
{
	return "rjd_linear";
}

void* rjd_mem_allocator_linear_alloc(size_t size, void* optional_heap)
{
	struct rjd_mem_heap_linear* heap = (struct rjd_mem_heap_linear*)optional_heap;
	RJD_ASSERT(heap->debug_sentinel == RJD_MEM_DEBUG_LINEAR_SENTINEL32);

	size_t align_diff = size % 8;
	if (align_diff != 0) {
		size += align_diff;
	}

	if ((char*)heap->next + size <= (char*)heap->base + heap->size) 
	{
		void* mem = (char*)heap->next;
		heap->next = (char*)heap->next + size;

		return mem;
	}

	return NULL;
}

void rjd_mem_allocator_linear_reset(void* optional_heap)
{
	struct rjd_mem_heap_linear* heap = (struct rjd_mem_heap_linear*)optional_heap;
	RJD_ASSERT(heap->debug_sentinel == RJD_MEM_DEBUG_LINEAR_SENTINEL32);

	heap->next = heap->base;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_rng.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_RNG_H 1

struct rjd_rng
{
	uint64_t seed;
	uint64_t state;
};

struct rjd_rng rjd_rng_init(uint64_t seed);
uint64_t rjd_rng_next(struct rjd_rng* rng);
double rjd_rng_float(struct rjd_rng* rng);
int32_t rjd_rng_range32(struct rjd_rng* rng, int32_t min_inclusive, int32_t max_exclusive);

#if RJD_IMPL

struct rjd_rng rjd_rng_init(uint64_t seed)
{
	struct rjd_rng rng = { seed, seed };
	return rng;
}

uint64_t rjd_rng_next(struct rjd_rng* rng)
{
	rng->state ^= rng->state << 15;
	rng->state ^= rng->state >> 3;
	rng->state ^= rng->state << 52;
	return rng->state;
}

double rjd_rng_float(struct rjd_rng* rng)
{
	uint64_t next = rjd_rng_next(rng) % 1000001ull;
	return (double)next / 1000000.0;
}

int32_t rjd_rng_range32(struct rjd_rng* rng, int32_t min_inclusive, int32_t max_exclusive)
{
	if (max_exclusive < min_inclusive) {
		return max_exclusive;
	}

	int32_t range = max_exclusive - min_inclusive;
	if (range == 0) {
		return min_inclusive;
	}

	uint64_t next = rjd_rng_next(rng);
	return min_inclusive + (next % range);
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_array.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_ARRAY_H 1

// static array count
// Note that GCC is awesome and has a warning if buf is a pointer. See -Wsizeof-pointer-div
#define rjd_countof(buf) (sizeof(buf) / sizeof(*(buf)))

// dyanmic array
#define rjd_array_alloc(type, capacity, allocator)	((type*)(rjd_array_alloc_impl((capacity), (allocator), sizeof(type))))
#define rjd_array_clone(buf, allocator)				rjd_array_clone_impl((buf), allocator, sizeof(*(buf)))
#define rjd_array_free(buf)							rjd_array_free_impl(buf)
#define rjd_array_capacity(buf) 					((buf)?(const uint32_t)(*rjd_array_capacity_impl(buf)):0)
#define rjd_array_count(buf) 						((buf)?(const uint32_t)(*rjd_array_count_impl(buf)):0)
#define rjd_array_clear(buf)						(*rjd_array_count_impl(buf) = 0)
#define rjd_array_reserve(buf, capacity)			(buf = rjd_array_reserve_impl((buf), capacity, sizeof(*(buf))))
#define rjd_array_resize(buf, size) 				(buf = rjd_array_resize_impl((buf), size, sizeof(*(buf))))
#define rjd_array_trim(buf)							(buf = rjd_array_trim_impl((buf), sizeof(*(buf))))
#define rjd_array_erase(buf, index) 				rjd_array_erase_impl((buf), index, sizeof(*(buf)))
#define rjd_array_erase_unordered(buf, index) 		rjd_array_erase_unordered_impl((buf), index, sizeof(*(buf)))
#define rjd_array_empty(buf) 						(rjd_array_count(buf) == 0)
#define rjd_array_full(buf) 						(rjd_array_count(buf) == rjd_array_capacity(buf))
#define rjd_array_push(buf, value) 					(buf = rjd_array_push_impl((buf), \
													sizeof(*(buf))), (buf)[rjd_array_count(buf) - 1] = value)
#define rjd_array_pop(buf)		 					(rjd_array_pop_impl(buf), 		\
													--*rjd_array_count_impl(buf), 	\
													*(buf + rjd_array_count(buf)))
#define rjd_array_insert(buf, ptr, index)			(buf = rjd_array_insert_impl((buf), (ptr), sizeof(*(buf)), index))
#define rjd_array_get(buf, index)					(rjd_array_get_validate((buf), (index)), (buf + index))
#define rjd_array_first(buf)						(rjd_array_get_validate((buf), 0), (buf)[0])
#define rjd_array_last(buf)							(rjd_array_get_validate((buf), 0), (buf)[rjd_array_count(buf) - 1])

// searching/sorting
typedef int32_t RJD_COMPILER_MSVC_ONLY(__cdecl) rjd_array_compare_func(const void* left, const void* right);
typedef int32_t RJD_COMPILER_MSVC_ONLY(__cdecl) rjd_array_compare_c_func(void* context, const void* left, const void* right);

enum { RJD_ARRAY_NOT_FOUND = -1 };

#define rjd_array_find(buf, ptr)						rjd_array_find_impl((buf), (ptr), sizeof(*(buf)), RJD_MUST_BE_SAME_TYPE_TEST((buf), (ptr)))
#define rjd_array_contains(buf, ptr)					rjd_array_contains_impl((buf), (ptr), sizeof(*(buf)), RJD_MUST_BE_SAME_TYPE_TEST((buf), (ptr)))

// These functions sort or deal with sorted data
#define rjd_array_sort(buf, comparer) \
		rjd_array_sort_impl((buf), sizeof(*(buf)), comparer)
#define rjd_array_lowerbound(buf, ptr, comparer) \
		rjd_array_lowerbound_impl((buf), ptr, sizeof(*(buf)), comparer, RJD_MUST_BE_SAME_TYPE_TEST((buf), (ptr)))
#define rjd_array_find_sorted(buf, ptr, comparer) \
		rjd_array_find_sorted_impl((buf), (ptr), sizeof(*(buf)), comparer, RJD_MUST_BE_SAME_TYPE_TEST((buf), (ptr)))
#define rjd_array_contains_sorted(buf, ptr, comparer) \
		rjd_array_contains_sorted_impl((buf), (ptr), sizeof(*(buf)), comparer, RJD_MUST_BE_SAME_TYPE_TEST((buf), (ptr)))

// These versions of the sort/find sorted functions allow you to provide a content parameter that 
// is passed into the compare func.
#define rjd_array_sort_c(buf, comparer, context) \
		rjd_array_sort_c_impl((buf), sizeof(*(buf)), comparer, context)
#define rjd_array_lowerbound_c(buf, ptr, comparer, context) \
		rjd_array_lowerbound_c_impl((buf), (ptr), sizeof(*(buf)), comparer, context, RJD_MUST_BE_SAME_TYPE_TEST((buf), (ptr)))
#define rjd_array_find_sorted_c(buf, ptr, comparer, context) \
		rjd_array_find_sorted_c_impl((buf), (ptr), sizeof(*(buf)), comparer, context, RJD_MUST_BE_SAME_TYPE_TEST((buf), (ptr)))
#define rjd_array_contains_sorted_c(buf, ptr, comparer, context) \
		rjd_array_contains_sorted_c_impl((buf), (ptr), sizeof(*(buf)), comparer, context, RJD_MUST_BE_SAME_TYPE_TEST((buf), (ptr)))

// predicate helpers for the functional-style interface
#define rjd_array_sum_predicate(acc, element) 		(acc + element)

// functional-style helpers
#define rjd_array_filter(buf, predicate, context)	for(int _i = (int)rjd_array_count(buf) - 1; _i >= 0; --_i) { 	 	\
															if (!(predicate((buf)[_i]))) { rjd_array_erase((buf), _i); } \
													}
#define rjd_array_map(in, out, predicate)			rjd_array_resize((out), rjd_array_count(in)); 					\
													for (size_t _i = 0; _i < rjd_array_count(in); ++_i) {			\
														out[_i] = predicate(in[_i]); 								\
													}
#define rjd_array_reduce(buf, acc, predicate)		for(size_t _i = 0; _i < rjd_array_count(buf); ++_i) {			\
														(acc) = predicate(acc, ((buf)[_i]));						\
													}
#define rjd_array_sum(buf, acc)						for(size_t _i = 0; _i < rjd_array_count(buf); ++_i) {			\
														(acc) = rjd_array_sum_predicate((acc), ((buf)[_i]));		\
													}
#define rjd_array_reverse(buf)						rjd_array_reverse_impl(buf, sizeof(*buf))

// randomness helpers
#define rjd_array_sample(buf, rng)					((buf)[rjd_rng_range32(rng, 0, rjd_array_count(buf))])
#define rjd_array_shuffle(buf, rng)					rjd_array_shuffle_impl(buf, rng, sizeof(*buf))

struct rjd_mem_allocator;
struct rjd_rng;

void* rjd_array_alloc_impl(uint32_t capacity, struct rjd_mem_allocator* allocator, size_t sizeof_type);
void* rjd_array_clone_impl(const void* array, struct rjd_mem_allocator* allocator, size_t sizeof_type);
void rjd_array_free_impl(const void* array);
uint32_t* rjd_array_capacity_impl(const void* array);
uint32_t* rjd_array_count_impl(const void* array);
void* rjd_array_reserve_impl(void* array, uint32_t newcapacity, size_t sizeof_type);
void* rjd_array_resize_impl(void* array, uint32_t newcount, size_t sizeof_type);
void* rjd_array_trim_impl(void* array, size_t sizeof_type);
void rjd_array_erase_impl(void* array, uint32_t index, size_t sizeof_type);
void rjd_array_erase_unordered_impl(void* array, uint32_t index, size_t sizeof_type);
void* rjd_array_push_impl(void* array, size_t sizeof_type);
void rjd_array_pop_impl(void* array);
void* rjd_array_insert_impl(void* array, const void* insert, size_t sizeof_type, uint32_t index);
void rjd_array_get_validate(void* array, uint32_t index);
int32_t rjd_array_find_impl(const void* array, const void* search, size_t sizeof_type, int unused);
bool rjd_array_contains_impl(const void* array, const void* search, size_t sizeof_type, int unused);
void rjd_array_sort_impl(void* array, size_t sizeof_type, rjd_array_compare_func* comparer);
int32_t rjd_array_lowerbound_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_func* comparer, int unused);
int32_t rjd_array_find_sorted_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_func* comparer, int unused);
bool rjd_array_contains_sorted_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_func* comparer, int unused);
void rjd_array_sort_c_impl(void* array, size_t sizeof_type, rjd_array_compare_c_func* comparer, void* context);
int32_t rjd_array_lowerbound_c_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_c_func* comparer, void* context, int unused);
int32_t rjd_array_find_sorted_c_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_c_func* comparer, void* context, int unused);
bool rjd_array_contains_sorted_c_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_c_func* comparer, void* context, int unused);
void rjd_array_shuffle_impl(void* array, struct rjd_rng* rng, size_t sizeof_type);
void rjd_array_reverse_impl(void* array, size_t sizeof_type);

#if RJD_IMPL

// Copied from stdlib.h. We want this extra platform functionality but don't want to turn on all the defines
// to get us there.
#if RJD_COMPILER_GCC
void __bsd_qsort_r (void *__base, size_t __nmemb, size_t __size, void *__thunk, int (*_compar)(void *, const void *, const void *));
#  define qsort_r __bsd_qsort_r
#endif

struct rjd_array_header
{
	struct rjd_mem_allocator* allocator;
	uint32_t capacity;
	uint32_t count;
	uint32_t debug_sentinel;
};

const uint32_t RJD_ARRAY_DEBUG_SENTINEL32 = 0xA7A7A7A7;

static struct rjd_array_header* rjd_array_getheader(void* array);
static struct rjd_mem_allocator* rjd_array_allocator(void* array);
static inline void rjd_array_validate(const void* array);
static void* rjd_array_grow(void* array, size_t sizeof_type);

void* rjd_array_alloc_impl(uint32_t capacity, struct rjd_mem_allocator* allocator, size_t sizeof_type)
{
	RJD_ASSERT(capacity > 0);
	RJD_ASSERT(allocator);
	RJD_ASSERT(sizeof_type > 0);

	size_t rawsize = sizeof(struct rjd_array_header) + (sizeof_type * capacity);
	char* raw = rjd_mem_alloc_array(char, rawsize, allocator);

	struct rjd_array_header* header = (struct rjd_array_header*)raw;
	header->allocator = allocator;
	header->capacity = capacity;
	header->count = 0;
	header->debug_sentinel = RJD_ARRAY_DEBUG_SENTINEL32; 

	char* buf = raw + sizeof(struct rjd_array_header);
	return buf;
}

void* rjd_array_clone_impl(const void* array, struct rjd_mem_allocator* allocator, size_t sizeof_type)
{
	uint32_t count = rjd_array_count(array);
	void* clone = rjd_array_alloc_impl(count, allocator, sizeof_type);
	clone = rjd_array_resize_impl(clone, count, sizeof_type);
	memcpy(clone, array, count * sizeof_type);
	return clone;
}

void rjd_array_free_impl(const void* array)
{
	if (!array) {
		return;
	}
	rjd_array_validate(array);

	char* raw = (char*)array;
	rjd_mem_free(raw - sizeof(struct rjd_array_header));
}

uint32_t* rjd_array_capacity_impl(const void* array)
{
	RJD_ASSERT(array);

	rjd_array_validate(array);

	struct rjd_array_header* header = rjd_array_getheader((void*)array);
	return &header->capacity;
}

uint32_t* rjd_array_count_impl(const void* array)
{
	RJD_ASSERT(array);

	rjd_array_validate(array);

	struct rjd_array_header* header = rjd_array_getheader((void*)array);
	return &header->count;
}

void* rjd_array_reserve_impl(void* array, uint32_t newcapacity, size_t sizeof_type)
{
	RJD_ASSERT(array);
	RJD_ASSERT(sizeof_type > 0);

	rjd_array_validate(array);

	uint32_t oldcapacity = rjd_array_capacity(array);

	if (oldcapacity < newcapacity) {
		struct rjd_mem_allocator* allocator = rjd_array_allocator(array);
		char* newarray = rjd_array_alloc_impl(newcapacity, allocator, sizeof_type);

		uint32_t* count = rjd_array_count_impl(newarray);
		*count = rjd_array_count(array);

		memcpy(newarray, array, (*count * sizeof_type));

		rjd_array_free(array);
		return newarray;
	}

	return array;
}

void* rjd_array_resize_impl(void* array, uint32_t newcount, size_t sizeof_type)
{
	RJD_ASSERT(array);
	RJD_ASSERT(sizeof_type > 0);

	rjd_array_validate(array);

	array = rjd_array_reserve_impl(array, newcount, sizeof_type);
	uint32_t* count = rjd_array_count_impl(array);

	// zero new members
	if (newcount > *count) {
		memset((char*)array + (*count * sizeof_type), 0, (newcount - *count) * sizeof_type);
	}

	*count = newcount;
	return array;
}

void* rjd_array_trim_impl(void* array, size_t sizeof_type)
{
	if (rjd_array_count(array) == rjd_array_capacity(array)) {
		return array;
	}

	void* newarray = rjd_array_alloc_impl(rjd_array_count(array), rjd_array_allocator(array), sizeof_type);
	memcpy(newarray, array, rjd_array_count(array) * sizeof_type);
	*rjd_array_count_impl(newarray) = rjd_array_count(array);

	rjd_array_free(array);

	return newarray;
}

void rjd_array_erase_impl(void* array, uint32_t index, size_t sizeof_type)
{
	RJD_ASSERT(array);
	RJD_ASSERT(index < rjd_array_count(array));
	RJD_ASSERT(sizeof_type > 0);

	rjd_array_validate(array);

	char* raw = array;
	size_t toshift = rjd_array_count(array) - index - 1;
	if (toshift > 0) {
		memmove(raw + index * sizeof_type, raw + (index + 1) * sizeof_type, toshift * sizeof_type);
	}
	--*rjd_array_count_impl(array);
}

void rjd_array_erase_unordered_impl(void* array, uint32_t index, size_t sizeof_type)
{
	RJD_ASSERT(array);
	RJD_ASSERT(index < rjd_array_count(array));
	RJD_ASSERT(sizeof_type > 0);

	rjd_array_validate(array);

	char* raw = array;

	uint32_t* count = rjd_array_count_impl(array);

	if (*count > 1) {
		char* erase = raw + index * sizeof_type;
		char* swap = raw + (*count - 1) * sizeof_type;
		memcpy(erase, swap, sizeof_type);
	}

	if (*count > 0) {
		--*rjd_array_count_impl(array);
	}
}

void* rjd_array_push_impl(void* array, size_t sizeof_type) 
{
	array = rjd_array_grow(array, sizeof_type);
	++*rjd_array_count_impl(array);

	// skip init new element to 0 since it will be set in the push macro

	return array;
}

void rjd_array_pop_impl(void* array)
{
	RJD_ASSERT(rjd_array_count(array) > 0);
}

void* rjd_array_insert_impl(void* array, const void* insert, size_t sizeof_type, uint32_t index)
{
	array = rjd_array_grow(array, sizeof_type);
	uint32_t* count = rjd_array_count_impl(array);
	++*count;

	RJD_ASSERT(*count > index);

	void* where_to_insert = (char*)array + sizeof_type * index;
	void* element_after_insert = (char*)where_to_insert + sizeof_type;
	memmove(element_after_insert, where_to_insert, sizeof_type * (*count - index));
	memcpy(where_to_insert, insert, sizeof_type);

	return array;
}

void rjd_array_get_validate(void* array, uint32_t index)
{
	rjd_array_validate(array);
	RJD_ASSERT(index < rjd_array_count(array));
}

int32_t rjd_array_find_impl(const void* array, const void* search, size_t sizeof_type, int unused)
{
	RJD_UNUSED_PARAM(unused);

	rjd_array_validate(array);

	if (!array) {
		return false;
	}

	char* raw = (char*)array;
	for (int32_t i = 0; i < (int32_t)rjd_array_count(array); ++i) {
		if (!memcmp(raw + i * sizeof_type, search, sizeof_type)) {
			return i;
		}
	}
	return RJD_ARRAY_NOT_FOUND;
}

bool rjd_array_contains_impl(const void* array, const void* search, size_t sizeof_type, int unused)
{
	RJD_UNUSED_PARAM(unused);

	const int32_t index = rjd_array_find_impl(array, search, sizeof_type, 0);
	return index != RJD_ARRAY_NOT_FOUND;
}

void rjd_array_sort_impl(void* array, size_t sizeof_type, rjd_array_compare_func* comparer)
{
	rjd_array_validate(array);
	size_t length = rjd_array_count(array);
	qsort(array, length, sizeof_type, comparer);
}

int32_t rjd_array_lowerbound_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_func* comparer, int unused)
{
	RJD_UNUSED_PARAM(unused);

	rjd_array_validate(array);

	uint32_t length = rjd_array_count(array);

	if (length == 0) {
		return 0;
	}

	int32_t first = 0;
	int32_t index = 0;
	
	while (length > 0)
	{
		int32_t step = length / 2;
		index = first + step;

		const void* value = (const char*)array + index * sizeof_type;
		const int32_t compared_value = comparer(value, needle);

		if (compared_value < 0) {
			++index;
			first = index;
			length -= step + 1;
		} else if (compared_value > 0) {
			length = step;
		} else {
			break;
		}
	}
	return index;
}

int32_t rjd_array_find_sorted_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_func* comparer, int unused)
{
	RJD_UNUSED_PARAM(unused);

	const int32_t index = rjd_array_lowerbound_impl(array, needle, sizeof_type, comparer, 0);
	const void* value = (const char*)array + (index * sizeof_type);
	if (comparer(array, value) == 0) {
		return index;
	}
	return RJD_ARRAY_NOT_FOUND;
}

bool rjd_array_contains_sorted_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_func* comparer, int unused)
{
	RJD_UNUSED_PARAM(unused);

	const int32_t index = rjd_array_find_sorted_impl(array, needle, sizeof_type, comparer, 0);
	return index != RJD_ARRAY_NOT_FOUND;
}

void rjd_array_sort_c_impl(void* array, size_t sizeof_type, rjd_array_compare_c_func* comparer, void* context)
{
	rjd_array_validate(array);
	const size_t length = rjd_array_count(array);
#if RJD_COMPILER_MSVC
	qsort_s(array, length, sizeof_type, comparer, context);
#else
	qsort_r(array, length, sizeof_type, context, comparer);
#endif
}

int32_t rjd_array_lowerbound_c_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_c_func* comparer, void* context, int unused)
{
	RJD_UNUSED_PARAM(unused);

	rjd_array_validate(array);

	uint32_t length = rjd_array_count(array);

	if (length == 0) {
		return 0;
	}

	int32_t first = 0;
	int32_t index = 0;
	
	while (length > 0)
	{
		int32_t step = length / 2;
		index = first + step;

		const void* value = (const char*)array + index * sizeof_type;
		const int32_t compared_value = comparer(context, value, needle);

		if (compared_value < 0) {
			++index;
			first = index;
			length -= step + 1;
		} else if (compared_value > 0) {
			length = step;
		} else {
			break;
		}
	}
	return index;
}

int32_t rjd_array_find_sorted_c_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_c_func* comparer, void* context, int unused)
{
	RJD_UNUSED_PARAM(unused);

	const int32_t index = rjd_array_lowerbound_c_impl(array, needle, sizeof_type, comparer, context, 0);
	const void* value = (const char*)array + (index * sizeof_type);
	if (comparer(context, array, value) == 0) {
		return index;
	}
	return RJD_ARRAY_NOT_FOUND;
}

bool rjd_array_contains_sorted_c_impl(const void* array, const void* needle, size_t sizeof_type, rjd_array_compare_c_func* comparer, void* context, int unused)
{
	RJD_UNUSED_PARAM(unused);

	const int32_t index = rjd_array_find_sorted_c_impl(array, needle, sizeof_type, comparer, context, 0);
	return index != RJD_ARRAY_NOT_FOUND;
}

void rjd_array_shuffle_impl(void* array, struct rjd_rng* rng, size_t sizeof_type)
{
	if (!array) {
		return;
	}

	rjd_array_validate(array);

	char tmp[512];
	RJD_ASSERTMSG(sizeof_type <= sizeof(tmp), 
		"tmp (%u bytes) must be greater than or equal to sizeof_type (%u bytes)", 
		(unsigned) sizeof(tmp), (unsigned) sizeof_type);

	char* raw = (char*)array;
	for (uint32_t i = 0; i < rjd_array_count(array); ++i) {
		uint32_t k = rjd_rng_range32(rng, 0, rjd_array_count(array));
		if (i == k) {
			continue;
		}

		char* a = raw + (i * sizeof_type);
		char* b = raw + (k * sizeof_type);

		memcpy(tmp, a, sizeof_type);
		memcpy(a, b, sizeof_type);
		memcpy(b, tmp, sizeof_type);
	}
}

void rjd_array_reverse_impl(void* array, size_t sizeof_type)
{
	if (!array) {
		return;
	}
	rjd_array_validate(array);

	uint8_t* raw = array;
	for (uint8_t* begin = raw, *end = raw + (int32_t)sizeof_type * ((int32_t)rjd_array_count(array) - 1); 
		begin < end; 
		begin += sizeof_type, end -= sizeof_type)
	{
		rjd_mem_swap(begin, end, sizeof_type);
	}
}

////////////////////////////////////////////////////////////////////////////////
// local helpers

static struct rjd_array_header* rjd_array_getheader(void* array)
{
	if (!array) {
		return NULL;
	}
	rjd_array_validate(array);

	char* raw = array;
	char* raw_header = raw - sizeof(struct rjd_array_header);
	return (struct rjd_array_header*) raw_header;
}

static struct rjd_mem_allocator* rjd_array_allocator(void* array)
{
	RJD_ASSERT(array);
	return rjd_array_getheader(array)->allocator;
}

static inline void rjd_array_validate(const void* array)
{
	RJD_ASSERT(array);
	const char* raw = array;
	const struct rjd_array_header* header = (struct rjd_array_header*)(raw - sizeof(struct rjd_array_header));
	RJD_ASSERTMSG(header->debug_sentinel == RJD_ARRAY_DEBUG_SENTINEL32, 
		"Debug sentinel was either corrupted by an underrun or this is not an rjd_array.");
	RJD_UNUSED_PARAM(header);
}

static void* rjd_array_grow(void* array, size_t sizeof_type)
{
	RJD_ASSERT(array);
	RJD_ASSERT(sizeof_type > 0);

	rjd_array_validate(array);

	uint32_t count = rjd_array_count(array);
	uint32_t capacity = rjd_array_capacity(array);
	if (count == capacity) {
		array = rjd_array_reserve_impl(array, capacity * 2, sizeof_type);
	}
	return array;
}

#endif //RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_math.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

// SSE3 math library with some functions for normal floats

#define RJD_MATH_H 1

#define RJD_MATH_PI (3.141592653589793238462643f)
#define RJD_MATH_EPSILON (0.000001)

////////////////////////////////////////////////////////////////////////////////
// utils

static inline uint32_t rjd_math_next_pow2(uint32_t v);
static inline int32_t rjd_math_pow32(int32_t v, uint32_t power);

#define RJD_MATH_DECLARE_SIGN_FUNC(name, type) static inline type name(type v);
#define RJD_MATH_DEFINE_SIGN_FUNC(name, type) static inline type name(type v) { return (v < 0) ? (type)-1 : (type)1; }
#define RJD_MATH_SIGN_FUNCS(xmacro)		\
	xmacro(rjd_math_sign32, int32_t)	\
	xmacro(rjd_math_sign, double)		\
	xmacro(rjd_math_signf, float)
RJD_MATH_SIGN_FUNCS(RJD_MATH_DECLARE_SIGN_FUNC)

#define RJD_MATH_DECLARE_ISEQUAL_FUNC(name, type) static inline bool name(type a, type b);
#define RJD_MATH_DEFINE_ISEQUAL_FUNC(name, type) static inline bool name(type a, type b) { return (type)fabs(a - b) < RJD_MATH_EPSILON; }
#define RJD_MATH_ISEQUAL_FUNCS(xmacro)	\
	xmacro(rjd_math_isequal, double)	\
	xmacro(rjd_math_isequalf, float)
RJD_MATH_ISEQUAL_FUNCS(RJD_MATH_DECLARE_ISEQUAL_FUNC)

#define RJD_MATH_DECLARE_MIN_FUNC(name, type) static inline type name(type a, type b);
#define RJD_MATH_DEFINE_MIN_FUNC(name, type) static inline type name(type a, type b) { return (a < b) ? a : b; }
#define RJD_MATH_MIN_FUNCS(xmacro)		\
	xmacro(rjd_math_min32, int32_t)		\
	xmacro(rjd_math_min64, int64_t)		\
	xmacro(rjd_math_minu32, uint32_t)	\
	xmacro(rjd_math_minu64, uint64_t)
RJD_MATH_MIN_FUNCS(RJD_MATH_DECLARE_MIN_FUNC)

#define RJD_MATH_DECLARE_MAX_FUNC(name, type) static inline type name(type a, type b);
#define RJD_MATH_DEFINE_MAX_FUNC(name, type) static inline type name(type a, type b) { return (a < b) ? b : a; }
#define RJD_MATH_MAX_FUNCS(xmacro)		\
	xmacro(rjd_math_max32, int32_t)		\
	xmacro(rjd_math_max64, int64_t)		\
	xmacro(rjd_math_maxu64, uint64_t)	\
	xmacro(rjd_math_maxu32, uint32_t)
RJD_MATH_MAX_FUNCS(RJD_MATH_DECLARE_MAX_FUNC)

#define RJD_MATH_DECLARE_CLAMP_FUNC(name, type) static inline type name(type v, type minv, type maxv);
#define RJD_MATH_DEFINE_CLAMP_FUNC(name, type) static inline type name(type v, type minv, type maxv) { return (v < minv) ? (minv) : (v > maxv ? maxv : v); }
#define RJD_MATH_CLAMP_FUNCS(xmacro)	\
	xmacro(rjd_math_clamp, double)		\
	xmacro(rjd_math_clampf, float)		\
	xmacro(rjd_math_clamp32, int32_t)	\
	xmacro(rjd_math_clamp64, int64_t)	\
	xmacro(rjd_math_clampu32, uint32_t)	\
	xmacro(rjd_math_clampu64, uint64_t)
RJD_MATH_CLAMP_FUNCS(RJD_MATH_DECLARE_CLAMP_FUNC)

#define RJD_MATH_DECLARE_TRUNCATE_FUNC(name, bigtype, smalltype) static inline smalltype name(bigtype v);
#define RJD_MATH_DEFINE_TRUNCATE_FUNC(name, bigtype, smalltype) static inline smalltype name(bigtype v) { RJD_ASSERT(v <= (smalltype)-1); return (smalltype)v; }
#define RJD_MATH_TRUNCATE_FUNCS(xmacro) 						\
	xmacro(rjd_math_truncate_u64_to_u32, uint64_t, uint32_t)	\
	xmacro(rjd_math_truncate_u64_to_u16, uint64_t, uint16_t)	\
	xmacro(rjd_math_truncate_u64_to_u8,  uint64_t, uint8_t)		\
	xmacro(rjd_math_truncate_u32_to_u16, uint32_t, uint16_t)	\
	xmacro(rjd_math_truncate_u32_to_u8,  uint32_t, uint8_t)		\
	xmacro(rjd_math_truncate_u16_to_u8,  uint16_t, uint8_t)
RJD_MATH_TRUNCATE_FUNCS(RJD_MATH_DECLARE_TRUNCATE_FUNC)

#define RJD_MATH_DECLARE_REMAP_FUNC(name, type) static inline type name(type v, type oldmin, type oldmax, type newmin, type newmax);
#define RJD_MATH_DEFINE_REMAP_FUNC(name, type) static inline type name(type v, type oldmin, type oldmax, type newmin, type newmax) { type oldrange = oldmax - oldmin; type newrange = newmax - newmin; return ((v - oldmin) * newrange) / oldrange + newmin; }
#define RJD_MATH_REMAP_FUNCS(xmacro)	\
	xmacro(rjd_math_remap, double)		\
	xmacro(rjd_math_remapf, float)
RJD_MATH_REMAP_FUNCS(RJD_MATH_DECLARE_REMAP_FUNC)

// vector structs

// NOTE: this is the one place we break the "no typedef" rule for convenience
RJD_FORCE_ALIGN(16, typedef struct rjd_math_vec3 {
	__m128 v;
} rjd_math_vec3);

RJD_FORCE_ALIGN(16, typedef struct rjd_math_vec4 {
	__m128 v;
} rjd_math_vec4);

// column-major 4x4 matrix
RJD_FORCE_ALIGN(16, typedef struct rjd_math_mat4 {
	rjd_math_vec4 m[4];
} rjd_math_mat4);

// vec4

#define rjd_math_vec4_shuffle(v4, x, y, z, w) ((rjd_math_vec4){_mm_shuffle_ps((v4).v, (v4).v, _MM_SHUFFLE(w, z, y, x))})

static inline rjd_math_vec4 rjd_math_vec4_zero(void);
static inline rjd_math_vec4 rjd_math_vec4_xyzw(float x, float y, float z, float w);
static inline rjd_math_vec4 rjd_math_vec4_splat(float v);
static inline rjd_math_vec4 rjd_math_vec4_one(void);
static inline rjd_math_vec4 rjd_math_vec4_setx(rjd_math_vec4 v, float x);
static inline rjd_math_vec4 rjd_math_vec4_sety(rjd_math_vec4 v, float y);
static inline rjd_math_vec4 rjd_math_vec4_setz(rjd_math_vec4 v, float z);
static inline rjd_math_vec4 rjd_math_vec4_setw(rjd_math_vec4 v, float w);
static inline float 		rjd_math_vec4_x(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_y(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_z(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_w(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_sum(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_dot(rjd_math_vec4 a, rjd_math_vec4 b);
static inline float 		rjd_math_vec4_lengthsq(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_length(rjd_math_vec4 v);
static inline float 		rjd_math_vec4_i(rjd_math_vec4 v, size_t index);
static inline float			rjd_math_vec4_hmin(rjd_math_vec4 v);
static inline float			rjd_math_vec4_hmax(rjd_math_vec4 v);
static inline rjd_math_vec4 rjd_math_vec4_normalize(rjd_math_vec4 v);
static inline rjd_math_vec4 rjd_math_vec4_abs(rjd_math_vec4 v);
static inline rjd_math_vec4 rjd_math_vec4_neg(rjd_math_vec4 v);
static inline rjd_math_vec4 rjd_math_vec4_floor(rjd_math_vec4 v);
static inline rjd_math_vec4 rjd_math_vec4_ceil(rjd_math_vec4 v);
static inline rjd_math_vec4 rjd_math_vec4_round(rjd_math_vec4 v);
static inline rjd_math_vec4 rjd_math_vec4_scale(rjd_math_vec4 v, float s);
static inline rjd_math_vec4 rjd_math_vec4_add(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_sub(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_mul(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_div(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_min(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_max(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_project(rjd_math_vec4 a, rjd_math_vec4 b);
static inline rjd_math_vec4 rjd_math_vec4_lerp(rjd_math_vec4 a, rjd_math_vec4 b, float t);
static inline bool			rjd_math_vec4_eq(rjd_math_vec4 a, rjd_math_vec4 b);
static inline bool			rjd_math_vec4_ge(rjd_math_vec4 a, rjd_math_vec4 b);
static inline float*		rjd_math_vec4_write(rjd_math_vec4 v, float* out);

// vec3

#define rjd_math_vec3_shuffle(v3, x, y, z) ((rjd_math_vec3){_mm_shuffle_ps((v3).v, (v3).v, _MM_SHUFFLE(3, z, y, x))})

static inline rjd_math_vec3 rjd_math_vec3_zero(void);
static inline rjd_math_vec3 rjd_math_vec3_xyz(float x, float y, float z);
static inline rjd_math_vec3 rjd_math_vec3_splat(float v);
static inline rjd_math_vec3 rjd_math_vec3_one(void);
static inline rjd_math_vec3 rjd_math_vec3_up(void);
static inline rjd_math_vec3 rjd_math_vec3_down(void);
static inline rjd_math_vec3 rjd_math_vec3_left(void);
static inline rjd_math_vec3 rjd_math_vec3_right(void);
static inline rjd_math_vec3 rjd_math_vec3_forward(void);
static inline rjd_math_vec3 rjd_math_vec3_back(void);
static inline rjd_math_vec3 rjd_math_vec3_yzx(rjd_math_vec3 v);
static inline rjd_math_vec3 rjd_math_vec3_zxy(rjd_math_vec3 v);
static inline rjd_math_vec3 rjd_math_vec3_setx(rjd_math_vec3 v, float x);
static inline rjd_math_vec3 rjd_math_vec3_sety(rjd_math_vec3 v, float y);
static inline rjd_math_vec3 rjd_math_vec3_setz(rjd_math_vec3 v, float z);
static inline float 		rjd_math_vec3_x(rjd_math_vec3 v);
static inline float 		rjd_math_vec3_y(rjd_math_vec3 v);
static inline float 		rjd_math_vec3_z(rjd_math_vec3 v);
static inline float 		rjd_math_vec3_sum(rjd_math_vec3 v);
static inline float 		rjd_math_vec3_dot(rjd_math_vec3 a, rjd_math_vec3 b);
static inline float 		rjd_math_vec3_angle(rjd_math_vec3 a, rjd_math_vec3 b);
static inline float 		rjd_math_vec3_lengthsq(rjd_math_vec3 v);
static inline float 		rjd_math_vec3_length(rjd_math_vec3 v);
static inline float			rjd_math_vec3_hmin(rjd_math_vec3 v);
static inline float			rjd_math_vec3_hmax(rjd_math_vec3 v);
static inline rjd_math_vec3 rjd_math_vec3_normalize(rjd_math_vec3 v);
static inline rjd_math_vec3 rjd_math_vec3_abs(rjd_math_vec3 v);
static inline rjd_math_vec3 rjd_math_vec3_neg(rjd_math_vec3 v);
static inline rjd_math_vec4 rjd_math_vec4_floor(rjd_math_vec4 v);
static inline rjd_math_vec4 rjd_math_vec4_ceil(rjd_math_vec4 v);
static inline rjd_math_vec4 rjd_math_vec4_round(rjd_math_vec4 v);
static inline rjd_math_vec3 rjd_math_vec3_scale(rjd_math_vec3 v, float s);
static inline rjd_math_vec3 rjd_math_vec3_add(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_sub(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_mul(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_div(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_cross(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_min(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_max(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_project(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_reflect(rjd_math_vec3 a, rjd_math_vec3 b);
static inline rjd_math_vec3 rjd_math_vec3_lerp(rjd_math_vec3 a, rjd_math_vec3 b, float t);
static inline bool			rjd_math_vec3_eq(rjd_math_vec3 a, rjd_math_vec3 b);
static inline bool			rjd_math_vec3_ge(rjd_math_vec3 a, rjd_math_vec3 b);
static inline float*		rjd_math_vec3_write(rjd_math_vec3 v, float* out);
static inline float*		rjd_math_vec3_writefast(rjd_math_vec3 v, float* out); // writes 4 floats to out

// mat4

static inline rjd_math_mat4 rjd_math_mat4_identity(void);
static inline rjd_math_mat4 rjd_math_mat4_translation(rjd_math_vec3 trans);
//static inline rjd_math_mat4 rjd_math_mat4_rotation(rjd_math_quat rot); // TODO quaternions
static inline rjd_math_mat4 rjd_math_mat4_angleaxis(float angle, rjd_math_vec3 axis);
static inline rjd_math_mat4 rjd_math_mat4_rotationx(float angle);
static inline rjd_math_mat4 rjd_math_mat4_rotationy(float angle);
static inline rjd_math_mat4 rjd_math_mat4_rotationz(float angle);
static inline rjd_math_mat4 rjd_math_mat4_rotationbasis(rjd_math_vec3 x, rjd_math_vec3 y, rjd_math_vec3 z);
static inline rjd_math_mat4 rjd_math_mat4_scaling(float scale);
static inline rjd_math_mat4 rjd_math_mat4_scaling_nonuniform(rjd_math_vec3 scale);
static inline rjd_math_mat4 rjd_math_mat4_add(rjd_math_mat4 a, rjd_math_mat4 b);
static inline rjd_math_mat4 rjd_math_mat4_mul(rjd_math_mat4 a, rjd_math_mat4 b);
static inline rjd_math_vec3 rjd_math_mat4_mulv3(rjd_math_mat4 m, rjd_math_vec3 v);
static inline rjd_math_vec4 rjd_math_mat4_mulv4(rjd_math_mat4 m, rjd_math_vec4 v);
static inline rjd_math_mat4 rjd_math_mat4_inv(rjd_math_mat4 m);
static inline rjd_math_mat4 rjd_math_mat4_transpose(rjd_math_mat4 m);
static inline rjd_math_mat4 rjd_math_mat4_frustum_righthanded(float left, float right, float top, float bot, float near_plane, float far_plane);
static inline rjd_math_mat4 rjd_math_mat4_ortho_righthanded(float left, float right, float top, float bot, float near_plane, float far_plane);
static inline rjd_math_mat4 rjd_math_mat4_ortho_lefthanded(float left, float right, float top, float bot, float near_plane, float far_plane);
static inline rjd_math_mat4 rjd_math_mat4_perspective_righthanded(float y_fov, float aspect, float near_plane, float far_plane);
static inline rjd_math_mat4 rjd_math_mat4_perspective_lefthanded(float y_fov, float aspect, float near_plane, float far_plane);
static inline rjd_math_mat4 rjd_math_mat4_lookat_righthanded(rjd_math_vec3 eye, rjd_math_vec3 target, rjd_math_vec3 up);
static inline rjd_math_mat4 rjd_math_mat4_lookat_lefthanded(rjd_math_vec3 eye, rjd_math_vec3 target, rjd_math_vec3 up);
static inline float*		rjd_math_mat4_write_colmajor(rjd_math_mat4 m, float* out);
static inline float*		rjd_math_mat4_write_rowmajor(rjd_math_mat4 m, float* out);

// implementation

RJD_MATH_SIGN_FUNCS(RJD_MATH_DEFINE_SIGN_FUNC)
RJD_MATH_ISEQUAL_FUNCS(RJD_MATH_DEFINE_ISEQUAL_FUNC)
RJD_MATH_MIN_FUNCS(RJD_MATH_DEFINE_MIN_FUNC)
RJD_MATH_MAX_FUNCS(RJD_MATH_DEFINE_MAX_FUNC)
RJD_MATH_CLAMP_FUNCS(RJD_MATH_DEFINE_CLAMP_FUNC)
RJD_MATH_TRUNCATE_FUNCS(RJD_MATH_DEFINE_TRUNCATE_FUNC)
RJD_MATH_REMAP_FUNCS(RJD_MATH_DEFINE_REMAP_FUNC)

static inline uint32_t rjd_math_next_pow2(uint32_t v) 
{
	--v;
	v |= v >> 1;
	v |= v >> 2;
	v |= v >> 4;
	v |= v >> 8;
	v |= v >> 16;
	v++;

	return v;
}

static inline int32_t rjd_math_pow32(int32_t v, uint32_t power)
{
	int32_t r = 1;
	while (power) {
		r *= v;
		--power;
	}
	return r;
}

// vec3 <-> vec4 conversion helpers

static inline rjd_math_vec4 rjd_math_vec3to4(rjd_math_vec3 v3) {
	rjd_math_vec4 v4 = { v3.v };
	return v4;
}

static inline rjd_math_vec3 rjd_math_vec4to3(rjd_math_vec4 v4) {
	rjd_math_vec3 v3 = { v4.v };
	return v3;
}

static inline rjd_math_vec4 rjd_math_vec3to4w(rjd_math_vec3 v3, float w) {
	rjd_math_vec4 v4 = rjd_math_vec3to4(v3);
	return rjd_math_vec4_setw(v4, w);
}

static inline rjd_math_vec3 rjd_math_vec4to3w(rjd_math_vec4 v4) {
	v4 = rjd_math_vec4_setw(v4, 0);
	return rjd_math_vec4to3(v4);
}

// vec4

static inline rjd_math_vec4 rjd_math_vec4_zero(void) {
	rjd_math_vec4 v = { _mm_setzero_ps() };
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_xyzw(float x, float y, float z, float w) {
	rjd_math_vec4 v = { _mm_set_ps(w, z, y, x) }; 
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_splat(float f) {
	rjd_math_vec4 v = { _mm_set1_ps(f) };
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_one(void) {
	return rjd_math_vec4_splat(1);
}
static inline rjd_math_vec4 rjd_math_vec4_setx(rjd_math_vec4 v, float x) {
	v.v = _mm_move_ss(v.v, rjd_math_vec4_splat(x).v);
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_sety(rjd_math_vec4 v, float y) {
	v = rjd_math_vec4_shuffle(v, 1, 0, 2, 3);
	v = rjd_math_vec4_setx(v, y);
	v = rjd_math_vec4_shuffle(v, 1, 0, 2, 3);
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_setz(rjd_math_vec4 v, float z) {
	v = rjd_math_vec4_shuffle(v, 2, 1, 0, 3);
	v = rjd_math_vec4_setx(v, z);
	v = rjd_math_vec4_shuffle(v, 2, 1, 0, 3);
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_setw(rjd_math_vec4 v, float w) {
	v = rjd_math_vec4_shuffle(v, 3, 1, 2, 0);
	v = rjd_math_vec4_setx(v, w);
	v = rjd_math_vec4_shuffle(v, 3, 1, 2, 0);
	return v;
}
static inline float rjd_math_vec4_x(rjd_math_vec4 v) {
	return _mm_cvtss_f32(v.v);
}
static inline float rjd_math_vec4_y(rjd_math_vec4 v) {
	return rjd_math_vec4_x(rjd_math_vec4_shuffle(v, 1, 0, 2, 3));
}
static inline float rjd_math_vec4_z(rjd_math_vec4 v) {
	return rjd_math_vec4_x(rjd_math_vec4_shuffle(v, 2, 1, 0, 3));
}
static inline float rjd_math_vec4_w(rjd_math_vec4 v) {
	return rjd_math_vec4_x(rjd_math_vec4_shuffle(v, 3, 1, 2, 0));
}
static inline float rjd_math_vec4_sum(rjd_math_vec4 v) {
	v.v = _mm_hadd_ps(v.v, v.v);
	v.v = _mm_hadd_ps(v.v, v.v);
	return rjd_math_vec4_x(v);
}
static inline float rjd_math_vec4_dot(rjd_math_vec4 a, rjd_math_vec4 b) {
	rjd_math_vec4 product = rjd_math_vec4_mul(a,b);
	return rjd_math_vec4_sum(product);
}
static inline float rjd_math_vec4_lengthsq(rjd_math_vec4 v) {
	return rjd_math_vec4_dot(v, v);
}
static inline float rjd_math_vec4_length(rjd_math_vec4 v) {
	return sqrtf(rjd_math_vec4_lengthsq(v));
}
static inline float rjd_math_vec4_hmin(rjd_math_vec4 v) {
	v = rjd_math_vec4_min(v, rjd_math_vec4_shuffle(v,1,1,2,3));
	v = rjd_math_vec4_min(v, rjd_math_vec4_shuffle(v,2,1,2,3));
	v = rjd_math_vec4_min(v, rjd_math_vec4_shuffle(v,3,1,2,3));
	return rjd_math_vec4_x(v);
}
static inline float rjd_math_vec4_hmax(rjd_math_vec4 v) {
	v = rjd_math_vec4_max(v, rjd_math_vec4_shuffle(v,1,1,2,3));
	v = rjd_math_vec4_max(v, rjd_math_vec4_shuffle(v,2,1,2,3));
	v = rjd_math_vec4_max(v, rjd_math_vec4_shuffle(v,3,1,2,3));
	return rjd_math_vec4_x(v);
}
static inline float rjd_math_vec4_i(rjd_math_vec4 v, size_t index) {
	switch(index) {
		case 0:	v = rjd_math_vec4_shuffle(v,0,0,0,0); break;
		case 1:	v = rjd_math_vec4_shuffle(v,1,1,1,1); break;
		case 2:	v = rjd_math_vec4_shuffle(v,2,2,2,2); break;
		case 3:	v = rjd_math_vec4_shuffle(v,3,3,3,3); break;
		default:
			RJD_ASSERTFAIL("index must be between 0 and 3");
			break;
	}
	return rjd_math_vec4_x(v);
}
static inline rjd_math_vec4 rjd_math_vec4_normalize(rjd_math_vec4 v) {
	float length = rjd_math_vec4_length(v);
	RJD_ASSERT(length != 0);
	rjd_math_vec4 l = rjd_math_vec4_splat(length);
	return rjd_math_vec4_div(v, l);
}
static inline rjd_math_vec4 rjd_math_vec4_abs(rjd_math_vec4 v) {
	__m128 signbits = _mm_set1_ps(-0.0f);
	v.v = _mm_andnot_ps(signbits, v.v); // Remove the sign bit
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_neg(rjd_math_vec4 v) {
	return rjd_math_vec4_scale(v, -1);
}
static inline rjd_math_vec4 rjd_math_vec4_floor(rjd_math_vec4 v) {
	v.v = _mm_floor_ps(v.v);
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_ceil(rjd_math_vec4 v) {
	v.v = _mm_ceil_ps(v.v);
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_round(rjd_math_vec4 v) {
	v.v = _mm_round_ps(v.v, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);
	return v;
}
static inline rjd_math_vec4 rjd_math_vec4_scale(rjd_math_vec4 v, float s) {
	rjd_math_vec4 scales = rjd_math_vec4_splat(s);
	return rjd_math_vec4_mul(v, scales);
}
static inline rjd_math_vec4 rjd_math_vec4_add(rjd_math_vec4 a, rjd_math_vec4 b) {
	a.v = _mm_add_ps(a.v, b.v);
	return a;
}
static inline rjd_math_vec4 rjd_math_vec4_sub(rjd_math_vec4 a, rjd_math_vec4 b) {
	a.v = _mm_sub_ps(a.v, b.v);
	return a;
}
static inline rjd_math_vec4 rjd_math_vec4_mul(rjd_math_vec4 a, rjd_math_vec4 b) {
	a.v = _mm_mul_ps(a.v, b.v);
	return a;
}
static inline rjd_math_vec4 rjd_math_vec4_div(rjd_math_vec4 a, rjd_math_vec4 b) {
	a.v = _mm_div_ps(a.v, b.v);
	return a;
}
static inline rjd_math_vec4 rjd_math_vec4_min(rjd_math_vec4 a, rjd_math_vec4 b) {
	a.v = _mm_min_ps(a.v, b.v);
	return a;
}
static inline rjd_math_vec4 rjd_math_vec4_max(rjd_math_vec4 a, rjd_math_vec4 b) {
	a.v = _mm_max_ps(a.v, b.v);
	return a;
}
static inline rjd_math_vec4 rjd_math_vec4_project(rjd_math_vec4 a, rjd_math_vec4 b) {
	float dot = rjd_math_vec4_dot(a, b);
	float lb = rjd_math_vec4_length(b);
	return rjd_math_vec4_scale(b, dot / lb);
}
static inline rjd_math_vec4 rjd_math_vec4_lerp(rjd_math_vec4 a, rjd_math_vec4 b, float t) {
	rjd_math_vec4 v = rjd_math_vec4_sub(b, a);
	v = rjd_math_vec4_scale(v, t);
	v = rjd_math_vec4_add(v, a);
	return v;
}
static inline bool rjd_math_vec4_eq(rjd_math_vec4 a, rjd_math_vec4 b) {
	return (_mm_movemask_ps(_mm_cmpeq_ps(a.v, b.v)) & 0xF) == 0xF;
}
static inline bool rjd_math_vec4_ge(rjd_math_vec4 a, rjd_math_vec4 b) {
	return (_mm_movemask_ps(_mm_cmpge_ps(a.v, b.v)) & 0xF) == 0xF;
}
static inline float* rjd_math_vec4_write(rjd_math_vec4 v, float* out) {
	RJD_ASSERT(RJD_MEM_ISALIGNED(out, 16));
	_mm_stream_ps(out,  v.v);
	return out + 4;
}

// vec3

static inline rjd_math_vec3 rjd_math_vec3_zero(void) { 
	return rjd_math_vec4to3(rjd_math_vec4_zero());
}
static inline rjd_math_vec3 rjd_math_vec3_xyz(float x, float y, float z) {
	return rjd_math_vec4to3(rjd_math_vec4_xyzw(x,y,z,0));
}
static inline rjd_math_vec3 rjd_math_vec3_splat(float v) { return rjd_math_vec3_xyz(v,v,v); }
static inline rjd_math_vec3 rjd_math_vec3_one(void) { return rjd_math_vec3_xyz(1,1,1); }
static inline rjd_math_vec3 rjd_math_vec3_up(void) { return rjd_math_vec3_xyz(0,1,0); }
static inline rjd_math_vec3 rjd_math_vec3_down(void) { return rjd_math_vec3_xyz(0,-1,0); }
static inline rjd_math_vec3 rjd_math_vec3_left(void) { return rjd_math_vec3_xyz(-1,0,0); }
static inline rjd_math_vec3 rjd_math_vec3_right(void) { return rjd_math_vec3_xyz(1,0,0); }
static inline rjd_math_vec3 rjd_math_vec3_forward(void) { return rjd_math_vec3_xyz(0,0,1); }
static inline rjd_math_vec3 rjd_math_vec3_back(void) { return rjd_math_vec3_xyz(0,0,-1); }
static inline rjd_math_vec3 rjd_math_vec3_yzx(rjd_math_vec3 v) {
	return rjd_math_vec3_shuffle(v, 1, 2, 0);
}
static inline rjd_math_vec3 rjd_math_vec3_zxy(rjd_math_vec3 v) {
	return rjd_math_vec3_shuffle(v, 2, 0, 1);
}
static inline rjd_math_vec3 rjd_math_vec3_setx(rjd_math_vec3 v, float x) {
	v.v = _mm_move_ss(v.v, rjd_math_vec3_splat(x).v);
	return v;
}
static inline rjd_math_vec3 rjd_math_vec3_sety(rjd_math_vec3 v, float y) {
	return rjd_math_vec4to3(rjd_math_vec4_sety(rjd_math_vec3to4(v), y));
}
static inline rjd_math_vec3 rjd_math_vec3_setz(rjd_math_vec3 v, float z) {
	return rjd_math_vec4to3(rjd_math_vec4_setz(rjd_math_vec3to4(v), z));
}
static inline float rjd_math_vec3_x(rjd_math_vec3 v) {
	return rjd_math_vec4_x(rjd_math_vec3to4(v));
}
static inline float rjd_math_vec3_y(rjd_math_vec3 v) {
	return rjd_math_vec4_y(rjd_math_vec3to4(v));
}
static inline float rjd_math_vec3_z(rjd_math_vec3 v) {
	return rjd_math_vec4_z(rjd_math_vec3to4(v));
}
static inline float rjd_math_vec3_sum(rjd_math_vec3 v) {
	return rjd_math_vec4_sum(rjd_math_vec3to4(v));
}
static inline float rjd_math_vec3_dot(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4_dot(rjd_math_vec3to4(a), rjd_math_vec3to4(b));
}
static inline float rjd_math_vec3_angle(rjd_math_vec3 a, rjd_math_vec3 b) {
	float dot = rjd_math_vec3_dot(a, b);
	float la = rjd_math_vec3_length(a);
	float lb = rjd_math_vec3_length(b);
	return acosf(dot / (la * lb));
}
static inline float rjd_math_vec3_lengthsq(rjd_math_vec3 v) {
	return rjd_math_vec4_lengthsq(rjd_math_vec3to4(v));
}
static inline float rjd_math_vec3_length(rjd_math_vec3 v) {
	return rjd_math_vec4_length(rjd_math_vec3to4(v));
}
static inline float rjd_math_vec3_hmin(rjd_math_vec3 v) {
	v = rjd_math_vec3_min(v, rjd_math_vec3_shuffle(v,1,1,2));
	v = rjd_math_vec3_min(v, rjd_math_vec3_shuffle(v,2,1,2));
	return rjd_math_vec3_x(v);
}
static inline float rjd_math_vec3_hmax(rjd_math_vec3 v) {
	v = rjd_math_vec3_max(v, rjd_math_vec3_shuffle(v,1,1,2));
	v = rjd_math_vec3_max(v, rjd_math_vec3_shuffle(v,2,1,2));
	return rjd_math_vec3_x(v);
}
static inline rjd_math_vec3 rjd_math_vec3_normalize(rjd_math_vec3 v) {
	return rjd_math_vec4to3(rjd_math_vec4_normalize(rjd_math_vec3to4(v)));
}
static inline rjd_math_vec3 rjd_math_vec3_abs(rjd_math_vec3 v) {
	return rjd_math_vec4to3(rjd_math_vec4_abs(rjd_math_vec3to4(v)));
}
static inline rjd_math_vec3 rjd_math_vec3_neg(rjd_math_vec3 v) {
	return rjd_math_vec4to3(rjd_math_vec4_neg(rjd_math_vec3to4(v)));
}
static inline rjd_math_vec3 rjd_math_vec3_floor(rjd_math_vec3 v) {
	return rjd_math_vec4to3(rjd_math_vec4_floor(rjd_math_vec3to4(v)));
}
static inline rjd_math_vec3 rjd_math_vec3_ceil(rjd_math_vec3 v) {
	return rjd_math_vec4to3(rjd_math_vec4_ceil(rjd_math_vec3to4(v)));
}
static inline rjd_math_vec3 rjd_math_vec3_round(rjd_math_vec3 v) {
	return rjd_math_vec4to3(rjd_math_vec4_abs(rjd_math_vec3to4(v)));
}
static inline rjd_math_vec3 rjd_math_vec3_scale(rjd_math_vec3 v, float s) {
	return rjd_math_vec4to3(rjd_math_vec4_scale(rjd_math_vec3to4(v), s));
}
static inline rjd_math_vec3 rjd_math_vec3_add(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_add(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_sub(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_sub(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_mul(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_mul(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_div(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_div(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_cross(rjd_math_vec3 a, rjd_math_vec3 b) {
	rjd_math_vec3 ap = rjd_math_vec3_mul(rjd_math_vec3_yzx(a), rjd_math_vec3_zxy(b));
	rjd_math_vec3 bp = rjd_math_vec3_mul(rjd_math_vec3_zxy(a), rjd_math_vec3_yzx(b));
	return rjd_math_vec3_sub(ap, bp);
}
static inline rjd_math_vec3 rjd_math_vec3_min(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_min(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_max(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_max(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_project(rjd_math_vec3 a, rjd_math_vec3 b) {
	return rjd_math_vec4to3(rjd_math_vec4_project(rjd_math_vec3to4(a), rjd_math_vec3to4(b)));
}
static inline rjd_math_vec3 rjd_math_vec3_reflect(rjd_math_vec3 v, rjd_math_vec3 n) {
	RJD_ASSERT(rjd_math_vec3_eq(n, rjd_math_vec3_normalize(n)));
	rjd_math_vec3 projected = rjd_math_vec3_scale(n, 2 * rjd_math_vec3_dot(v, n));
	return rjd_math_vec3_sub(v, projected);
}
static inline rjd_math_vec3 rjd_math_vec3_lerp(rjd_math_vec3 a, rjd_math_vec3 b, float t) {
	return rjd_math_vec4to3(rjd_math_vec4_lerp(rjd_math_vec3to4(a), rjd_math_vec3to4(b), t));
}
static inline bool rjd_math_vec3_eq(rjd_math_vec3 a, rjd_math_vec3 b) {
	return (_mm_movemask_ps(_mm_cmpeq_ps(a.v, b.v)) & 7) == 7; // 7 is the platform-independent version of 0b111
}
static inline bool rjd_math_vec3_ge(rjd_math_vec3 a, rjd_math_vec3 b) {
	return (_mm_movemask_ps(_mm_cmpge_ps(a.v, b.v)) & 7) == 7;
}
static inline float* rjd_math_vec3_write(rjd_math_vec3 v, float* out) {
	RJD_FORCE_ALIGN(16, float) tmp[4];
	_mm_stream_ps(tmp, v.v);
	memcpy(out, tmp, sizeof(float) * 3);
	return out + 3;
}
static inline float* rjd_math_vec3_writefast(rjd_math_vec3 v, float* out) {
	RJD_ASSERT(RJD_MEM_ISALIGNED(out, 16));
	_mm_stream_ps(out, v.v);
	return out + 3;
}

// mat4

static inline rjd_math_mat4 rjd_math_mat4_identity(void) {
	rjd_math_mat4 m;
	m.m[0] = rjd_math_vec4_xyzw(1,0,0,0);
	m.m[1] = rjd_math_vec4_xyzw(0,1,0,0);
	m.m[2] = rjd_math_vec4_xyzw(0,0,1,0);
	m.m[3] = rjd_math_vec4_xyzw(0,0,0,1);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_translation(rjd_math_vec3 trans) {
	rjd_math_mat4 m;
	m.m[0] = rjd_math_vec4_xyzw(1,0,0,0);
	m.m[1] = rjd_math_vec4_xyzw(0,1,0,0);
	m.m[2] = rjd_math_vec4_xyzw(0,0,1,0);
	m.m[3] = rjd_math_vec3to4w(trans, 1);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_angleaxis(float angle, rjd_math_vec3 axis) {
	rjd_math_mat4 m;

	// TODO optimize
	float c = cosf(angle);
	float k = 1 - c;
	float s = sinf(angle);

	float x = rjd_math_vec3_x(axis);
	float y = rjd_math_vec3_y(axis);
	float z = rjd_math_vec3_z(axis);

	//rjd_math_vec4 axis4 = rjd_math_vec3to4w(axis,1); // x,y,z,1
	//rjd_math_vec4 tmp1 = rjd_math_vec4_mul(axis4, rjd_math_vec4_xyzw(s,s,s,c)); // x*s, y*s, z*s, c
	//rjd_math_vec4 vk = rjd_math_vec4_splat(k);

	//rjd_math_vec4 v0 = rjd_math_vec4_mul(axis4, rjd_math_vec4_shuffle(axis4,0,0,0,3));
	//v0 = rjd_math_vec4_mul(v0, vk);

	//v0 = rjd_math_vec4_add(v0, rjd_math_vec4_shuffle(tmp1,3,2,1));

	//m.m[0] = 


	//vec3 diagonal = rjd_math_vec3_mul(axis, axis);
	//diagonal = rjd_math_vec3_mul(diagonal, veck);
	//diagonal = rjd_math_vec3_add(diagonal, rjd_math_vec3_splat(c));
	
	float m00 = k*x*x + c;
	float m10 = k*x*y + z*s;
	float m20 = k*x*z - y*s;

	float m01 = k*x*y - z*s;
	float m11 = k*y*y + c;
	float m21 = k*y*z + x*s;

	float m02 = k*x*z + y*s;
	float m12 = k*y*z - x*s;
	float m22 = k*z*z + c;

	m.m[0] = rjd_math_vec4_xyzw(m00, m10, m20, 0);
	m.m[1] = rjd_math_vec4_xyzw(m01, m11, m21, 0);
	m.m[2] = rjd_math_vec4_xyzw(m02, m12, m22, 0);
	m.m[3] = rjd_math_vec4_xyzw(  0,   0,   0, 1);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_rotationx(float angle) {
	return rjd_math_mat4_angleaxis(angle, rjd_math_vec3_right());
}
static inline rjd_math_mat4 rjd_math_mat4_rotationy(float angle) {
	return rjd_math_mat4_angleaxis(angle, rjd_math_vec3_up());
}
static inline rjd_math_mat4 rjd_math_mat4_rotationz(float angle) {
	return rjd_math_mat4_angleaxis(angle, rjd_math_vec3_forward());
}
static inline rjd_math_mat4 rjd_math_mat4_rotationbasis(rjd_math_vec3 x, rjd_math_vec3 y, rjd_math_vec3 z) {
	rjd_math_vec4 xx = rjd_math_vec3to4(x);
	rjd_math_vec4 yy = rjd_math_vec3to4(y);
	rjd_math_vec4 zz = rjd_math_vec3to4(z);
	rjd_math_mat4 m = { { xx, yy, zz, rjd_math_vec4_xyzw(0,0,0,1) } };
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_scaling(float s) {
	rjd_math_mat4 m;
	m.m[0] = rjd_math_vec4_xyzw(s,0,0,0);
	m.m[1] = rjd_math_vec4_xyzw(0,s,0,0);
	m.m[2] = rjd_math_vec4_xyzw(0,0,s,0);
	m.m[3] = rjd_math_vec4_xyzw(0,0,0,1);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_scaling_nonuniform(rjd_math_vec3 scale) {
	float x = rjd_math_vec3_x(scale);
	float y = rjd_math_vec3_y(scale);
	float z = rjd_math_vec3_z(scale);

	rjd_math_mat4 m;
	m.m[0] = rjd_math_vec4_xyzw(x,0,0,0);
	m.m[1] = rjd_math_vec4_xyzw(0,y,0,0);
	m.m[2] = rjd_math_vec4_xyzw(0,0,z,0);
	m.m[3] = rjd_math_vec4_xyzw(0,0,0,1);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_add(rjd_math_mat4 a, rjd_math_mat4 b) {
    rjd_math_mat4 m = {0};
	for (size_t i = 0; i < rjd_countof(m.m); ++i) {
		m.m[i] = rjd_math_vec4_add(a.m[i], b.m[i]);
	}
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_mul(rjd_math_mat4 a, rjd_math_mat4 b) {
    rjd_math_mat4 m = {0};
	for (size_t i = 0; i < rjd_countof(m.m); ++i) {
		m.m[i] = rjd_math_mat4_mulv4(a, b.m[i]);
	}
	return m;
}
static inline rjd_math_vec3 rjd_math_mat4_mulv3(rjd_math_mat4 m, rjd_math_vec3 v) {
	return rjd_math_vec4to3(rjd_math_mat4_mulv4(m, rjd_math_vec3to4w(v, 1)));
}
static inline rjd_math_vec4 rjd_math_mat4_mulv4(rjd_math_mat4 m, rjd_math_vec4 v) {
	// TODO optimize
	rjd_math_mat4 trans = rjd_math_mat4_transpose(m);
	float x = rjd_math_vec4_dot(trans.m[0], v);
	float y = rjd_math_vec4_dot(trans.m[1], v);
	float z = rjd_math_vec4_dot(trans.m[2], v);
	float w = rjd_math_vec4_dot(trans.m[3], v);
	return rjd_math_vec4_xyzw(x, y, z, w);
}
static inline rjd_math_mat4 rjd_math_mat4_inv(rjd_math_mat4 m) {
	rjd_math_mat4 t = rjd_math_mat4_transpose(m);
	rjd_math_vec4 t0 = t.m[0];
	rjd_math_vec4 t1 = t.m[1];
	rjd_math_vec4 t2 = t.m[2];
	rjd_math_vec4 t3 = t.m[3];
	
	rjd_math_mat4 inv;
	rjd_math_vec4 term;

	// first column
	//inv0.x = m11m22m33 + m12m23m31 + m13m21m32 - m11m23m32 - m12m21m33 - m13m22m31;
	//inv0.y = m10m23m32 + m12m20m33 + m13m22m30 - m10m22m33 - m12m23m30 - m13m20m32;
	//inv0.z = m10m21m31 + m11m23m30 + m13m20m31 - m10m23m30 - m11m20m33 - m13m21m30;
	//inv0.w = m10m22m31 + m11m20m32 + m12m21m30 - m10m21m32 - m11m22m30 - m12m20m31;
	//																		x		  y			z		  w
	term = rjd_math_vec4_shuffle(t1,1,0,0,0);							// m11,		 m10,      m10,      m10
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,3,1,2)); 	// m11m22,   m10m23,   m10m21,   m10m22
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,2,1,1)); 	// m11m22m33,m10m23m32,m10m21m31,m10m22m31
	inv.m[0] = term;

	term = rjd_math_vec4_shuffle(t1,2,2,1,1);							// m12,      m12,      m11,      m11
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,3,0,3,0)); 	// m12m23,   m12m20,   m11m23,   m11m20
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,1,3,0,2)); 	// m12m23m31,m12m20m33,m11m23m30,m11m20m32
	inv.m[0] = rjd_math_vec4_add(inv.m[0], term);

	term = rjd_math_vec4_shuffle(t1,3,3,3,2);							// m13,      m13,      m13,      m12
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,3,1,2)); 	// m13m21,   m13m22,   m13m20,   m12m21
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,2,1,1)); 	// m13m21m32,m13m22m30,m13m20m31,m12m21m30
	inv.m[0] = rjd_math_vec4_add(inv.m[0], term);

	term = rjd_math_vec4_shuffle(t1,1,0,0,0);							// m11,      m10,      m10,      m10
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,3,2,3,1)); 	// m11m23,   m10m22,   m10m23,   m10m21
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,2,3,0,2)); 	// m11m23m32,m10m22m33,m10m23m30,m10m21m32
	inv.m[0] = rjd_math_vec4_sub(inv.m[0], term);

	term = rjd_math_vec4_shuffle(t1,2,2,1,1);							// m12,      m12,      m11,      m11
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,1,3,0,2)); 	// m12m21,   m12m23,   m11m20,   m11m22
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,0,3,0)); 	// m12m21m33,m12m23m30,m11m20m33,m11m22m30
	inv.m[0] = rjd_math_vec4_sub(inv.m[0], term);

	term = rjd_math_vec4_shuffle(t1,3,3,3,2);							// m13,      m13,      m13,      m12
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,0,1,0)); 	// m13m22,   m13m20,   m13m21,   m12m20
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,1,2,0,1)); 	// m13m22m31,m13m20m32,m13m21m30,m12m20m31
	inv.m[0] = rjd_math_vec4_sub(inv.m[0], term);

	// second column
	// inv.m[1].x = m01m23m32 + m02m21m33 + m03m22m31 - m01m22m33 - m02m23m31 - m03m21m32
	// inv.m[1].y = m00m22m33 + m02m23m30 + m03m20m30 - m00m23m32 - m02m20m33 - m03m22m30
	// inv.m[1].z = m00m23m31 + m01m20m33 + m03m21m30 - m00m21m33 - m01m23m30 - m03m20m31
	// inv.m[1].w = m00m21m32 + m01m22m30 + m02m20m31 - m00m22m31 - m01m20m32 - m02m21m30
	term = rjd_math_vec4_shuffle(t0,1,0,0,0);                         // m01,      m00,      m00,      m00
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,3,2,3,1)); // m01m23,   m00m22,   m00m23,   m00m21
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,2,3,1,2)); // m01m23m32,m00m22m33,m00m23m31,m00m21m32
	inv.m[1] = term;

	term = rjd_math_vec4_shuffle(t0,2,2,1,1);                         // m02,      m02,      m01,      m01
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,1,3,0,2)); // m02m21,   m02m23,   m01m20,   m01m22
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,0,3,0)); // m02m21m33,m02m23m30,m01m20m33,m01m22m30
	inv.m[1] = rjd_math_vec4_add(inv.m[1], term);

	term = rjd_math_vec4_shuffle(t0,3,3,3,2);                         // m03,      m03,      m03,      m02
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,0,1,0)); // m03m22,   m03m20,   m03m21,   m02m20
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,1,0,0,1)); // m03m22m31,m03m20m30,m03m21m30,m02m20m31
	inv.m[1] = rjd_math_vec4_add(inv.m[1], term);

	term = rjd_math_vec4_shuffle(t0,1,0,0,0);                         // m01,      m00,      m00,      m00
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,3,1,2)); // m01m22,   m00m23,   m00m21,   m00m22
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,2,3,1)); // m01m22m33,m00m23m32,m00m21m33,m00m22m31
	inv.m[1] = rjd_math_vec4_sub(inv.m[1], term);

	term = rjd_math_vec4_shuffle(t0,2,2,1,1);                         // m02,      m02,      m01,      m01
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,3,0,3,0)); // m02m23,   m02m20,   m01m23,   m01m20
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,1,3,0,2)); // m02m23m31,m02m20m33,m01m23m30,m01m20m32
	inv.m[1] = rjd_math_vec4_sub(inv.m[1], term);

	term = rjd_math_vec4_shuffle(t0,3,3,3,2);                         // m03,      m03,      m03,      m02
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,1,2,0,1)); // m03m21,   m03m22,   m03m20,   m02m21
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,2,0,1,0)); // m03m21m32,m03m22m30,m03m20m31,m02m21m30
	inv.m[1] = rjd_math_vec4_sub(inv.m[1], term);

	// third column
	// inv.m[2].x = m01m12m33 + m02m13m31 + m03m11m32 - m01m13m32 - m02m11m33 - m03m12m31
	// inv.m[2].y = m00m13m32 + m02m10m33 + m03m12m30 - m00m12m33 - m02m13m30 - m03m10m32
	// inv.m[2].z = m00m11m33 + m01m13m30 + m03m10m31 - m00m13m31 - m01m10m33 - m01m11m30
	// inv.m[2].w = m00m12m31 + m01m10m32 + m02m11m30 - m00m11m32 - m01m12m30 - m02m10m31
	term = rjd_math_vec4_shuffle(t0,1,0,0,0);                          // m01       m00       m00       m00
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,2,3,1,2)); // m01m12    m00m13    m00m11    m00m12
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,2,3,1)); // m01m12m33 m00m13m32 m00m11m33 m00m12m31
	inv.m[2] = term;

	term = rjd_math_vec4_shuffle(t0,2,2,1,1);                          // m02       m02       m01       m01
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,3,0,3,0)); // m02m13    m02m10    m01m13    m01m10
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,1,3,0,2)); // m02m13m31 m02m10m33 m01m13m30 m01m10m32
	inv.m[2] = rjd_math_vec4_add(inv.m[2], term);

	term = rjd_math_vec4_shuffle(t0,3,3,3,2);                          // m03       m03       m03       m02
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,1,2,0,1)); // m03m11    m03m12    m03m10    m02m11
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,2,0,1,0)); // m03m11m32 m03m12m30 m03m10m31 m02m11m30
	inv.m[2] = rjd_math_vec4_add(inv.m[2], term);

	term = rjd_math_vec4_shuffle(t0,1,0,0,0);                          // m01       m00       m00       m00
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,3,2,3,1)); // m01m13    m00m12    m00m13    m00m11
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,2,3,1,2)); // m01m13m32 m00m12m33 m00m13m31 m00m11m32
	inv.m[2] = rjd_math_vec4_sub(inv.m[2], term);

	term = rjd_math_vec4_shuffle(t0,2,2,1,1);                          // m02       m02       m01       m01
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,1,3,0,2)); // m02m11    m02m13    m01m10    m01m12
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,3,0,3,0)); // m02m11m33 m02m13m30 m01m10m33 m01m12m30
	inv.m[2] = rjd_math_vec4_sub(inv.m[2], term);

	term = rjd_math_vec4_shuffle(t0,3,3,1,2);                          // m03       m03       m01       m02
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,2,0,1,0)); // m03m12    m03m10    m01m11    m02m10
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t3,1,2,0,1)); // m03m12m31 m03m10m32 m01m11m30 m02m10m31
	inv.m[2] = rjd_math_vec4_sub(inv.m[2], term);	

	// fourth column
	// inv.m[3].x = m01m13m22 + m02m11m23 + m03m12m21 - m01m12m23 - m02m13m21 - m03m11m22
	// inv.m[3].y = m00m12m23 + m02m13m20 + m03m10m22 - m00m13m22 - m02m10m23 - m03m12m20
	// inv.m[3].z = m00m13m21 + m01m13m23 + m03m11m20 - m00m11m23 - m01m13m20 - m03m10m21
	// inv.m[3].w = m00m11m22 + m01m12m20 + m02m10m21 - m00m12m21 - m01m10m22 - m02m11m20
	term = rjd_math_vec4_shuffle(t0,1,0,0,0);                          // m01 m00 m00 m00
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,3,2,3,1)); // m01m13 m00m12 m00m13 m00m11
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,3,1,2)); // m01m13m22 m00m12m23 m00m13m21 m00m11m22
	inv.m[3] = term;

	term = rjd_math_vec4_shuffle(t0,2,2,1,1);                          // m02 m02 m01 m01
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,1,3,3,2)); // m02m11 m02m13 m01m13 m01m12
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,3,0,3,0)); // m02m11m23 m02m13m20 m01m13m23 m01m12m20
	inv.m[3] = rjd_math_vec4_add(inv.m[3], term);

	term = rjd_math_vec4_shuffle(t0,3,3,3,2);                          // m03 m03 m03 m02
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,2,0,1,0)); // m03m12 m03m10 m03m11 m02m10
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,1,2,0,1)); // m03m12m21 m03m10m22 m03m11m20 m02m10m21
	inv.m[3] = rjd_math_vec4_add(inv.m[3], term);

	term = rjd_math_vec4_shuffle(t0,1,0,0,0);                          // m01 m00 m00 m00
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,2,3,1,2)); // m01m12 m00m13 m00m11 m00m12
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,3,2,3,1)); // m01m12m23 m00m13m22 m00m11m23 m00m12m21
	inv.m[3] = rjd_math_vec4_sub(inv.m[3], term);

	term = rjd_math_vec4_shuffle(t0,2,2,1,1);                          // m02 m02 m01 m01
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,3,0,3,0)); // m02m13 m02m10 m01m13 m01m10
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,1,3,0,2)); // m02m13m21 m02m10m23 m01m13m20 m01m10m22
	inv.m[3] = rjd_math_vec4_sub(inv.m[3], term);

	term = rjd_math_vec4_shuffle(t0,3,3,3,2);                          // m03 m03 m03 m02
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t1,1,2,0,1)); // m03m11 m03m12 m03m10 m02m11
	term = rjd_math_vec4_mul(term, rjd_math_vec4_shuffle(t2,2,0,1,0)); // m03m11m22 m03m12m20 m03m10m21 m02m11m20
	inv.m[3] = rjd_math_vec4_sub(inv.m[3], term);

	rjd_math_mat4 trans = rjd_math_mat4_transpose(inv);
	rjd_math_vec4 det = rjd_math_vec4_mul(trans.m[0], m.m[0]);

	det.v = _mm_hadd_ps(det.v, det.v);
	det.v = _mm_hadd_ps(det.v, det.v);
	det = rjd_math_vec4_shuffle(det,0,0,0,0);

	RJD_ASSERTMSG(!rjd_math_isequalf(rjd_math_vec4_x(det), 0), "Matrix is not invertible - if you're not sure, check rjd_math_mat4_det() == 0 beforehand");

	rjd_math_vec4 det_reciprocal = {_mm_rcp_ps(det.v)};

    rjd_math_mat4 out = {0};
	for (size_t i = 0; i < rjd_countof(out.m); ++i) {
		out.m[i] = rjd_math_vec4_mul(det_reciprocal, inv.m[i]);
	}

	// NOTE that intel's implementation is 82 intrinsics while this is at least 140(cofactor) + 9(determinant) + 
	// 		12(transpose) + 12(transpose), but this implementation is more straightforward

	return out;
}
static inline rjd_math_mat4 rjd_math_mat4_transpose(rjd_math_mat4 m) {
	_MM_TRANSPOSE4_PS(m.m[0].v, m.m[1].v, m.m[2].v, m.m[3].v);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_frustum_righthanded(float left, float right, float top, float bot, float near_plane, float far_plane) {
	float np = near_plane;
	float fp = far_plane;

	rjd_math_mat4 m = {0};
	m.m[0] = rjd_math_vec4_xyzw(2*np/(right-left),			0,						0,					0);
	m.m[1] = rjd_math_vec4_xyzw(0,							2*np/(top-bot),			0,					0);
	m.m[2] = rjd_math_vec4_xyzw((right+left)/(right-left),	(top+bot)/(top-bot),	-(fp+np)/(fp-np), 	-1);
	m.m[3] = rjd_math_vec4_xyzw(0,							0,						-2*fp*np/(fp-np),	0);
	return m;;
}
static inline rjd_math_mat4 rjd_math_mat4_ortho_righthanded(float left, float right, float top, float bot, float near_plane, float far_plane) {
	float np = near_plane;
	float fp = far_plane;

	rjd_math_mat4 m;
	m.m[0] = rjd_math_vec4_xyzw(           2/(right-left),                   0,                0, 0);
	m.m[1] = rjd_math_vec4_xyzw(                        0,         2/(top-bot),                0, 0);
	m.m[2] = rjd_math_vec4_xyzw(                        0,                   0,    1/(np-fp),  0);
	m.m[3] = rjd_math_vec4_xyzw((left+right)/(left-right), (top+bot)/(bot-top),	   np/(np-fp), 1);
	return m;
}
static inline rjd_math_mat4 rjd_math_mat4_ortho_lefthanded(float left, float right, float top, float bot, float near_plane, float far_plane) {
	RJD_ASSERTFAIL("not implemented");
	RJD_UNUSED_PARAM(left);
	RJD_UNUSED_PARAM(right);
	RJD_UNUSED_PARAM(top);
	RJD_UNUSED_PARAM(bot);
	RJD_UNUSED_PARAM(near_plane);
	RJD_UNUSED_PARAM(far_plane);
	return rjd_math_mat4_identity();
}
static inline rjd_math_mat4 rjd_math_mat4_perspective_righthanded(float y_fov, float aspect, float near_plane, float far_plane) {
    float scale = tanf(y_fov * 0.5f * RJD_MATH_PI / 180.0f) * near_plane; 
    float right = aspect * scale;
	float left = -right; 
	float top = scale;
	float bot = -top;
	return rjd_math_mat4_frustum_righthanded(left, right, top, bot, near_plane, far_plane);
}
static inline rjd_math_mat4 rjd_math_mat4_perspective_lefthanded(float y_fov, float aspect, float near_plane, float far_plane) {
	RJD_ASSERTFAIL("not implemented");
	RJD_UNUSED_PARAM(y_fov);
	RJD_UNUSED_PARAM(aspect);
	RJD_UNUSED_PARAM(near_plane);
	RJD_UNUSED_PARAM(far_plane);
	return rjd_math_mat4_identity();
}
static inline rjd_math_mat4 rjd_math_mat4_lookat_righthanded(rjd_math_vec3 eye, rjd_math_vec3 target, rjd_math_vec3 up) {
	rjd_math_vec3 forward = rjd_math_vec3_normalize(rjd_math_vec3_sub(target, eye));
	rjd_math_vec3 left = rjd_math_vec3_normalize(rjd_math_vec3_cross(forward, up));
	up = rjd_math_vec3_normalize(rjd_math_vec3_cross(left, forward));

	rjd_math_mat4 rot = rjd_math_mat4_rotationbasis(left, up, rjd_math_vec3_neg(forward));
	rjd_math_mat4 trans = rjd_math_mat4_translation(rjd_math_vec3_neg(eye));
	return rjd_math_mat4_mul(trans, rjd_math_mat4_transpose(rot));
}
static inline rjd_math_mat4 rjd_math_mat4_lookat_lefthanded(rjd_math_vec3 eye, rjd_math_vec3 target, rjd_math_vec3 up) {
	RJD_ASSERTFAIL("not implemented");
	RJD_UNUSED_PARAM(eye);
	RJD_UNUSED_PARAM(target);
	RJD_UNUSED_PARAM(up);
	return rjd_math_mat4_identity();
}
static inline float* rjd_math_mat4_write_colmajor(rjd_math_mat4 m, float* out) {
	RJD_ASSERT(RJD_MEM_ISALIGNED(out, 16));
	_mm_stream_ps(out + 0,  m.m[0].v);
	_mm_stream_ps(out + 4,  m.m[1].v);
	_mm_stream_ps(out + 8,  m.m[2].v);
	_mm_stream_ps(out + 12, m.m[3].v);
	return out + 16;
}
static inline float* rjd_math_mat4_write_rowmajor(rjd_math_mat4 m, float* out) {
	rjd_math_mat4 transpose = rjd_math_mat4_transpose(m);
	return rjd_math_mat4_write_colmajor(transpose, out);
}


////////////////////////////////////////////////////////////////////////////////
// rjd_geo.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_GEO_H 1

typedef struct {
	rjd_math_vec4 minmax; // xy is the min, zw is the max
} rjd_geo_rect;

typedef struct {
	rjd_math_vec3 xyr; // z is the radius
} rjd_geo_circle;

typedef struct {
	rjd_math_vec3 min;
	rjd_math_vec3 max;
} rjd_geo_box;

typedef struct {
	rjd_math_vec4 xyzr; // w is the radius
} rjd_geo_sphere;

typedef struct {
	rjd_math_vec3 p;
	rjd_math_vec3 d;
} rjd_geo_ray;

rjd_geo_rect rjd_geo_rect_minmax(float minx, float miny, float maxx, float maxy);
rjd_geo_circle rjd_geo_circle_xyr(float x, float y, float r);
rjd_geo_box rjd_geo_box_minmax(rjd_math_vec3 min,  rjd_math_vec3 max);
rjd_geo_sphere rjd_geo_sphere_xyzr(float x, float y, float z, float r);
rjd_geo_ray rjd_geo_ray_pd(rjd_math_vec3 p,  rjd_math_vec3 d);

bool rjd_geo_point_rect(rjd_math_vec3 p, rjd_geo_rect r);
bool rjd_geo_point_box(rjd_math_vec3 p, rjd_geo_box b);
bool rjd_geo_point_circle(rjd_math_vec3 p, rjd_geo_circle c);
bool rjd_geo_point_sphere(rjd_math_vec3 p, rjd_geo_sphere s);
bool rjd_geo_circle_circle(rjd_geo_circle c1, rjd_geo_circle c2);
bool rjd_geo_circle_rect(rjd_geo_circle c, rjd_geo_rect r);
bool rjd_geo_rect_rect(rjd_geo_rect a, rjd_geo_rect b);
bool rjd_geo_sphere_sphere(rjd_geo_sphere b, rjd_geo_sphere a);
bool rjd_geo_sphere_box(rjd_geo_sphere s, rjd_geo_box b);
bool rjd_geo_box_box(rjd_geo_box a, rjd_geo_box b);
bool rjd_geo_ray_point(rjd_geo_ray r, rjd_math_vec3 p, float* t_out);
bool rjd_geo_ray_sphere(rjd_geo_ray r, rjd_geo_sphere s, float* t_out);
bool rjd_geo_ray_box(rjd_geo_ray r, rjd_geo_box b, float* t_out);
bool rjd_geo_ray_boxfast(rjd_math_vec3 ray_pos, rjd_math_vec3 ray_inv_dir, rjd_geo_box b, float* t_out);

#if RJD_IMPL

rjd_geo_rect rjd_geo_rect_minmax(float minx, float miny, float maxx, float maxy) {
	RJD_ASSERT(minx <= maxx);
	RJD_ASSERT(miny <= maxy);
	rjd_geo_rect r = { rjd_math_vec4_xyzw(minx, miny, maxx, maxy) };
	return r;
}

rjd_geo_circle rjd_geo_circle_xyr(float x, float y, float r) {
	rjd_geo_circle c = { rjd_math_vec3_xyz(x,y,r) };
	return c;
}

rjd_geo_box rjd_geo_box_minmax(rjd_math_vec3 min, rjd_math_vec3 max) {
	rjd_geo_box b = { min, max };
	return b;
}

rjd_geo_sphere rjd_geo_sphere_xyzr(float x, float y, float z, float r) {
	rjd_geo_sphere s = { rjd_math_vec4_xyzw(x,y,z,r) };
	return s;
}

rjd_geo_ray rjd_geo_ray_pd(rjd_math_vec3 p, rjd_math_vec3 d) {
	rjd_geo_ray r = { p, d };
	return r;
}

bool rjd_geo_point_rect(rjd_math_vec3 p, rjd_geo_rect r) {
	rjd_math_vec4 pp = rjd_math_vec3to4(p);
	pp = rjd_math_vec4_shuffle(pp,0,1,0,1); // { x,y,x,y }

	rjd_math_vec4 a = { _mm_unpackhi_ps(pp.v, r.minmax.v) }; // { x maxx y maxy }
	rjd_math_vec4 b = { _mm_unpacklo_ps(pp.v, r.minmax.v) }; // { x minx y miny }
	b = rjd_math_vec4_shuffle(b,1,0,3,2);						 // { minx x miny y }
	
	return rjd_math_vec4_ge(a,b); // { x >= minx, maxx >= x, y >= miny, maxy >= y }
}

bool rjd_geo_point_box(rjd_math_vec3 p, rjd_geo_box b) {
	return rjd_math_vec3_ge(p, b.min) && rjd_math_vec3_ge(b.max, p);
}

bool rjd_geo_point_circle(rjd_math_vec3 p, rjd_geo_circle c) {
	rjd_math_vec3 v = rjd_math_vec3_sub(p, rjd_math_vec3_setz(c.xyr,0));
	return rjd_math_vec3_lengthsq(v) <= powf(rjd_math_vec3_z(c.xyr), 2);
}

bool rjd_geo_point_sphere(rjd_math_vec3 p, rjd_geo_sphere s) {
	rjd_math_vec4 pp = rjd_math_vec3to4(p);
	rjd_math_vec4 v = rjd_math_vec4_sub(pp, rjd_math_vec4_setw(s.xyzr, 0));
	return rjd_math_vec4_lengthsq(v) <= powf(rjd_math_vec4_w(s.xyzr), 2);
}

bool rjd_geo_circle_circle(rjd_geo_circle c1, rjd_geo_circle c2) {
	rjd_math_vec3 v = rjd_math_vec3_setz(rjd_math_vec3_sub(c1.xyr, c2.xyr), 0);
	rjd_math_vec3 added = rjd_math_vec3_add(c1.xyr, c2.xyr);
	rjd_math_vec3 squared = rjd_math_vec3_mul(added, added);
	return rjd_math_vec3_lengthsq(v) <= rjd_math_vec3_z(squared);
}

bool rjd_geo_circle_rect(rjd_geo_circle c, rjd_geo_rect r) {
	rjd_math_vec3 min = rjd_math_vec4to3(r.minmax);
	rjd_math_vec3 max = { _mm_movehl_ps(r.minmax.v, r.minmax.v) };

	rjd_math_vec3 center = rjd_math_vec3_setz(c.xyr, 0);
	rjd_math_vec3 p = rjd_math_vec3_max(min, rjd_math_vec3_min(max, center));
	p = rjd_math_vec3_setz(p, 0);
	return rjd_geo_point_circle(p, c);
}

bool rjd_geo_rect_rect(rjd_geo_rect a, rjd_geo_rect b) {
	rjd_math_vec4 min = { _mm_unpacklo_ps(a.minmax.v, b.minmax.v) }; // a.x, b.x, a.y, b.y
	rjd_math_vec4 max = { _mm_unpackhi_ps(a.minmax.v, b.minmax.v) }; // a.x, b.x, a.y, b.y
	max = rjd_math_vec4_shuffle(max,1,0,3,2); // b.x, a.x, b.y, a.y

	return rjd_math_vec4_ge(max, min);
}

bool rjd_geo_sphere_sphere(rjd_geo_sphere a, rjd_geo_sphere b) {
	rjd_math_vec4 v = rjd_math_vec4_setw(rjd_math_vec4_sub(a.xyzr, b.xyzr), 0);
	rjd_math_vec4 squared = rjd_math_vec4_mul(a.xyzr, b.xyzr);
	return rjd_math_vec4_lengthsq(v) <= rjd_math_vec4_w(squared);
}

bool rjd_geo_sphere_box(rjd_geo_sphere s, rjd_geo_box b) {
	rjd_math_vec3 center = rjd_math_vec4to3w(s.xyzr);
	rjd_math_vec3 p = rjd_math_vec3_max(b.min, rjd_math_vec3_min(b.max, center));
	return rjd_geo_point_sphere(p, s);
}

bool rjd_geo_box_box(rjd_geo_box a, rjd_geo_box b) {
	return rjd_math_vec3_ge(a.max, b.min) && rjd_math_vec3_ge(b.max, a.min);
}

bool rjd_geo_ray_point(rjd_geo_ray r, rjd_math_vec3 p, float* t_out) {
	rjd_math_vec3 to_p = rjd_math_vec3_sub(r.p, p);
	rjd_math_vec3 to_p_normalized = rjd_math_vec3_normalize(to_p);
	if (rjd_math_isequalf(rjd_math_vec3_dot(to_p_normalized, r.d), 1)) {
		return false;
	}

	if (t_out) {
		*t_out = rjd_math_vec3_length(to_p);
	}

	return true;
}

bool rjd_geo_ray_sphere(rjd_geo_ray r, rjd_geo_sphere s, float* t_out) {
	rjd_math_vec3 center = rjd_math_vec4to3w(s.xyzr);
	rjd_math_vec3 r_to_s = rjd_math_vec3_sub(center, r.p);
	float dot = rjd_math_vec3_dot(r.d, r_to_s);
	if (dot < 0) {
		return false;
	}

	rjd_math_vec3 p = rjd_math_vec3_scale(r.d, dot);
	rjd_math_vec3 s_to_p = rjd_math_vec3_sub(p, center);
	bool colliding = rjd_math_vec3_lengthsq(s_to_p) <= powf(rjd_math_vec4_w(s.xyzr), 2);
	if (colliding && t_out) {
		*t_out = dot;
	}

	return colliding;
}

bool rjd_geo_ray_box(rjd_geo_ray r, rjd_geo_box b, float* t_out) {
	rjd_math_vec3 inv_dir = rjd_math_vec3_div(rjd_math_vec3_one(), r.d);

	float t_dummy = FLT_MAX;
	if (!t_out) {
		t_out = &t_dummy;
	}

	return rjd_geo_ray_boxfast(r.p, inv_dir, b, t_out);
}

bool rjd_geo_ray_boxfast(rjd_math_vec3 ray_pos, rjd_math_vec3 ray_inv_dir, rjd_geo_box b, float* t_out) {
	rjd_math_vec3 v0 = rjd_math_vec3_mul(rjd_math_vec3_sub(b.min, ray_pos), ray_inv_dir);
	rjd_math_vec3 v1 = rjd_math_vec3_mul(rjd_math_vec3_sub(b.max, ray_pos), ray_inv_dir);

	rjd_math_vec3 min = rjd_math_vec3_min(v0, v1);
	rjd_math_vec3 max = rjd_math_vec3_max(v0, v1);

	float tmin = rjd_math_vec3_hmax(min);
	float tmax = rjd_math_vec3_hmax(max);

	bool colliding = (tmax >= 0) && (tmax >= tmin) && (tmin <= *t_out);
	if (colliding) {
		*t_out = tmin;
	}
	return colliding;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_procgeo.h
////////////////////////////////////////////////////////////////////////////////

#define RJD_PROCGEO_H 1

// dependencies:
// * math.h

// Functions for generating procedural geometry:
// * Generates centered at 0,0 scaled by input params. 
// * All functions write 3 floats per vertex, and skip stride number of floats. Pass 0 stride for tightly packed arrays.
// * Returns NULL if there isn't enough space in the float array to generate the geometry. Otherwise, returns the
//   pointer to one past the last element.
// * Use *_calc_num_verts() functions to find how many vertices you need.
// * Vertices are generated in clockwise winding order, assuming view is looking -Z

enum rjd_procgeo_type
{
	RJD_PROCGEO_TYPE_RECT,
	RJD_PROCGEO_TYPE_CIRCLE,
	RJD_PROCGEO_TYPE_BOX,
	RJD_PROCGEO_TYPE_CONE,
	RJD_PROCGEO_TYPE_CYLINDER,
	RJD_PROCGEO_TYPE_SPHERE,
	RJD_PROCGEO_TYPE_COUNT,
};

uint32_t rjd_procgeo_calc_num_verts(enum rjd_procgeo_type type, uint32_t tesselation);
float* rjd_procgeo(enum rjd_procgeo_type type, uint32_t tesselation, float size_x, float size_y, float size_z, float* out, uint32_t length, uint32_t stride);

uint32_t rjd_procgeo_rect_calc_num_verts(void);
uint32_t rjd_procgeo_circle_calc_num_verts(uint32_t tesselation);
uint32_t rjd_procgeo_box_calc_num_verts(void);
uint32_t rjd_procgeo_cone_calc_num_verts(uint32_t tesselation);
uint32_t rjd_procgeo_cylinder_calc_num_verts(uint32_t tesselation);
uint32_t rjd_procgeo_sphere_calc_num_verts(uint32_t tesselation);

float* rjd_procgeo_rect(float width, float height, float* out, uint32_t length, uint32_t stride);
float* rjd_procgeo_circle(float radius, uint32_t tesselation, float* out, uint32_t length, uint32_t stride);
float* rjd_procgeo_box(float width, float height, float depth, float* out, uint32_t length, uint32_t stride);
float* rjd_procgeo_cone(float radius, float height, uint32_t tesselation, float* out, uint32_t length, uint32_t stride);
float* rjd_procgeo_cylinder(float radius, float height, uint32_t tesselation, float* out, uint32_t length, uint32_t stride);
float* rjd_procgeo_sphere(float radius, uint32_t tesselation, float* out, uint32_t length, uint32_t stride);

////////////////////////////////////////////////////////////////////////////////
// inline implementation

#if RJD_IMPL

const float RJD_PROCGEO_PI = 3.141592653589793238462643f;
const uint32_t RJD_PROCGEO_MIN_TESSELATION_CIRCLE = 3;
const uint32_t RJD_PROCGEO_MIN_TESSELATION_SPHERE = 3;
const uint32_t RJD_PROCGEO_FLOATS_PER_TRI = 3;

uint32_t rjd_procgeo_calc_num_verts(enum rjd_procgeo_type type, uint32_t tesselation)
{
	switch (type)
	{
	 	case RJD_PROCGEO_TYPE_RECT: return rjd_procgeo_rect_calc_num_verts();
	 	case RJD_PROCGEO_TYPE_CIRCLE: return rjd_procgeo_circle_calc_num_verts(tesselation);
	 	case RJD_PROCGEO_TYPE_BOX: return rjd_procgeo_box_calc_num_verts();
	 	case RJD_PROCGEO_TYPE_CONE: return rjd_procgeo_cone_calc_num_verts(tesselation);
	 	case RJD_PROCGEO_TYPE_CYLINDER: return rjd_procgeo_cylinder_calc_num_verts(tesselation);
	 	case RJD_PROCGEO_TYPE_SPHERE: return rjd_procgeo_sphere_calc_num_verts(tesselation);
		default: break;
	}
	RJD_ASSERTFAIL("Unknown type: %d", type);
	return 0;
}

float* rjd_procgeo(enum rjd_procgeo_type type, uint32_t tesselation, float size_x, float size_y, float size_z, float* out, uint32_t length, uint32_t stride)
{
	switch (type)
	{
	 	case RJD_PROCGEO_TYPE_RECT: return rjd_procgeo_rect(size_x, size_y, out, length, stride);
	 	case RJD_PROCGEO_TYPE_CIRCLE: return rjd_procgeo_circle(size_x, tesselation, out, length, stride);
	 	case RJD_PROCGEO_TYPE_BOX: return rjd_procgeo_box(size_x, size_y, size_z, out, length, stride);
	 	case RJD_PROCGEO_TYPE_CONE: return rjd_procgeo_cone(size_x, size_y, tesselation, out, length, stride);
	 	case RJD_PROCGEO_TYPE_CYLINDER: return rjd_procgeo_cylinder(size_x, size_y, tesselation, out, length, stride);
	 	case RJD_PROCGEO_TYPE_SPHERE: return rjd_procgeo_sphere(size_x, tesselation, out, length, stride);
		default: break;
	}

	RJD_ASSERTFAIL("Unknown type: %d", type);
	return out;
}

uint32_t rjd_procgeo_rect_calc_num_verts() {
	return RJD_PROCGEO_FLOATS_PER_TRI * 2;
}

uint32_t rjd_procgeo_circle_calc_num_verts(uint32_t tesselation) {
	uint32_t final_tesselation = RJD_PROCGEO_MIN_TESSELATION_CIRCLE + tesselation;
	return RJD_PROCGEO_FLOATS_PER_TRI * final_tesselation;
}

uint32_t rjd_procgeo_box_calc_num_verts() {
	return RJD_PROCGEO_FLOATS_PER_TRI * 2 * 6;
}

uint32_t rjd_procgeo_cone_calc_num_verts(uint32_t tesselation) {
	return 2 * rjd_procgeo_circle_calc_num_verts(tesselation);
}

uint32_t rjd_procgeo_cylinder_calc_num_verts(uint32_t tesselation)
{
	uint32_t circle_verts = rjd_procgeo_circle_calc_num_verts(tesselation);
	uint32_t final_tesselation = RJD_PROCGEO_MIN_TESSELATION_CIRCLE + tesselation;
	uint32_t quad_verts = RJD_PROCGEO_FLOATS_PER_TRI * 2 * final_tesselation;
	return quad_verts + (circle_verts * 2);
}

uint32_t rjd_procgeo_sphere_calc_num_verts(uint32_t tesselation) {
	uint32_t final_tesselation = RJD_PROCGEO_MIN_TESSELATION_SPHERE + tesselation;
	uint32_t tri_verts = RJD_PROCGEO_FLOATS_PER_TRI;
	uint32_t quad_verts = tri_verts * 2;

	return quad_verts * final_tesselation * final_tesselation - tri_verts * final_tesselation * 2;
}

float* rjd_procgeo_rect(float width, float height, float* out, uint32_t length, uint32_t stride)
{
	const uint32_t floats_per_vert = RJD_PROCGEO_FLOATS_PER_TRI + (uint32_t)stride;
	const uint32_t num_verts = rjd_procgeo_rect_calc_num_verts();
	if (length < num_verts * floats_per_vert) {
		return NULL;
	}

	const float x = width / 2.0f;
	const float y = height / 2.0f;

	int32_t i = 0;

	out[i++] = -x; out[i++] = -y; out[i++] = 0.0f; i += stride;
	out[i++] =  x; out[i++] =  y; out[i++] = 0.0f; i += stride;
	out[i++] = -x; out[i++] =  y; out[i++] = 0.0f; i += stride;

	out[i++] = -x; out[i++] = -y; out[i++] = 0.0f; i += stride;
	out[i++] =  x; out[i++] = -y; out[i++] = 0.0f; i += stride;
	out[i++] =  x; out[i++] =  y; out[i++] = 0.0f; i += stride;

	return out + i;
}

float* rjd_procgeo_circle(float radius, uint32_t tesselation, float* out, uint32_t length, uint32_t stride)
{
	const uint32_t floats_per_vert = RJD_PROCGEO_FLOATS_PER_TRI + stride;
	const uint32_t num_verts = rjd_procgeo_circle_calc_num_verts(tesselation);
	if (length < num_verts * floats_per_vert) {
		return NULL;
	}

	const uint32_t final_tesselation = tesselation + RJD_PROCGEO_MIN_TESSELATION_CIRCLE;
	const float arc_radians = RJD_PROCGEO_PI * 2 / final_tesselation;

	for (uint32_t i = 0, arc_segment = 0; i < num_verts * floats_per_vert; ++arc_segment) {
		float p1_radians = arc_radians * arc_segment;
		float p2_radians = arc_radians * (arc_segment + 1);

		out[i++] = 0;							out[i++] = 0;							out[i++] = 0; i += stride;
		out[i++] = cosf(p1_radians) * radius;	out[i++] = sinf(p1_radians) * radius;	out[i++] = 0; i += stride;
		out[i++] = cosf(p2_radians) * radius;	out[i++] = sinf(p2_radians) * radius;	out[i++] = 0; i += stride;
	}

	return out + num_verts * floats_per_vert;
}

float* rjd_procgeo_box(float width, float height, float depth, float* out, uint32_t length, uint32_t stride)
{
	const uint32_t floats_per_vert = RJD_PROCGEO_FLOATS_PER_TRI + stride;
	const uint32_t num_verts = rjd_procgeo_box_calc_num_verts();
	if (length < num_verts * floats_per_vert) {
		return NULL;
	}

	const float x = width / 2;
	const float y = height / 2;
	const float z = depth / 2;

	int i = 0;

	// front
	out[i++] = -x; out[i++] =  y; out[i++] =  z; i += stride;
	out[i++] = -x; out[i++] = -y; out[i++] =  z; i += stride;
	out[i++] =  x; out[i++] = -y; out[i++] =  z; i += stride;
	out[i++] = -x; out[i++] =  y; out[i++] =  z; i += stride;
	out[i++] =  x; out[i++] = -y; out[i++] =  z; i += stride;
	out[i++] =  x; out[i++] =  y; out[i++] =  z; i += stride;

	// back
	out[i++] = -x; out[i++] =  y; out[i++] = -z; i += stride;
	out[i++] =  x; out[i++] = -y; out[i++] = -z; i += stride;
	out[i++] = -x; out[i++] = -y; out[i++] = -z; i += stride;
	out[i++] = -x; out[i++] =  y; out[i++] = -z; i += stride;
	out[i++] =  x; out[i++] =  y; out[i++] = -z; i += stride;
	out[i++] =  x; out[i++] = -y; out[i++] = -z; i += stride;

	// left
	out[i++] = -x; out[i++] = -y; out[i++] = -z; i += stride;
	out[i++] = -x; out[i++] = -y; out[i++] =  z; i += stride;
	out[i++] = -x; out[i++] =  y; out[i++] =  z; i += stride;
	out[i++] = -x; out[i++] = -y; out[i++] = -z; i += stride;
	out[i++] = -x; out[i++] =  y; out[i++] =  z; i += stride;
	out[i++] = -x; out[i++] =  y; out[i++] = -z; i += stride;

	// right
	out[i++] =  x; out[i++] = -y; out[i++] = -z; i += stride;
	out[i++] =  x; out[i++] =  y; out[i++] = -z; i += stride;
	out[i++] =  x; out[i++] =  y; out[i++] =  z; i += stride;
	out[i++] =  x; out[i++] = -y; out[i++] = -z; i += stride;
	out[i++] =  x; out[i++] =  y; out[i++] =  z; i += stride;
	out[i++] =  x; out[i++] = -y; out[i++] =  z; i += stride;

	// top
	out[i++] =  x; out[i++] =  y; out[i++] = -z; i += stride;
	out[i++] = -x; out[i++] =  y; out[i++] = -z; i += stride;
	out[i++] = -x; out[i++] =  y; out[i++] =  z; i += stride;
	out[i++] =  x; out[i++] =  y; out[i++] = -z; i += stride;
	out[i++] = -x; out[i++] =  y; out[i++] =  z; i += stride;
	out[i++] =  x; out[i++] =  y; out[i++] =  z; i += stride;

	// bottom
	out[i++] = -x; out[i++] = -y; out[i++] =  z; i += stride;
	out[i++] = -x; out[i++] = -y; out[i++] = -z; i += stride;
	out[i++] =  x; out[i++] = -y; out[i++] = -z; i += stride;
	out[i++] = -x; out[i++] = -y; out[i++] =  z; i += stride;
	out[i++] =  x; out[i++] = -y; out[i++] = -z; i += stride;
	out[i++] =  x; out[i++] = -y; out[i++] =  z; i += stride;

	return out + i;
}

float* rjd_procgeo_cone(float height, float radius, uint32_t tesselation, float* out, uint32_t length, uint32_t stride)
{
	const uint32_t floats_per_vert = RJD_PROCGEO_FLOATS_PER_TRI + stride;
	const uint32_t num_verts = rjd_procgeo_cone_calc_num_verts(tesselation);
	if (length < num_verts * floats_per_vert) {
		return NULL;
	}

	const uint32_t final_tesselation = tesselation + RJD_PROCGEO_MIN_TESSELATION_CIRCLE;
	const float arc_radians = RJD_PROCGEO_PI * 2 / final_tesselation;

	const uint32_t top_begin_offset = (num_verts / 2) * floats_per_vert;
	const float cone_y = height / 2;

	for (uint32_t i = 0, arc_segment = 0; i < top_begin_offset; i += 3 * (floats_per_vert), ++arc_segment) {
		float p1_radians = arc_radians * arc_segment;
		float p2_radians = arc_radians * (arc_segment + 1);

		float cos_1 = cosf(p1_radians) * radius; 
		float sin_1 = sinf(p1_radians) * radius;
		float cos_2 = cosf(p2_radians) * radius; 
		float sin_2 = sinf(p2_radians) * radius;

		uint32_t bot_index = i;
		uint32_t top_index = i + top_begin_offset;

		out[bot_index++] = 0;		out[bot_index++] = -cone_y;	out[bot_index++] = 0;		bot_index += stride;
		out[bot_index++] = cos_1;	out[bot_index++] = -cone_y;	out[bot_index++] = sin_1;	bot_index += stride;
		out[bot_index++] = cos_2;	out[bot_index++] = -cone_y;	out[bot_index++] = sin_2;	bot_index += stride;

		out[top_index++] = 0;		out[top_index++] = cone_y;	out[top_index++] = 0;		top_index += stride;
		out[top_index++] = cos_2;	out[top_index++] = -cone_y;	out[top_index++] = sin_2;	top_index += stride;
		out[top_index++] = cos_1;	out[top_index++] = -cone_y;	out[top_index++] = sin_1;	top_index += stride;
	}

	return out + num_verts * floats_per_vert;
}

float* rjd_procgeo_cylinder(float radius, float height, uint32_t tesselation, float* out, uint32_t length, uint32_t stride)
{
	const uint32_t floats_per_vert = RJD_PROCGEO_FLOATS_PER_TRI + stride;
	const uint32_t num_verts = rjd_procgeo_cylinder_calc_num_verts(tesselation);
	if (length < num_verts * floats_per_vert) {
		return NULL;
	}

	const uint32_t final_tesselation = tesselation + RJD_PROCGEO_MIN_TESSELATION_CIRCLE;
	const float arc_radians = RJD_PROCGEO_PI * 2 / final_tesselation;

	const uint32_t top_begin_offset = rjd_procgeo_circle_calc_num_verts(tesselation);
	const uint32_t side_begin_offset = top_begin_offset * 2;
	const float y = height / 2;

	for (uint32_t v = 0, arc_segment = 0; v < top_begin_offset; v += RJD_PROCGEO_FLOATS_PER_TRI, ++arc_segment) {
		float p1_radians = arc_radians * arc_segment;
		float p2_radians = arc_radians * (arc_segment + 1);

		float cos_1 = cosf(p1_radians) * radius; 
		float sin_1 = sinf(p1_radians) * radius;
		float cos_2 = cosf(p2_radians) * radius; 
		float sin_2 = sinf(p2_radians) * radius;

		uint32_t bot_index = v * floats_per_vert;
		out[bot_index++] = 0;		out[bot_index++] = -y; out[bot_index++] = 0;		bot_index += stride;
		out[bot_index++] = cos_1;	out[bot_index++] = -y; out[bot_index++] = sin_1;	bot_index += stride;
		out[bot_index++] = cos_2;	out[bot_index++] = -y; out[bot_index++] = sin_2;	bot_index += stride;

		uint32_t top_index = (v + top_begin_offset) * floats_per_vert;
		out[top_index++] = 0;		out[top_index++] = y; out[top_index++] = 0;		top_index += stride;
		out[top_index++] = cos_2;	out[top_index++] = y; out[top_index++] = sin_2;	top_index += stride;
		out[top_index++] = cos_1;	out[top_index++] = y; out[top_index++] = sin_1;	top_index += stride;

		uint32_t side_index = (v + v + side_begin_offset) * floats_per_vert;
		out[side_index++] = cos_1; out[side_index++] = -y; out[side_index++] = sin_1; side_index += stride;
		out[side_index++] = cos_1; out[side_index++] =  y; out[side_index++] = sin_1; side_index += stride;
		out[side_index++] = cos_2; out[side_index++] =  y; out[side_index++] = sin_2; side_index += stride;

		out[side_index++] = cos_2; out[side_index++] =  y; out[side_index++] = sin_2; side_index += stride;
		out[side_index++] = cos_2; out[side_index++] = -y; out[side_index++] = sin_2; side_index += stride;
		out[side_index++] = cos_1; out[side_index++] = -y; out[side_index++] = sin_1; side_index += stride;
	}

	return out + num_verts * floats_per_vert;
}

float* rjd_procgeo_sphere(float radius, uint32_t tesselation, float* out, uint32_t length, uint32_t stride)
{
	const uint32_t floats_per_vert = RJD_PROCGEO_FLOATS_PER_TRI + stride;
	const uint32_t num_verts = rjd_procgeo_sphere_calc_num_verts(tesselation);
	if (length < num_verts * floats_per_vert) {
		return NULL;
	}
	
	const float pi = RJD_PROCGEO_PI;

	const uint32_t final_tesselation = tesselation + RJD_PROCGEO_MIN_TESSELATION_SPHERE;

	uint32_t i = 0;

	for (uint32_t y_arc = 0; y_arc < final_tesselation; ++y_arc) {

		float y_arc1 = (float)y_arc / final_tesselation;
		float y_arc2 = (float)(y_arc + 1) / final_tesselation;

		float cos_2pi_y_arc1 = cosf(2 * pi * y_arc1);
		float cos_2pi_y_arc2 = cosf(2 * pi * y_arc2);

		float sin_2pi_y_arc1 = sinf(2 * pi * y_arc1);
		float sin_2pi_y_arc2 = sinf(2 * pi * y_arc2);

		for (uint32_t xz_arc = 0; xz_arc < final_tesselation; ++xz_arc) {

			float xz_arc1 = (float)xz_arc / final_tesselation;
			float xz_arc2 = (float)(xz_arc + 1) / final_tesselation;

			float sin_pi_xz_arc1 = sinf(pi * xz_arc1);
			float cos_pi_xz_arc1 = cosf(pi * xz_arc1);

			float sin_pi_xz_arc2 = sinf(pi * xz_arc2);
			float cos_pi_xz_arc2 = cosf(pi * xz_arc2);

			float x1 = sin_pi_xz_arc1 * cos_2pi_y_arc1 * radius;
			float y1 = cos_pi_xz_arc1 * radius;
			float z1 = sin_pi_xz_arc1 * sin_2pi_y_arc1 * radius;

			float x2 = sin_pi_xz_arc2 * cos_2pi_y_arc1 * radius;
			float y2 = cos_pi_xz_arc2 * radius;
			float z2 = sin_pi_xz_arc2 * sin_2pi_y_arc1 * radius;

			float x3 = sin_pi_xz_arc1 * cos_2pi_y_arc2 * radius;
			float y3 = cos_pi_xz_arc1 * radius;
			float z3 = sin_pi_xz_arc1 * sin_2pi_y_arc2 * radius;

			float x4 = sin_pi_xz_arc2 * cos_2pi_y_arc2 * radius;
			float y4 = cos_pi_xz_arc2 * radius;
			float z4 = sin_pi_xz_arc2 * sin_2pi_y_arc2 * radius;

			if (xz_arc > 0)
			{
				out[i++] = x1; out[i++] = y1; out[i++] = z1; i += stride;
				out[i++] = x3; out[i++] = y3; out[i++] = z3; i += stride;
				out[i++] = x2; out[i++] = y2; out[i++] = z2; i += stride;
			}

			if (xz_arc < final_tesselation - 1)
			{
				out[i++] = x2; out[i++] = y2; out[i++] = z2; i += stride;
				out[i++] = x3; out[i++] = y3; out[i++] = z3; i += stride;
				out[i++] = x4; out[i++] = y4; out[i++] = z4; i += stride;
			}
		}
	}

	return out + num_verts * floats_per_vert;
}

#endif


////////////////////////////////////////////////////////////////////////////////
// rjd_easing.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_EASING_H 1

enum rjd_ease_type
{
	RJD_EASE_TYPE_LINE, // linear
	RJD_EASE_TYPE_SINE, // sine
	RJD_EASE_TYPE_CUBE, // cubic
	RJD_EASE_TYPE_QUAD, // quadratic
	RJD_EASE_TYPE_QUAR, // quartic
	RJD_EASE_TYPE_QUIN, // quintic
	RJD_EASE_TYPE_EXPO, // exponential
	RJD_EASE_TYPE_CIRC, // circular
	RJD_EASE_TYPE_BACK, // back
	RJD_EASE_TYPE_ELAS, // elastic
	RJD_EASE_TYPE_BOUN, // bounce
	RJD_EASE_TYPE_MAX,
};

enum rjd_ease_dir
{
	RJD_EASE_DIR_INOUT,
	RJD_EASE_DIR_IN,
	RJD_EASE_DIR_OUT,
	RJD_EASE_DIR_MAX,
};

typedef float (*rjd_ease_func)(float t);

static inline float rjd_ease(float t, enum rjd_ease_type type, enum rjd_ease_dir dir);
static inline float rjd_ease_between(float t, float min, float max, rjd_ease_func f);
static inline float rjd_ease_line(float t);
static inline float rjd_ease_in_sine(float t);
static inline float rjd_ease_in_quad(float t);
static inline float rjd_ease_in_cube(float t);
static inline float rjd_ease_in_quar(float t);
static inline float rjd_ease_in_quin(float t);
static inline float rjd_ease_in_expo(float t);
static inline float rjd_ease_in_circ(float t);
static inline float rjd_ease_in_back(float t);
static inline float rjd_ease_in_elas(float t);
static inline float rjd_ease_in_boun(float t);
static inline float rjd_ease_out_sine(float t);
static inline float rjd_ease_out_quad(float t);
static inline float rjd_ease_out_cube(float t);
static inline float rjd_ease_out_quar(float t);
static inline float rjd_ease_out_quin(float t);
static inline float rjd_ease_out_expo(float t);
static inline float rjd_ease_out_circ(float t);
static inline float rjd_ease_out_back(float t);
static inline float rjd_ease_out_elas(float t);
static inline float rjd_ease_out_boun(float t);
static inline float rjd_ease_inout_sine(float t);
static inline float rjd_ease_inout_quad(float t);
static inline float rjd_ease_inout_cube(float t);
static inline float rjd_ease_inout_quar(float t);
static inline float rjd_ease_inout_quin(float t);
static inline float rjd_ease_inout_expo(float t);
static inline float rjd_ease_inout_circ(float t);
static inline float rjd_ease_inout_back(float t);
static inline float rjd_ease_inout_elas(float t);
static inline float rjd_ease_inout_boun(float t);

// impl

static inline float rjd_ease(float t, enum rjd_ease_type type, enum rjd_ease_dir dir)
{
	switch (dir) {
		case RJD_EASE_DIR_IN: {
			switch(type) {
				case RJD_EASE_TYPE_LINE: return rjd_ease_line(t);
				case RJD_EASE_TYPE_SINE: return rjd_ease_in_sine(t);
				case RJD_EASE_TYPE_CUBE: return rjd_ease_in_cube(t);
				case RJD_EASE_TYPE_QUAD: return rjd_ease_in_quad(t);
				case RJD_EASE_TYPE_QUAR: return rjd_ease_in_quar(t);
				case RJD_EASE_TYPE_QUIN: return rjd_ease_in_quin(t);
				case RJD_EASE_TYPE_EXPO: return rjd_ease_in_expo(t);
				case RJD_EASE_TYPE_CIRC: return rjd_ease_in_circ(t);
				case RJD_EASE_TYPE_BACK: return rjd_ease_in_back(t);
				case RJD_EASE_TYPE_ELAS: return rjd_ease_in_elas(t);
				case RJD_EASE_TYPE_BOUN: return rjd_ease_in_boun(t);
				case RJD_EASE_TYPE_MAX:  break;
			}
		}

		case RJD_EASE_DIR_OUT: {
			switch(type) {
				case RJD_EASE_TYPE_LINE: return rjd_ease_line(t);
				case RJD_EASE_TYPE_SINE: return rjd_ease_inout_sine(t);
				case RJD_EASE_TYPE_CUBE: return rjd_ease_inout_cube(t);
				case RJD_EASE_TYPE_QUAD: return rjd_ease_inout_quad(t);
				case RJD_EASE_TYPE_QUAR: return rjd_ease_inout_quar(t);
				case RJD_EASE_TYPE_QUIN: return rjd_ease_inout_quin(t);
				case RJD_EASE_TYPE_EXPO: return rjd_ease_inout_expo(t);
				case RJD_EASE_TYPE_CIRC: return rjd_ease_inout_circ(t);
				case RJD_EASE_TYPE_BACK: return rjd_ease_inout_back(t);
				case RJD_EASE_TYPE_ELAS: return rjd_ease_inout_elas(t);
				case RJD_EASE_TYPE_BOUN: return rjd_ease_inout_boun(t);
				case RJD_EASE_TYPE_MAX:  break;
			}
		}

		case RJD_EASE_DIR_INOUT: {
			switch(type) {
				case RJD_EASE_TYPE_LINE: return rjd_ease_line(t);
				case RJD_EASE_TYPE_SINE: return rjd_ease_inout_sine(t);
				case RJD_EASE_TYPE_CUBE: return rjd_ease_inout_cube(t);
				case RJD_EASE_TYPE_QUAD: return rjd_ease_inout_quad(t);
				case RJD_EASE_TYPE_QUAR: return rjd_ease_inout_quar(t);
				case RJD_EASE_TYPE_QUIN: return rjd_ease_inout_quin(t);
				case RJD_EASE_TYPE_EXPO: return rjd_ease_inout_expo(t);
				case RJD_EASE_TYPE_CIRC: return rjd_ease_inout_circ(t);
				case RJD_EASE_TYPE_BACK: return rjd_ease_inout_back(t);
				case RJD_EASE_TYPE_ELAS: return rjd_ease_inout_elas(t);
				case RJD_EASE_TYPE_BOUN: return rjd_ease_inout_boun(t);
				case RJD_EASE_TYPE_MAX:  break;
			}
		}

		default: break;
	}

	RJD_ASSERTFAIL("type (%d) or dir (%d) was invalid.\n", type, dir);
	return 0;
}

static inline float rjd_ease_between(float t, float min, float max, rjd_ease_func f) {
	return f(t) * (max - min) + min;
}

static inline float rjd_ease_line(float t) {
	return t;
}

static inline float rjd_ease_in_sine(float t) {
	return sinf((t - 1) * RJD_MATH_PI/2.0f) + 1;
}

static inline float rjd_ease_in_quad(float t) {
	return t*t;
}

static inline float rjd_ease_in_cube(float t) {
	return t*t*t;
}

static inline float rjd_ease_in_quar(float t) {
	return t*t*t*t;
}

static inline float rjd_ease_in_quin(float t) {
	return t*t*t*t*t;
}

static inline float rjd_ease_in_expo(float t) {
	return t == 0 ? t : powf(2, 10*(t - 1));
}

static inline float rjd_ease_in_circ(float t) {
	return -sqrtf(1-t*t) + 1;
}

static inline float rjd_ease_in_back(float t) {
	return t * t * t - t * sinf(t * RJD_MATH_PI);
}

static inline float rjd_ease_in_elas(float t) {
	return sinf(13.0f * RJD_MATH_PI / 2.0f * t) * powf(2, 10 * (t - 1));
}

static inline float rjd_ease_in_boun(float t) {
	return 1 - rjd_ease_out_boun(1 - t);
}

static inline float rjd_ease_out_sine(float t) {
	return sinf(t*RJD_MATH_PI/2.0f);
}

static inline float rjd_ease_out_quad(float t) {
	float tt = t - 1;
	return 1 - (tt * tt);
}

static inline float rjd_ease_out_cube(float t) {
	float tt = t - 1;
	return tt * tt * tt + 1;
}

static inline float rjd_ease_out_quar(float t) {
	float tt = t - 1;
	return 1 - (tt * tt * tt * tt);
}

static inline float rjd_ease_out_quin(float t) {
	float tt = t - 1;
	return tt * tt * tt * tt * tt + 1;
}

static inline float rjd_ease_out_expo(float t) {
	return t == 1 ? t : -powf(2, -10*t) + 1;
}

static inline float rjd_ease_out_circ(float t) {
	float tt = t - 1;
	return sqrtf(1 - tt * tt);
}

static inline float rjd_ease_out_back(float t) {
	float tt = 1 - t;
	return 1 - (tt*tt*tt - tt*sinf(tt*RJD_MATH_PI));
}

static inline float rjd_ease_out_elas(float t) {
	return sinf(-13.0f * RJD_MATH_PI / 2.0f * (t + 1)) * powf(2, -10 * t) + 1;
}

static inline float rjd_ease_out_boun(float t) {
	if (t < 4.0f/11.0f) {
		return 121 * t * t / 16.0f;
	} else if (t < 8.0f/11.0f) {
		return 363.0f/40.0f*t*t - 99.0f/10.0f*t + 17.0f/5.0f;
	} else if (t < 9.0f/10.0f) {
		return 4356.0f/361.0f*t*t - 35442.0f/1805.0f*t + 16061.0f/1805.0f;
	} else {
		return 54.0f/5.0f*t*t - 513.0f/25.0f*t + 268.0f/25.0f;
	}
}

static inline float rjd_ease_inout_sine(float t) {
	return sinf(t*RJD_MATH_PI - RJD_MATH_PI/2.0f) / 2.0f + 0.5f;
}

static inline float rjd_ease_inout_quad(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_quad(tt) : rjd_ease_out_quad(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_cube(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_cube(tt) : rjd_ease_out_cube(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_quar(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_quar(tt) : rjd_ease_out_quar(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_quin(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_quin(tt) : rjd_ease_out_quin(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_expo(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_expo(tt) : rjd_ease_out_expo(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_circ(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_circ(tt) : rjd_ease_out_circ(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_back(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_back(tt) : rjd_ease_out_back(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_elas(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_elas(tt) : rjd_ease_out_elas(tt - 1) + 1) / 2;
}

static inline float rjd_ease_inout_boun(float t) {
	float tt = t * 2.0f;
	return ((tt < 1) ? rjd_ease_in_boun(tt) : rjd_ease_out_boun(tt - 1) + 1) / 2;
}

////////////////////////////////////////////////////////////////////////////////
// rjd_strbuf.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_STRBUF_H 1

#ifndef RJD_STRBUF_STATIC_SIZE
	#define RJD_STRBUF_STATIC_SIZE 512
#endif

RJD_STATIC_ASSERT(RJD_STRBUF_STATIC_SIZE > 0);

struct rjd_mem_allocator;

struct rjd_strbuf
{
	struct rjd_mem_allocator* allocator;
	uint32_t length;
	char* heap;
	char stack[RJD_STRBUF_STATIC_SIZE];
};

struct rjd_strbuf rjd_strbuf_init(struct rjd_mem_allocator* allocator);
uint32_t rjd_strbuf_length(const struct rjd_strbuf* buf);
const char* rjd_strbuf_str(const struct rjd_strbuf* buf);
void rjd_strbuf_append(struct rjd_strbuf* buf, const char* format, ...);
void rjd_strbuf_appendv(struct rjd_strbuf* buf, const char* format, va_list args);
void rjd_strbuf_appendl(struct rjd_strbuf* buf, const char* str, uint32_t length);
void rjd_strbuf_free(struct rjd_strbuf* buf);

#define RJD_STRBUF_SCOPED(buffername, allocator, scope)				\
	{																\
		struct rjd_strbuf buffername = rjd_strbuf_init(allocator);	\
		{scope}														\
		rjd_strbuf_free(&buffername);								\
	}

#if RJD_IMPL

static void rjd_strbuf_grow(struct rjd_strbuf* buf, uint32_t format_length);

struct rjd_strbuf rjd_strbuf_init(struct rjd_mem_allocator* allocator)
{
	struct rjd_strbuf buf;
	buf.length = 0;
	buf.heap = 0;
	buf.stack[0] = 0;
	buf.allocator = allocator;

	return buf;
}

const char* rjd_strbuf_str(const struct rjd_strbuf* buf)
{
	RJD_ASSERT(buf);
	return buf->heap ? buf->heap : buf->stack;
}

void rjd_strbuf_append(struct rjd_strbuf* buf, const char* format, ...)
{
	RJD_ASSERT(buf);

	if (!format || *format == '\0') {
		return;
	}

	va_list args;
	va_start(args, format);
		rjd_strbuf_appendv(buf, format, args);
	va_end(args);
}

void rjd_strbuf_appendv(struct rjd_strbuf* buf, const char* format, va_list args)
{
	RJD_ASSERT(buf);

	if (!format || *format == '\0') {
		return;
	}

	uint32_t capacity = buf->heap ? rjd_array_capacity(buf->heap) : RJD_STRBUF_STATIC_SIZE;
	uint32_t remaining = capacity - buf->length;
	uint32_t format_length = (uint32_t)strlen(format);

	if (remaining < format_length + 1) {
		rjd_strbuf_grow(buf, format_length);
		remaining = rjd_array_capacity(buf->heap) - buf->length;
	}

	char* str = buf->heap ? buf->heap : buf->stack;
	int written = vsnprintf(str + buf->length, remaining, format, args);
	while (written < 0) {
		rjd_strbuf_grow(buf, 1);
		str = buf->heap;
		written = vsnprintf(str + buf->length, remaining, format, args);
	}

	buf->length += written;
}

void rjd_strbuf_appendl(struct rjd_strbuf* buf, const char* format, uint32_t length)
{
	RJD_ASSERT(buf);
	RJD_ASSERT(format + length <= format + strlen(format));

	if (format == NULL || *format == '\0') {
		return;
	}

	uint32_t capacity = buf->heap ? rjd_array_capacity(buf->heap) : RJD_STRBUF_STATIC_SIZE;
	uint32_t remaining = capacity - buf->length;

	if (remaining < length) {
		rjd_strbuf_grow(buf, length);
		remaining = rjd_array_capacity(buf->heap) - buf->length;
	}

	char* str = buf->heap ? buf->heap : buf->stack;
	memcpy(str + buf->length, format, length);
	buf->length += length;
	str[buf->length] = '\0';
}

void rjd_strbuf_free(struct rjd_strbuf* buf)
{
	RJD_ASSERT(buf);

	rjd_array_free(buf->heap);
	buf->length = 0;
	buf->heap = 0;
	buf->stack[0] = '\0';
}

static void rjd_strbuf_grow(struct rjd_strbuf* buf, uint32_t format_length)
{
	RJD_ASSERT(buf);
	RJD_ASSERT(buf->allocator);

	uint32_t current = buf->heap ? rjd_array_capacity(buf->heap) : RJD_STRBUF_STATIC_SIZE;
	uint32_t min = current + format_length + 1;
	uint32_t next = rjd_math_next_pow2(min);

	if (!buf->heap) {
		buf->heap = rjd_array_alloc(char, next, buf->allocator);
		rjd_array_resize(buf->heap, next);

		strcpy(buf->heap, buf->stack);
	}
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_timer.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_TIMER_H 1

struct rjd_timer
{
	double timestamp;
};

struct rjd_timer rjd_timer_init(void);
void rjd_timer_reset(struct rjd_timer* timer);
double rjd_timer_elapsed(const struct rjd_timer* timer);
double rjd_timer_global(void);

#define RJD_TIMER_SCOPE_BEGIN(name) struct rjd_timer timer_##name = rjd_timer_init();
#define RJD_TIMER_SCOPE_END_WITHLOG(name, log_function) log_function("Elapsed %s: %.4fms", #name, rjd_timer_elapsed(&timer_##name));
#define RJD_TIMER_SCOPE_END(name)	RJD_TIMER_SCOPE_END_WITHLOG(name, RJD_LOG)

#if RJD_IMPL

struct rjd_timer rjd_timer_init(void)
{
	struct rjd_timer timer;
	rjd_timer_reset(&timer);
	return timer;
}

void rjd_timer_reset(struct rjd_timer* timer)
{
	timer->timestamp = rjd_timer_global();
}

double rjd_timer_elapsed(const struct rjd_timer* timer)
{
	return rjd_timer_global() - timer->timestamp;
}
#if RJD_PLATFORM_WINDOWS
	static double RJD_QPC_FREQUENCY = 0;
	
	double rjd_timer_global(void)
	{
		if (RJD_QPC_FREQUENCY == 0) {
			LARGE_INTEGER frequency = {.QuadPart = 1};
			if (!QueryPerformanceFrequency(&frequency))
			{
				RJD_LOG("Failed to get QueryPerformanceFrequency: %d", GetLastError());
			}
			RJD_QPC_FREQUENCY = (double)frequency.QuadPart;
		}

		LARGE_INTEGER time = { .QuadPart = 0 };
		if (!QueryPerformanceCounter(&time))
		{
			RJD_LOG("Failed to get QueryPerformanceCounter. Time will be incorrect. Error: %d", GetLastError());
		}

		return (time.QuadPart * 1000LL) / RJD_QPC_FREQUENCY;
	}
#endif //RJD_PLATFORM_WINDOWS

#if RJD_PLATFORM_OSX
	#include <mach/mach.h>
	#include <mach/mach_time.h>

	static mach_timebase_info_data_t RJD_MACH_TIMEBASE_INFO;
	double rjd_timer_global(void)
	{
		if (RJD_MACH_TIMEBASE_INFO.denom == 0) {
			int ok = mach_timebase_info(&RJD_MACH_TIMEBASE_INFO);
			if (ok != KERN_SUCCESS) {
				RJD_LOG("Failed to get mach timebase info: %d", ok);
			}
		}

		double time = (double)mach_absolute_time();
		return time * ((double)RJD_MACH_TIMEBASE_INFO.numer / ((double)RJD_MACH_TIMEBASE_INFO.denom)) / 1000000;
	}
#endif // 

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_cmd.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_CMD_H 1

struct rjd_mem_allocator;

struct rjd_cmd_argv
{
	const char* shortname;
	const char* longname;
	const char* argname;
	const char* description;
};

struct rjd_cmd
{
	int argc;
	const char** argv;

	struct rjd_cmd_argv* opts;
	struct rjd_cmd_argv* reqs;

	struct rjd_mem_allocator* allocator;
};

struct rjd_cmd rjd_cmd_init(int argc, const char** argv, struct rjd_mem_allocator* allocator);
void rjd_cmd_free(struct rjd_cmd* cmd);
void rjd_cmd_add_opt(struct rjd_cmd* cmd, const char* shortname, const char* longname, const char* argname, const char* description);
void rjd_cmd_add_req(struct rjd_cmd* cmd, const char* argname, const char* description);
bool rjd_cmd_ok(const struct rjd_cmd* cmd);
void rjd_cmd_usage(const struct rjd_cmd* cmd);
void rjd_cmd_help(const struct rjd_cmd* cmd);

int rjd_cmd_int(const struct rjd_cmd* cmd, const char* shortname, int _default);
unsigned rjd_cmd_uint(const struct rjd_cmd* cmd, const char* shortname, unsigned _default);
double rjd_cmd_float(const struct rjd_cmd* cmd, const char* shortname, double _default);
bool rjd_cmd_bool(const struct rjd_cmd* cmd, const char* shortname);
const char* rjd_cmd_str(const struct rjd_cmd* cmd, const char* shortname);

#if RJD_IMPL

struct rjd_cmd rjd_cmd_init(int argc, const char** argv, struct rjd_mem_allocator* allocator)
{
	struct rjd_cmd cmd = {argc, argv, NULL, NULL, allocator};
	cmd.opts = rjd_array_alloc(struct rjd_cmd_argv, 8, allocator);
	cmd.reqs = rjd_array_alloc(struct rjd_cmd_argv, 8, allocator);

	rjd_cmd_add_opt(&cmd, "-h", "--help", NULL, "Prints help");
	return cmd;
}

void rjd_cmd_free(struct rjd_cmd* cmd)
{
	rjd_array_free(cmd->opts);
	rjd_array_free(cmd->reqs);
}

void rjd_cmd_add_opt(struct rjd_cmd* cmd, const char* shortname, const char* longname, const char* argname, const char* description)
{
	RJD_ASSERT(cmd);
	RJD_ASSERT(shortname);
	RJD_ASSERT(longname);
	RJD_ASSERT(description);

	struct rjd_cmd_argv opt = { shortname, longname, argname, description };
	rjd_array_push(cmd->opts, opt);
}

void rjd_cmd_add_req(struct rjd_cmd* cmd, const char* argname, const char* description)
{
	RJD_ASSERT(cmd);
	RJD_ASSERT(argname);
	RJD_ASSERT(description);

	struct rjd_cmd_argv req = { NULL, NULL, argname, description };
	rjd_array_push(cmd->reqs, req);
}

static const struct rjd_cmd_argv* rjd_cmd_matchopt(const struct rjd_cmd* cmd, const char* argv);
static int rjd_cmd_firstreq(const struct rjd_cmd* cmd);
static const struct rjd_cmd_argv* rjd_cmd_getopt(const struct rjd_cmd* cmd, const char* shortname);
static const char* rjd_cmd_findopt(const struct rjd_cmd* cmd, const char* shortname);
static const char* rjd_cmd_findreq(const struct rjd_cmd* cmd, const char* argname);

bool rjd_cmd_ok(const struct rjd_cmd* cmd)
{
	RJD_ASSERT(cmd);

	int count = rjd_array_count(cmd->reqs);
	if (cmd->argc - 1 < count) {
		return false;
	}

	const int firstreq = rjd_cmd_firstreq(cmd);

	for (int i = 1; i < firstreq; ++i) {
		const struct rjd_cmd_argv* opt = rjd_cmd_matchopt(cmd, cmd->argv[i]);

		if (!opt) {
			return false;
		}

		if (opt->argname) {
			if (!strcmp(cmd->argv[i], opt->shortname)) {
				// since we're expecting an argument, this shouldn't match any other options
				if (rjd_cmd_matchopt(cmd, cmd->argv[i+1])) {
					return false;
				}
			} else {
				const char* eq = strstr(cmd->argv[i], "=");
				if (!eq) {
					return false;
				}
				const char* arg = eq + 1;
				if (*arg == 0) {
					return false;
				}
			}
			++i;
		}
	}
	
	return (cmd->argc - 1 - firstreq) == (int) rjd_array_count(cmd->reqs);
}

void rjd_cmd_usage(const struct rjd_cmd* cmd)
{
	// TODO rjd_stringbuilder

	size_t offset = 0;

	char optString[4096];
	for (size_t i = 0; i < rjd_array_count(cmd->opts); ++i) {
		offset += snprintf(optString + offset, sizeof(optString) - offset, "%s", cmd->opts[i].shortname);
		if (i < rjd_array_count(cmd->opts) - 1) {
			offset += snprintf(optString + offset, sizeof(optString) - offset, " ");
		}
	}
	optString[offset] = 0;

	offset = 0;

	char reqString[4096];
	for (size_t i = 0; i < rjd_array_count(cmd->reqs); ++i) {
		offset += snprintf(reqString + offset, sizeof(reqString) - offset, "%s", cmd->reqs[i].argname);
		if (i < rjd_array_count(cmd->opts) - 1) {
			offset += snprintf(reqString + offset, sizeof(reqString) - offset, " ");
		}
	}
	reqString[offset] = 0;

	RJD_LOG("Usage: %s [%s] %s", cmd->argv[0], optString, reqString);
}

void rjd_cmd_help(const struct rjd_cmd* cmd) 
{
	rjd_cmd_usage(cmd);

	for (size_t i = 0; i < rjd_array_count(cmd->reqs); ++i) {
		RJD_LOG("%s\n\t%s", cmd->reqs[i].argname, cmd->reqs[i].description);
	}

	for (size_t i = 0; i < rjd_array_count(cmd->opts); ++i) {
		const struct rjd_cmd_argv* arg = cmd->opts + i;
		if (arg->argname) {
			RJD_LOG("%s %s, %s=%s\n\t%s", arg->shortname, arg->argname, arg->longname, arg->argname, arg->description);
		} else {
			RJD_LOG("%s, %s\n\t%s", arg->shortname, arg->longname, arg->description);
		}
	}
}

int rjd_cmd_int(const struct rjd_cmd* cmd, const char* name, int _default)
{
	return (int)rjd_cmd_float(cmd, name, _default);
}

unsigned rjd_cmd_uint(const struct rjd_cmd* cmd, const char* name, unsigned _default)
{
	double v = rjd_cmd_float(cmd, name, _default);
	if (v < 0) {
		return _default;
	}
	return (unsigned)v;
}

double rjd_cmd_float(const struct rjd_cmd* cmd, const char* name, double _default)
{
	const char* str = rjd_cmd_str(cmd, name);
	if (!str) {
		return _default;
	}

	char* end = NULL;
	double v = strtod(str, &end);
	if (v == 0 && end != NULL) {
		return _default;
	}
	return v;
}

bool rjd_cmd_bool(const struct rjd_cmd* cmd, const char* name)
{
	const char* str = rjd_cmd_str(cmd, name);
	if (!str) {
		return false;
	}

	if (!strcmp(str, "true")) {
		return true;
	} else if (!strcmp(str, "false")) {
		return false;
	}

	const struct rjd_cmd_argv* opt = rjd_cmd_getopt(cmd, name);
	return opt && !strcmp(opt->shortname, name);
}

const char* rjd_cmd_str(const struct rjd_cmd* cmd, const char* name)
{
	const char* opt = rjd_cmd_findopt(cmd, name);
	if (opt) {
		return opt;
	}

	const char* req = rjd_cmd_findreq(cmd, name);
	if (req) {
		return req;
	}

	return NULL;
}

static const struct rjd_cmd_argv* rjd_cmd_matchopt(const struct rjd_cmd* cmd, const char* argv)
{
	if (!argv) {
		return NULL;
	}

	for (uint32_t i = 0; i < rjd_array_count(cmd->opts); ++i) {
		const char* shortname = cmd->opts[i].shortname;
		const char* longname = cmd->opts[i].longname;
		if (!strcmp(shortname, argv)) {
			return cmd->opts + i;
		}
		if (strstr(argv, longname) == argv) {
			return cmd->opts + i;
		}
	}

	return NULL;
}
	
static int rjd_cmd_firstreq(const struct rjd_cmd* cmd)
{
	int index = 0;
	for (int i = 1; i < cmd->argc; ++i) {
		const struct rjd_cmd_argv* opt = rjd_cmd_matchopt(cmd, cmd->argv[i]);
		if (opt) {
			// skip the argument (assuming the format is ok)
			if (!strcmp(cmd->argv[i], opt->shortname) && opt->argname) {
				++i;
			}
			index = i;
		} else {
			break;
		}
	}

	return index + 1;
}

static const struct rjd_cmd_argv* rjd_cmd_getopt(const struct rjd_cmd* cmd, const char* shortname)
{
	for (uint32_t i = 0; i < rjd_array_count(cmd->opts); ++i) {
		if (!strcmp(cmd->opts[i].shortname, shortname)) {
			return cmd->opts + i;
		}
	}
	return NULL;
}

static const char* rjd_cmd_findopt(const struct rjd_cmd* cmd, const char* shortname)
{
	for (int i = 0; i < cmd->argc; ++i) {
		const struct rjd_cmd_argv* opt = rjd_cmd_matchopt(cmd, cmd->argv[i]);
		if (opt && !strcmp(opt->shortname, shortname)) {
			if (!opt->argname) {
				return cmd->argv[i];
			}
			if (!strcmp(cmd->argv[i], opt->shortname)) {
				return cmd->argv[i + 1];
			}
			const char* eq = strstr(cmd->argv[i], "=");
			if (eq) {
				return eq + 1;
			}
			break;
		}
	}
	return NULL;
}

static const char* rjd_cmd_findreq(const struct rjd_cmd* cmd, const char* argname) 
{
	int reqindex = -1;
	for (int i = 0; i < (int)rjd_array_count(cmd->reqs); ++i) {
		if (!strcmp(cmd->reqs[i].argname, argname)) {
			reqindex = i;
			break;
		}
	}

	if (reqindex == -1) {
		return NULL;
	}

	int optindex = rjd_cmd_firstreq(cmd) - 1; // -1 to get to first opt index

	int argvindex = optindex + reqindex + 1; // +1 to skip exe arg
	RJD_ASSERT(argvindex < cmd->argc);

	return cmd->argv[argvindex];
}

#endif


////////////////////////////////////////////////////////////////////////////////
// rjd_dict.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_DICT_H 1

struct rjd_mem_allocator;

struct rjd_dict
{
	uint32_t count;
	struct rjd_hash64* hashes;
	void** values;
	struct rjd_mem_allocator* allocator;
};

struct rjd_dict rjd_dict_init(struct rjd_mem_allocator* allocator, size_t initial_capacity);
void rjd_dict_insert(struct rjd_dict* dict, struct rjd_hash64 hash, void* item);
void* rjd_dict_erase(struct rjd_dict* dict, struct rjd_hash64 hash);
void* rjd_dict_get(const struct rjd_dict* dict, struct rjd_hash64 hash);
bool rjd_dict_has(const struct rjd_dict* dict, struct rjd_hash64 hash);
void rjd_dict_free(struct rjd_dict* dict);

static inline void rjd_dict_insert_hashstr(struct rjd_dict* dict, const char* key, void* item);
static inline void* rjd_dict_erase_hashstr(struct rjd_dict* dict, const char* key);
static inline void* rjd_dict_get_hashstr(const struct rjd_dict* dict, const char* key);
static inline bool rjd_dict_has_hashstr(const struct rjd_dict* dict, const char* key);

static inline void rjd_dict_insert_hashstr(struct rjd_dict* dict, const char* key, void* item)
{
	rjd_dict_insert(dict, rjd_hash64_data((uint8_t*)key, -1), item);
}

static inline void* rjd_dict_erase_hashstr(struct rjd_dict* dict, const char* key)
{
	return rjd_dict_erase(dict, rjd_hash64_data((uint8_t*)key, -1));
}

static inline void* rjd_dict_get_hashstr(const struct rjd_dict* dict, const char* key)
{
	return rjd_dict_get(dict, rjd_hash64_data((uint8_t*)key, -1));
}

static inline bool rjd_dict_has_hashstr(const struct rjd_dict* dict, const char* key)
{
	return rjd_dict_has(dict, rjd_hash64_data((uint8_t*)key, -1));
}

#if RJD_IMPL

enum rjd_dict_findmode
{
	RJD_DICT_FINDMODE_INSERTION,
	RJD_DICT_FINDMODE_EXISTING,
};

static void rjd_dict_grow(struct rjd_dict* dict, size_t capacity);
static int32_t rjd_dict_findindex(const struct rjd_hash64* hashes, struct rjd_hash64 hash, enum rjd_dict_findmode mode);
 
struct rjd_dict rjd_dict_init(struct rjd_mem_allocator* allocator, size_t initial_capacity)
{
	RJD_ASSERT(allocator);

	struct rjd_dict dict = { 0, NULL, NULL, allocator };

	if (initial_capacity > 0) {
		rjd_dict_grow(&dict, initial_capacity);
	}

	return dict;
}

void rjd_dict_insert(struct rjd_dict* dict, struct rjd_hash64 hash, void* value)
{
	RJD_ASSERT(dict);
	RJD_ASSERT(rjd_hash64_valid(hash));

	const float load = dict->hashes ? (dict->count + 1) / (float)rjd_array_capacity(dict->hashes) : 1;
	if (load > 0.6) {
		uint32_t capacity = dict->hashes ? rjd_array_capacity(dict->hashes) * 2 : 32;
		rjd_dict_grow(dict, capacity);
	}

	int32_t i = rjd_dict_findindex(dict->hashes, hash, RJD_DICT_FINDMODE_INSERTION);
	RJD_ASSERT(i >= 0);
	RJD_ASSERT(!rjd_hash64_valid(dict->hashes[i]));

	dict->hashes[i] = hash;
	dict->values[i] = value;
	++dict->count;
}

void* rjd_dict_erase(struct rjd_dict* dict, struct rjd_hash64 hash)
{
	RJD_ASSERT(dict);
	
	int32_t index = rjd_dict_findindex(dict->hashes, hash, RJD_DICT_FINDMODE_EXISTING);
	if (index < 0) {
		return NULL;
	}

	void* v = dict->values[index];

	dict->hashes[index] = rjd_hash64_data(NULL, 0);
	dict->values[index] = NULL;
	--dict->count;

	return v;
}

void* rjd_dict_get(const struct rjd_dict* dict, struct rjd_hash64 hash)
{
	RJD_ASSERT(dict);

	int32_t index = rjd_dict_findindex(dict->hashes, hash, RJD_DICT_FINDMODE_EXISTING);
	if (index < 0) {
		return NULL;
	}

	return dict->values[index];
}

bool rjd_dict_has(const struct rjd_dict* dict, struct rjd_hash64 hash)
{
	RJD_ASSERT(dict);

	if (!rjd_hash64_valid(hash)) {
		return false;
	}

	int32_t index = rjd_dict_findindex(dict->hashes, hash, RJD_DICT_FINDMODE_EXISTING);
	if (index >= 0) {
		return rjd_hash64_valid(dict->hashes[index]);
	}

	return false;
}

void rjd_dict_free(struct rjd_dict* dict)
{
	RJD_ASSERT(dict);

	rjd_array_free(dict->hashes);
	rjd_array_free(dict->values);
	dict->hashes = NULL;
	dict->values = NULL;
	dict->count = 0;
}

static void rjd_dict_grow(struct rjd_dict* dict, size_t capacity)
{
	RJD_ASSERT(capacity > 0);
	RJD_ASSERT(dict);

	struct rjd_hash64* hashes = rjd_array_alloc(struct rjd_hash64, (uint32_t)capacity, dict->allocator);
	void** values = rjd_array_alloc(void*, (uint32_t)capacity, dict->allocator);

	rjd_array_resize(hashes, (uint32_t)capacity);
	rjd_array_resize(values, (uint32_t)capacity);

	for (uint32_t i = 0; i < rjd_array_count(dict->hashes); ++i) {
		if (rjd_hash64_valid(dict->hashes[i])) {
			int32_t k = rjd_dict_findindex(hashes, dict->hashes[i], RJD_DICT_FINDMODE_INSERTION);
			RJD_ASSERT(k >= 0);
			hashes[k] = dict->hashes[i];
			values[k] = dict->values[i];
		}
	}

	rjd_array_free(dict->hashes);
	rjd_array_free(dict->values);

	dict->hashes = hashes;
	dict->values = values;
}

static int32_t rjd_dict_findindex(const struct rjd_hash64* hashes, struct rjd_hash64 hash, enum rjd_dict_findmode mode)
{
	if (!hashes) {
		return -1;
	}

	const uint32_t capacity = rjd_array_capacity(hashes);
	const uint32_t start = hash.value % capacity;
	uint32_t i = start;
	do {
		if (mode == RJD_DICT_FINDMODE_INSERTION && !rjd_hash64_valid(hashes[i])) {
			return (int32_t)i;
		} else if (mode == RJD_DICT_FINDMODE_EXISTING && hashes[i].value == hash.value) {
			return (int32_t)i;
		}

		i = (i + 1) % capacity;
	} while (i != start);

	return -1;
}

#endif


////////////////////////////////////////////////////////////////////////////////
// rjd_fio.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_FILEIO_H 1

enum rjd_fio_writemode
{
	RJD_FIO_WRITEMODE_REPLACE,
	RJD_FIO_WRITEMODE_APPEND,
};

// use rjd_array_free() to free *buffer after use
struct rjd_result rjd_fio_read(const char* path, char** buffer, struct rjd_mem_allocator* allocator);
struct rjd_result rjd_fio_write(const char* path, const char* data, size_t length, enum rjd_fio_writemode mode);
struct rjd_result rjd_fio_size(const char* path, size_t* out_size);
struct rjd_result rjd_fio_delete(const char* path);
struct rjd_result rjd_fio_mkdir(const char* path);
bool rjd_fio_exists(const char* path);

#if RJD_IMPL

static inline struct rjd_result rjd_fio_mkdir_platform(const char* foldername);

struct rjd_result rjd_fio_read(const char* path, char** buffer, struct rjd_mem_allocator* allocator)
{
	FILE* file = fopen(path, "rb");
	if (!file) {
		return RJD_RESULT("Failed to open the path for reading");
	}

	if (fseek(file, 0, SEEK_END)) {
		fclose(file);
		return RJD_RESULT("Failed to seek to the end of the file");
	}

	long int length = ftell(file);
	if (length < 0) {
		length = 0;
	}

	rewind(file);

	*buffer = rjd_array_alloc(char, (uint32_t)length, allocator);
	if (!*buffer) {
		return RJD_RESULT("Not enough memory in the allocator");
	}
	rjd_array_resize(*buffer, (uint32_t)length);

	size_t read_length = fread(*buffer, 1, length, file);
	fclose(file);

	if (read_length < (size_t)length) {
		rjd_array_free(*buffer);
		*buffer = NULL;
		return RJD_RESULT("Failed to read the entire file into memory");
	}

	return RJD_RESULT_OK();
}

struct rjd_result rjd_fio_write(const char* path, const char* data, size_t length, enum rjd_fio_writemode mode)
{
	const char* m = (mode == RJD_FIO_WRITEMODE_REPLACE) ? "wb" : "ab";
	FILE* file = fopen(path, m);
	if (!file) {
		return RJD_RESULT("Failed to open a writable handle");
	}

	const size_t written = fwrite(data, 1, length, file);

	fclose(file);

	if (written == 0) {
		return RJD_RESULT("Failed to write any bytes");
	} else if (written < length) {
		return RJD_RESULT("Failed to write the entire file");
	} else {
		return RJD_RESULT_OK();
	}
}

struct rjd_result rjd_fio_size(const char* path, size_t* out_size)
{
	FILE* file = fopen(path, "rb");
	if (!file) {
		return RJD_RESULT("Failed to open the path for reading");
	}

	if (fseek(file, 0, SEEK_END)) {
		fclose(file);
		return RJD_RESULT("Failed to seek to the end of the file");
	}

	long int length = ftell(file);
	fclose(file);

	*out_size = (size_t) length;
	return RJD_RESULT_OK();
}

struct rjd_result rjd_fio_mkdir(const char* path)
{
    RJD_ASSERT(path);
    RJD_ASSERT(*path);
    
    struct rjd_result result = RJD_RESULT_OK();
    
    const char* next = path;
    const char* end = next;
	do
    {
		end = strstr(end, "/");
        // skip directory separator
        if (end) {
            ++end;
        }
        
        char stackbuffer[256];
        const char* subpath = NULL;

		if (end) {
			size_t length = end - next;
            RJD_ASSERT(length < (ptrdiff_t)sizeof(stackbuffer));
			memcpy(stackbuffer, next, length);
			stackbuffer[length] = '\0';
			if (stackbuffer[length - 1] == '/') {
				stackbuffer[length - 1] = '\0';
			}
            subpath = stackbuffer;
		} else {
			subpath = next;
		}

		if (rjd_fio_exists(subpath)) {
			result = RJD_RESULT("Path already exists");
		} else {
			result = rjd_fio_mkdir_platform(subpath);
			if (!rjd_result_isok(result)) {
				break;
			}
		}
    } while (end != NULL);
    
    return result;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

#if RJD_COMPILER_MSVC

#include <shellapi.h>

static struct rjd_result rjd_fio_delete_folder_recursive(const wchar_t* directory_path);

#define RJD_FIO_UTF8_TO_UTF16(utf8, out_utf16_name)											\
	const size_t length_utf16 = mbstowcs(NULL, utf8, INT_MAX);								\
	wchar_t* out_utf16_name = rjd_mem_alloc_stack_array_noclear(wchar_t, length_utf16 + 1);	\
	mbstowcs(out_utf16_name, utf8, INT_MAX);

struct rjd_result rjd_fio_delete(const char* path)
{
	RJD_ASSERT(path && *path);
	RJD_FIO_UTF8_TO_UTF16(path, path_wide);

	DWORD attributes = GetFileAttributesW(path_wide);
	if (attributes == INVALID_FILE_ATTRIBUTES)
	{
		return RJD_RESULT("Failed getting path attributes. Check permissions and verify the path exists.");
	}

	if (attributes & FILE_ATTRIBUTE_READONLY) {
		return RJD_RESULT("Path is read-only");
	}

	if (attributes & FILE_ATTRIBUTE_DIRECTORY) {
		return rjd_fio_delete_folder_recursive(path_wide);
	}

	if (!DeleteFileW(path_wide)) {
		return RJD_RESULT("Failed to delete file. Check GetLastError() for more info.");
	}

	return RJD_RESULT_OK();
}

bool rjd_fio_exists(const char* path)
{
	RJD_ASSERT(path);
	RJD_FIO_UTF8_TO_UTF16(path, path_wide);

	DWORD attributes = GetFileAttributesW(path_wide);
	if (attributes == INVALID_FILE_ATTRIBUTES) {
		DWORD err = GetLastError();
		return err != ERROR_FILE_NOT_FOUND && err != ERROR_PATH_NOT_FOUND;
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////////

static inline struct rjd_result rjd_fio_mkdir_platform(const char* foldername)
{
	RJD_FIO_UTF8_TO_UTF16(foldername, foldername_wide);

	struct rjd_result result = RJD_RESULT_OK();
	SECURITY_ATTRIBUTES security = { .nLength = sizeof(SECURITY_ATTRIBUTES) };
	if (!CreateDirectoryW(foldername_wide, &security)) {
		const int error = GetLastError();
		RJD_ASSERTMSG(error != ERROR_PATH_NOT_FOUND, "The rjd_fio_mkdir() code should handle this case.");
		switch (GetLastError())
		{
			case ERROR_ALREADY_EXISTS: result = RJD_RESULT("Folder already exists"); break;
			default: result = RJD_RESULT("Unknown error creating subfolder"); break;
		}
	}

	return result;
}

struct rjd_result rjd_fio_delete_folder_recursive(const wchar_t* directory_path)
{
	wchar_t* path_with_search_spec = NULL;
	const size_t path_length = wcslen(directory_path);
	{
		const wchar_t search_spec[] = L"/*";
		path_with_search_spec = rjd_mem_alloc_stack_array_noclear(wchar_t, path_length + rjd_countof(search_spec) + 1);
		wcscpy(path_with_search_spec, directory_path);
		wcscpy(path_with_search_spec + path_length, search_spec);
	}

	WIN32_FIND_DATAW find_data = {0};
	const HANDLE find_handle = FindFirstFileW(path_with_search_spec, &find_data);
	if (find_handle == INVALID_HANDLE_VALUE) {
		const DWORD err = GetLastError();
		if (err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND) {
			return RJD_RESULT("Directory not found");
		}
		return RJD_RESULT("Failed while enumerating directory contents. Check GetLastError() for more info");
	}

	do
	{
		if (find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
			if (wcscmp(find_data.cFileName, L".") != 0 &&
				wcscmp(find_data.cFileName, L"..") != 0) {

				size_t nested_path_length = wcslen(find_data.cFileName);
				wchar_t* nested_path = _alloca((path_length + nested_path_length + 2) * sizeof(wchar_t)); // +2 for null and path separator
				wcscpy(nested_path, directory_path);
				wcscpy(nested_path + path_length, L"/");
				wcscpy(nested_path + path_length + 1, find_data.cFileName);

				struct rjd_result result = rjd_fio_delete_folder_recursive(nested_path);
				if (!rjd_result_isok(result)) {
					return result;
				}
			}
		} else {
			if (!DeleteFileW(find_data.cFileName)) {
				FindClose(find_handle);
				return RJD_RESULT("Failed to delete file. Check GetLastError() for more info.");
			}
		}
	} while (FindNextFileW(find_handle, &find_data));

	FindClose(find_handle);

	if (GetLastError() != ERROR_NO_MORE_FILES) {
		return RJD_RESULT("Failed while enumerating directory contents. Check GetLastError() for more info");
	}

	if (!RemoveDirectoryW(directory_path)) {
		return RJD_RESULT("Failed to delete the directory. Check GetLastError() for more info");
	}

	return RJD_RESULT_OK();
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

#elif RJD_COMPILER_GCC || RJD_COMPILER_CLANG

#include <sys/stat.h>
#include <ftw.h>
#include <errno.h>

static int rjd_delete_nftw_func(const char *path, const struct stat *sb, int typeflag, struct FTW *ftwbuf);

struct rjd_result rjd_fio_delete(const char* path)
{
	if (remove(path)) {
    	if (nftw(path, rjd_delete_nftw_func, 64, FTW_DEPTH | FTW_PHYS)) {
			return RJD_RESULT("delete failed");
		}
	}

	return RJD_RESULT_OK();
}

bool rjd_fio_exists(const char* path)
{
    struct stat unused;
    return !stat(path, &unused);
}

////////////////////////////////////////////////////////////////////////////////

static int rjd_delete_nftw_func(const char *path, const struct stat *sb, int typeflag, struct FTW *ftwbuf)
{
	RJD_UNUSED_PARAM(sb);
	RJD_UNUSED_PARAM(typeflag);
	RJD_UNUSED_PARAM(ftwbuf);
	return remove(path);
}

static inline struct rjd_result rjd_fio_mkdir_platform(const char* foldername)
{
	const mode_t mode = S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH;
	const int error = mkdir(foldername, mode);

	struct rjd_result result = RJD_RESULT_OK();
	switch (error)
	{
		case 0: break;
		case EACCES: result = RJD_RESULT("The parent directory does not allow write permission to the process, or one of the directories in pathname did not allow search permission."); break;
		case EDQUOT: result = RJD_RESULT("The user's quota of disk blocks or inodes on the file system has been exhausted."); break;
		case EEXIST: result = RJD_RESULT("pathname already exists (not necessarily as a directory). This includes the case where pathname is a symbolic link, dangling or not."); break;
		case EFAULT: result = RJD_RESULT("pathname points outside your accessible address space."); break;
		case ELOOP: result = RJD_RESULT("Too many symbolic links were encountered in resolving pathname."); break;
		case EMLINK: result = RJD_RESULT("The number of links to the parent directory would exceed LINK_MAX."); break;
		case ENAMETOOLONG: result = RJD_RESULT("pathname was too long."); break;
		case ENOENT: result = RJD_RESULT("A directory component in pathname does not exist or is a dangling symbolic link."); break;
		case ENOMEM: result = RJD_RESULT("Insufficient kernel memory was available."); break;
		case ENOSPC: result = RJD_RESULT("The device has no room for the new directory (user's disk quota may be exhausted)."); break;
		case ENOTDIR: result = RJD_RESULT("A component used as a directory in pathname is not, in fact, a directory."); break;
		case EPERM: result = RJD_RESULT("The file system containing pathname does not support the creation of directories."); break;
		case EROFS: result = RJD_RESULT("pathname refers to a file on a read-only file system."); break; 
		default: result = RJD_RESULT("Unknown error creating subpath"); break;
	}

	return result;
}

#endif

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_thread.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_THREAD

#ifndef RJD_THREAD_STACKSIZE_DEFAULT
	#define RJD_THREAD_STACKSIZE_DEFAULT (4 * RJD_MB)
#endif

#define RJD_THREAD_NAME_MAX_LENGTH (16u)

typedef void rjd_thread_entrypoint_func(void* userdata);

struct rjd_thread_desc
{
	rjd_thread_entrypoint_func* entrypoint_func;
	struct rjd_mem_allocator* allocator;
	uint32_t stacksize;
	void* userdata;
	const char optional_name[RJD_THREAD_NAME_MAX_LENGTH];
};

struct rjd_thread_id
{
	char platform_impl[8];
};

struct rjd_thread_platform
{
	char platform_impl[16];
};

struct rjd_thread
{
	struct rjd_thread_id id;
	struct rjd_thread_platform platform;
};

struct rjd_condvar
{
	char platform_impl[128 + 256];
};

struct rjd_lock
{
	char platform_impl[64];
};

struct rjd_rwlock
{
	char platform_impl[256];
};

struct rjd_thread_id rjd_thread_id_current(void);
bool rjd_thread_id_equals(const struct rjd_thread_id a, const struct rjd_thread_id b);

struct rjd_result rjd_thread_create(struct rjd_thread* thread, struct rjd_thread_desc desc);
struct rjd_result rjd_thread_join(struct rjd_thread* thread);
struct rjd_result rjd_thread_getname(struct rjd_thread* thread, uint32_t destination_max_length, char* out);
void rjd_thread_sleep(uint32_t seconds);

struct rjd_result rjd_condvar_create(struct rjd_condvar* condvar);
struct rjd_result rjd_condvar_destroy(struct rjd_condvar* condvar);
struct rjd_result rjd_condvar_lock(struct rjd_condvar* condvar);
struct rjd_result rjd_condvar_unlock(struct rjd_condvar* condvar);
struct rjd_result rjd_condvar_signal_single(struct rjd_condvar* condvar); // automatically unlocks
struct rjd_result rjd_condvar_signal_all(struct rjd_condvar* condvar); // automatically unlocks
struct rjd_result rjd_condvar_wait(struct rjd_condvar* condvar);
struct rjd_result rjd_condvar_wait_timed(struct rjd_condvar* condvar, uint32_t seconds);

struct rjd_result rjd_lock_create(struct rjd_lock* lock);
struct rjd_result rjd_lock_destroy(struct rjd_lock* lock);
struct rjd_result rjd_lock_acquire(struct rjd_lock* lock);
struct rjd_result rjd_lock_try_acquire(struct rjd_lock* lock);
struct rjd_result rjd_lock_release(struct rjd_lock* lock);

struct rjd_result rjd_rwlock_create(struct rjd_rwlock* lock);
struct rjd_result rjd_rwlock_destroy(struct rjd_rwlock* lock);
struct rjd_result rjd_rwlock_acquire_reader(struct rjd_rwlock* lock);
struct rjd_result rjd_rwlock_acquire_writer(struct rjd_rwlock* lock);
struct rjd_result rjd_rwlock_try_acquire_reader(struct rjd_rwlock* lock);
struct rjd_result rjd_rwlock_try_acquire_writer(struct rjd_rwlock* lock);
struct rjd_result rjd_rwlock_release_reader(struct rjd_rwlock* lock);
struct rjd_result rjd_rwlock_release_writer(struct rjd_rwlock* lock);

#if RJD_IMPL

#if RJD_PLATFORM_WINDOWS

#include <processthreadsapi.h>
#include <synchapi.h>

const struct rjd_thread_id RJD_THREAD_ID_INVALID = { 0 };

struct rjd_thread_id_win32
{
	uint64_t id;
};

struct rjd_thread_win32
{
	HANDLE handle;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_thread_win32) <= sizeof(struct rjd_thread_platform));
RJD_STATIC_ASSERT(sizeof(HANDLE) <= sizeof(uint64_t));

struct rjd_thread_params
{
	rjd_thread_entrypoint_func* entrypoint_func;
	void* userdata;
};

struct rjd_condvar_win32
{
	CONDITION_VARIABLE condition_variable;
	struct rjd_rwlock lock;
	bool is_locked;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_condvar_win32) <= sizeof(struct rjd_condvar));

struct rjd_lock_win32
{
	struct rjd_thread_id owning_thread;
	CRITICAL_SECTION cs;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_lock_win32) <= sizeof(struct rjd_lock));

struct rjd_rwlock_win32
{
	SRWLOCK lock;
	struct rjd_thread_id exclusive_owning_thread;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_rwlock_win32) <= sizeof(struct rjd_rwlock));

DWORD WINAPI rjd_thread_entrypoint_win32(LPVOID lpParameter);

#if defined(_WIN32_WINNT) &&(_WIN32_WINNT >= _WIN32_WINNT_WIN10)	\
	&& defined(WINVER) && (WINVER >= _WIN32_WINNT_WIN10)			\
	&& defined(WDK_NTDDI_VERSION) && (WDK_NTDDI_VERSION >= NTDDI_WIN10_RS1)
	#define RJD_THREAD_NAME_AVAILABLE 1
#else 
	#define RJD_THREAD_NAME_AVAILABLE 0

	const struct rjd_result RJD_RESULT_THREADNAME_UNAVAILABLE = {
		"Thread naming uses features that require WINVER and _WIN32_WINNT to be set to at least "
		"_WIN32_WINNT_WIN10 (0x0A00), and WDK_NTDDI_VERSION set to NTDDI_WIN10_RS1 (0x0A000002)" };
#endif

#if RJD_THREAD_NAME_AVAILABLE && RJD_COMPILER_GCC
	// The headers don't have the declarations for these functions but the imports exist in the libs,
	// so this is a workaround until that bug gets fixed.
	WINBASEAPI HRESULT WINAPI SetThreadDescription(
	    _In_ HANDLE hThread,
	    _In_ PCWSTR lpThreadDescription
	    );

	 
	WINBASEAPI HRESULT WINAPI GetThreadDescription(
	    _In_ HANDLE hThread,
	    _Outptr_result_z_ PWSTR* ppszThreadDescription
	    );
#endif

////////////////////////////////////////////////////////////////////////////////
// interface implementation

struct rjd_thread_id rjd_thread_id_current(void)
{
	struct rjd_thread_id id = {0};
	struct rjd_thread_id_win32* id_win32 = (struct rjd_thread_id_win32*)&id;
	id_win32->id = GetCurrentThreadId();
	return id;
}

bool rjd_thread_id_equals(const struct rjd_thread_id a, const struct rjd_thread_id b)
{
	struct rjd_thread_id_win32* a_win32 = (struct rjd_thread_id_win32*)&a;
	struct rjd_thread_id_win32* b_win32 = (struct rjd_thread_id_win32*)&b;
	return a_win32->id == b_win32->id;
}

struct rjd_result rjd_thread_create(struct rjd_thread* thread, struct rjd_thread_desc desc)
{
	struct rjd_thread_win32* thread_win32 = (struct rjd_thread_win32*)thread;

	SECURITY_ATTRIBUTES security = { 
		.nLength = sizeof(SECURITY_ATTRIBUTES),
		.bInheritHandle = false,
	};

	struct rjd_thread_params* params = rjd_mem_alloc(struct rjd_thread_params, desc.allocator);
	params->entrypoint_func = desc.entrypoint_func;
	params->userdata = desc.userdata;

	// Note that there's no way to provide stack memory to CreateThread() on windows, so we just ignore
	// the desc.allocator param on this platform.
	DWORD flags = 0;
	DWORD threadId = 0;
	HANDLE handle = CreateThread(&security, desc.stacksize, rjd_thread_entrypoint_win32, params, flags, &threadId);
	if (handle == NULL) {
		return RJD_RESULT("CreateThread() failed. Call GetLastError() for more info");
	}

	thread_win32->handle = handle;

	if (desc.optional_name) {
		#if RJD_THREAD_NAME_AVAILABLE
			wchar_t widename[32];
			size_t length = mbstowcs(widename, desc.optional_name, rjd_countof(widename) - 1);
			widename[length] = '\0';

			if (FAILED(SetThreadDescription(handle, widename))) {
				return RJD_RESULT("Thread was created, but name was unable to be set. Call GetLastError for more info");
			}
		#else
			return RJD_RESULT_THREADNAME_UNAVAILABLE;
		#endif
	}

	return RJD_RESULT_OK();
}

struct rjd_result rjd_thread_join(struct rjd_thread* thread)
{
	struct rjd_thread_win32* thread_win32 = (struct rjd_thread_win32*)thread;
	DWORD result = WaitForSingleObject(thread_win32->handle, INFINITE);
	if (result == WAIT_FAILED) {
		return RJD_RESULT("Wait failed. Call GetLastError for more info");
	}

	return RJD_RESULT_OK();
}

struct rjd_result rjd_thread_getname(struct rjd_thread* thread, uint32_t destination_max_length, char* out)
{
	#if RJD_THREAD_NAME_AVAILABLE
		struct rjd_thread_win32* thread_win32 = (struct rjd_thread_win32*)thread;

		wchar_t* thread_name = NULL;
		if (FAILED(GetThreadDescription(thread_win32->handle, &thread_name)) || !thread_name) {
			return RJD_RESULT("Unable to get thread name. Call GetLastError for more info");
		}

		size_t length = wcstombs(out, thread_name, destination_max_length - 1);
		out[length] = '\0';

		LocalFree(thread_name);
		
		return RJD_RESULT_OK();	
	#else
		RJD_UNUSED_PARAM(thread);
		if (destination_max_length > 0) {
			out[0] = '\0';
		}
		return RJD_RESULT_THREADNAME_UNAVAILABLE;
	#endif
}

void rjd_thread_sleep(uint32_t seconds)
{
	Sleep(seconds * 1000);
}

struct rjd_result rjd_condvar_create(struct rjd_condvar* condvar)
{
	struct rjd_condvar_win32* condvar_win32 = (struct rjd_condvar_win32*)condvar;
	
	InitializeConditionVariable(&condvar_win32->condition_variable);
	return rjd_rwlock_create(&condvar_win32->lock);
}

struct rjd_result rjd_condvar_destroy(struct rjd_condvar* condvar)
{
	// nothing to do for CONDITION_VARIABLE
	struct rjd_condvar_win32* condvar_win32 = (struct rjd_condvar_win32*)condvar;
	return rjd_rwlock_destroy(&condvar_win32->lock);
}

struct rjd_result rjd_condvar_lock(struct rjd_condvar* condvar)
{
	struct rjd_condvar_win32* condvar_win32 = (struct rjd_condvar_win32*)condvar;
	return rjd_rwlock_acquire_writer(&condvar_win32->lock);
}

struct rjd_result rjd_condvar_unlock(struct rjd_condvar* condvar)
{
	struct rjd_condvar_win32* condvar_win32 = (struct rjd_condvar_win32*)condvar;
	return rjd_rwlock_release_writer(&condvar_win32->lock);
}

struct rjd_result rjd_condvar_signal_single(struct rjd_condvar* condvar)
{
	struct rjd_condvar_win32* condvar_win32 = (struct rjd_condvar_win32*)condvar;
	WakeConditionVariable(&condvar_win32->condition_variable);
	return RJD_RESULT_OK();
}

struct rjd_result rjd_condvar_signal_all(struct rjd_condvar* condvar)
{
	struct rjd_condvar_win32* condvar_win32 = (struct rjd_condvar_win32*)condvar;
	WakeAllConditionVariable(&condvar_win32->condition_variable);
	return RJD_RESULT_OK();
}

struct rjd_result rjd_condvar_wait(struct rjd_condvar* condvar)
{
	return rjd_condvar_wait_timed(condvar, INFINITE);
}

struct rjd_result rjd_condvar_wait_timed(struct rjd_condvar* condvar, uint32_t seconds)
{
	struct rjd_condvar_win32* condvar_win32 = (struct rjd_condvar_win32*)condvar;
	struct rjd_rwlock_win32* lock_win32 = (struct rjd_rwlock_win32*)&condvar_win32->lock;
	RJD_ASSERTMSG(!rjd_thread_id_equals(lock_win32->exclusive_owning_thread, RJD_THREAD_ID_INVALID),
		"You must lock the condvar before waiting on it.");

	uint32_t ms = (seconds == INFINITE) ? INFINITE : seconds * 1000;

	lock_win32->exclusive_owning_thread = RJD_THREAD_ID_INVALID;

	if (!SleepConditionVariableSRW(&condvar_win32->condition_variable, &lock_win32->lock, ms, 0)) {
		if (GetLastError() == ERROR_TIMEOUT) {
			return RJD_RESULT("Timed out");
		} else {
			return RJD_RESULT("Unknown failure. Call GetLastError() to know more");
		}
	}

	const struct rjd_thread_id current_thread = rjd_thread_id_current();
	lock_win32->exclusive_owning_thread = current_thread;

	return RJD_RESULT_OK(); 
}

struct rjd_result rjd_lock_create(struct rjd_lock* lock)
{
	struct rjd_lock_win32* lock_win32 = (struct rjd_lock_win32*)lock;

	DWORD SPIN_COUNT = 0;
	DWORD FLAGS = 0; // TODO maybe use CRITICAL_SECTION_NO_DEBUG_INFO in release?

	lock_win32->owning_thread = RJD_THREAD_ID_INVALID;
	if (InitializeCriticalSectionEx(&lock_win32->cs, SPIN_COUNT, FLAGS)) {
		return RJD_RESULT_OK();
	}

	return RJD_RESULT("Win32 API call failed. Call GetLastError() for more info.");
}

struct rjd_result rjd_lock_destroy(struct rjd_lock* lock)
{
	struct rjd_lock_win32* lock_win32 = (struct rjd_lock_win32*)lock;

	if (!rjd_thread_id_equals(RJD_THREAD_ID_INVALID, lock_win32->owning_thread)) {
		return RJD_RESULT("The lock is still in use by a thread");
	}

	DeleteCriticalSection(&lock_win32->cs);
	return RJD_RESULT_OK();
}

struct rjd_result rjd_lock_acquire(struct rjd_lock* lock)
{
	struct rjd_lock_win32* lock_win32 = (struct rjd_lock_win32*)lock;
	const struct rjd_thread_id current_thread = rjd_thread_id_current();

	// posix mutex is non-reentrant but win32 critical section is. To keep functionality the same,
	// we ensure this CS is non-recursive as well.
	if (rjd_thread_id_equals(lock_win32->owning_thread, current_thread)) {
		return RJD_RESULT("Lock recursion detected.");
	}

	EnterCriticalSection(&lock_win32->cs);
	lock_win32->owning_thread = current_thread;
	return RJD_RESULT_OK();
}

struct rjd_result rjd_lock_try_acquire(struct rjd_lock* lock)
{
	struct rjd_lock_win32* lock_win32 = (struct rjd_lock_win32*)lock;
	const struct rjd_thread_id current_thread = rjd_thread_id_current();

	// posix mutex is non-reentrant but win32 critical section is. To keep functionality the same,
	// we ensure this CS is non-recursive as well.
	if (rjd_thread_id_equals(lock_win32->owning_thread, current_thread)) {
		return RJD_RESULT("Lock recursion detected.");
	}

	if (!TryEnterCriticalSection(&lock_win32->cs)) {
		return RJD_RESULT("Lock in use");
	}
	lock_win32->owning_thread = current_thread;
	return RJD_RESULT_OK();
}

struct rjd_result rjd_lock_release(struct rjd_lock* lock)
{
	struct rjd_lock_win32* lock_win32 = (struct rjd_lock_win32*)lock;
	const struct rjd_thread_id current_thread = rjd_thread_id_current();

	if (!rjd_thread_id_equals(lock_win32->owning_thread, current_thread)) {
		return RJD_RESULT("This thread does not own this lock.");
	}

	lock_win32->owning_thread = RJD_THREAD_ID_INVALID;
	LeaveCriticalSection(&lock_win32->cs);
	return RJD_RESULT_OK();
}

struct rjd_result rjd_rwlock_create(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_win32* lock_win32 = (struct rjd_rwlock_win32*)lock;
	InitializeSRWLock(&lock_win32->lock);
	return RJD_RESULT_OK();
}

struct rjd_result rjd_rwlock_destroy(struct rjd_rwlock* lock)
{
	RJD_UNUSED_PARAM(lock);
	return RJD_RESULT_OK();
}

struct rjd_result rjd_rwlock_acquire_reader(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_win32* lock_win32 = (struct rjd_rwlock_win32*)lock;
	AcquireSRWLockShared(&lock_win32->lock);
	return RJD_RESULT_OK();
}

struct rjd_result rjd_rwlock_acquire_writer(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_win32* lock_win32 = (struct rjd_rwlock_win32*)lock;
	const struct rjd_thread_id current_thread = rjd_thread_id_current();
	AcquireSRWLockExclusive(&lock_win32->lock);
	lock_win32->exclusive_owning_thread = current_thread;
	return RJD_RESULT_OK();
}

struct rjd_result rjd_rwlock_try_acquire_reader(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_win32* lock_win32 = (struct rjd_rwlock_win32*)lock;
	if (!TryAcquireSRWLockShared(&lock_win32->lock)) {
		return RJD_RESULT("Lock in use");
	}
	return RJD_RESULT_OK();
}

struct rjd_result rjd_rwlock_try_acquire_writer(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_win32* lock_win32 = (struct rjd_rwlock_win32*)lock;
	const struct rjd_thread_id current_thread = rjd_thread_id_current();
	if (!TryAcquireSRWLockExclusive(&lock_win32->lock)) {
		return RJD_RESULT("Lock in use");
	}
	lock_win32->exclusive_owning_thread = current_thread;
	return RJD_RESULT_OK();
}

struct rjd_result rjd_rwlock_release_reader(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_win32* lock_win32 = (struct rjd_rwlock_win32*)lock;
	ReleaseSRWLockShared(&lock_win32->lock);
	return RJD_RESULT_OK();
}

struct rjd_result rjd_rwlock_release_writer(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_win32* lock_win32 = (struct rjd_rwlock_win32*)lock;
	const struct rjd_thread_id current_thread = rjd_thread_id_current();

	if (!rjd_thread_id_equals(lock_win32->exclusive_owning_thread, current_thread)) {
		return RJD_RESULT("This thread does not own this lock.");
	}
	lock_win32->exclusive_owning_thread = RJD_THREAD_ID_INVALID;
	ReleaseSRWLockExclusive(&lock_win32->lock);
	return RJD_RESULT_OK();
}

////////////////////////////////////////////////////////////////////////////////
// local helpers

DWORD WINAPI rjd_thread_entrypoint_win32(LPVOID lpParameter)
{
	struct rjd_thread_params params = *(struct rjd_thread_params*)lpParameter;
	rjd_mem_free(lpParameter);

	params.entrypoint_func(params.userdata);
	return 0;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

#elif RJD_PLATFORM_OSX

#include <pthread.h>
#include <unistd.h> // sleep
#include <limits.h> // PTHREAD_STACK_MIN
#include <sys/errno.h>
#include <sys/time.h> // gettimeofday

struct rjd_thread_id_osx
{
	pthread_t handle;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_thread_id_osx) <= sizeof(struct rjd_thread_id));

struct rjd_thread_osx
{
	pthread_t handle;
	void* stack;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_thread_osx) <= sizeof(struct rjd_thread_platform));

struct rjd_thread_params
{
	rjd_thread_entrypoint_func* entrypoint_func;
	void* userdata;
	char name[RJD_THREAD_NAME_MAX_LENGTH];
};

struct rjd_condvar_osx
{
	pthread_cond_t condition_variable;
	struct rjd_lock lock;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_condvar_osx) <= sizeof(struct rjd_condvar));

struct rjd_lock_osx
{
	pthread_mutex_t lock;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_lock_osx) <= sizeof(struct rjd_lock));

struct rjd_rwlock_osx
{
	pthread_rwlock_t lock;
	struct rjd_thread_id exclusive_owning_thread;
	bool is_exclusively_locked;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_rwlock_osx) <= sizeof(struct rjd_rwlock));

RJD_STATIC_ASSERT(RJD_THREAD_STACKSIZE_DEFAULT >= PTHREAD_STACK_MIN);

static inline struct rjd_thread_id rjd_thread_id_from_pthread(pthread_t handle);
static inline struct rjd_thread_osx* rjd_thread_get_osx(struct rjd_thread* thread);
static inline struct rjd_condvar_osx* rjd_condvar_get_osx(struct rjd_condvar* condvar);
static inline struct rjd_lock_osx* rjd_lock_get_osx(struct rjd_lock* lock);
static inline struct rjd_rwlock_osx* rjd_rwlock_get_osx(struct rjd_rwlock* rwlock);

struct rjd_result rjd_error_to_result(int error);
static void* rjd_thread_entrypoint_osx(void* userdata);

////////////////////////////////////////////////////////////////////////////////
// interface implementation

struct rjd_thread_id rjd_thread_id_current(void)
{
	struct rjd_thread_id id = {0};
	struct rjd_thread_id_osx* id_osx = (struct rjd_thread_id_osx*)&id;
	id_osx->handle = pthread_self();
	return id;
}

bool rjd_thread_id_equals(const struct rjd_thread_id a, const struct rjd_thread_id b)
{
	struct rjd_thread_id_osx* a_osx = (struct rjd_thread_id_osx*)&a;
	struct rjd_thread_id_osx* b_osx = (struct rjd_thread_id_osx*)&b;
	return pthread_equal(a_osx->handle, b_osx->handle);
}

struct rjd_result rjd_thread_create(struct rjd_thread* thread, struct rjd_thread_desc desc)
{
	struct rjd_thread_osx* thread_osx = rjd_thread_get_osx(thread);
	thread_osx->stack = NULL;

	if (desc.stacksize == 0) {
		desc.stacksize = RJD_THREAD_STACKSIZE_DEFAULT;
	}

	// pthreads require 4K alignment for stacks
	void* stack = rjd_mem_alloc_array_aligned_noclear(uint8_t, desc.stacksize, desc.allocator, 4 * RJD_KB);
	struct rjd_thread_params* params = rjd_mem_alloc(struct rjd_thread_params, desc.allocator);
	params->entrypoint_func = desc.entrypoint_func;
	params->userdata = desc.userdata;
	params->name[0] = 0;
	if (*desc.optional_name) {
		strncpy(params->name, desc.optional_name, RJD_THREAD_NAME_MAX_LENGTH);
        params->name[rjd_countof(params->name) - 1] = 0;
	}

    pthread_attr_t attributes = {0};
    int error = pthread_attr_init(&attributes);
	struct rjd_result result = rjd_error_to_result(error);

	if (rjd_result_isok(result)) {
		error = pthread_attr_setstack(&attributes, stack, desc.stacksize);
        if (error == EINVAL && desc.stacksize < PTHREAD_STACK_MIN) {
            result = RJD_RESULT("Failed to set the stack. Ensure it is at least as large as PTHREAD_STACK_MIN");
        } else {
            result = rjd_error_to_result(error);
        }
        
		if (rjd_result_isok(result)) {
			// NOTE params ownership is passed to thread
			error = pthread_create(&thread_osx->handle, &attributes, rjd_thread_entrypoint_osx, params);
			result = rjd_error_to_result(error);
			if (rjd_result_isok(result)) {
                thread->id = rjd_thread_id_from_pthread(thread_osx->handle);
				thread_osx->stack = stack;
			}
		}
	}

	if (!rjd_result_isok(result)) {
		rjd_mem_free(params);
		rjd_mem_free(stack);
	}

	return result;
}

struct rjd_result rjd_thread_join(struct rjd_thread* thread)
{
	struct rjd_thread_osx* thread_osx = rjd_thread_get_osx(thread);

	void* unused_return_value = NULL;
    int error = pthread_join(thread_osx->handle, &unused_return_value);

	rjd_mem_free(thread_osx->stack);

	return rjd_error_to_result(error);
}

struct rjd_result rjd_thread_getname(struct rjd_thread* thread, uint32_t destination_max_length, char* out)
{
	struct rjd_thread_osx* thread_osx = rjd_thread_get_osx(thread);

	struct rjd_result result = RJD_RESULT_OK();

	int error = pthread_getname_np(thread_osx->handle, out, destination_max_length);
	if (error == ERANGE) {
		result = RJD_RESULT("Destination buffer too short");
	}

	return result;
}

void rjd_thread_sleep(uint32_t seconds)
{
	sleep(seconds);
}

struct rjd_result rjd_condvar_create(struct rjd_condvar* condvar)
{
	struct rjd_condvar_osx* condvar_osx = rjd_condvar_get_osx(condvar);

	struct rjd_result result = rjd_lock_create(&condvar_osx->lock);
	if (rjd_result_isok(result)) {
		const int error = pthread_cond_init(&condvar_osx->condition_variable, NULL);
		result = rjd_error_to_result(error);
	}

	return result;
}

struct rjd_result rjd_condvar_destroy(struct rjd_condvar* condvar)
{
	struct rjd_condvar_osx* condvar_osx = rjd_condvar_get_osx(condvar);

    struct rjd_result result = rjd_lock_release(&condvar_osx->lock);
    if (rjd_result_isok(result)) {
        result = rjd_lock_destroy(&condvar_osx->lock);
        if (rjd_result_isok(result)) {
            const int error = pthread_cond_destroy(&condvar_osx->condition_variable);
            result = rjd_error_to_result(error);
        }
    }

	return result;
}

struct rjd_result rjd_condvar_lock(struct rjd_condvar* condvar)
{
	struct rjd_condvar_osx* condvar_osx = rjd_condvar_get_osx(condvar);
	return rjd_lock_acquire(&condvar_osx->lock);
}

struct rjd_result rjd_condvar_unlock(struct rjd_condvar* condvar)
{
	struct rjd_condvar_osx* condvar_osx = rjd_condvar_get_osx(condvar);
	return rjd_lock_release(&condvar_osx->lock);
}


struct rjd_result rjd_condvar_signal_single(struct rjd_condvar* condvar)
{
	struct rjd_condvar_osx* condvar_osx = rjd_condvar_get_osx(condvar);

    int error = pthread_cond_signal(&condvar_osx->condition_variable);
    struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_condvar_signal_all(struct rjd_condvar* condvar)
{
	struct rjd_condvar_osx* condvar_osx = rjd_condvar_get_osx(condvar);

    int error = pthread_cond_broadcast(&condvar_osx->condition_variable);
    struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_condvar_wait(struct rjd_condvar* condvar)
{
	struct rjd_condvar_osx* condvar_osx = rjd_condvar_get_osx(condvar);
	struct rjd_lock_osx* lock_osx = rjd_lock_get_osx(&condvar_osx->lock);

	int error = pthread_cond_wait(&condvar_osx->condition_variable, &lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_condvar_wait_timed(struct rjd_condvar* condvar, uint32_t seconds)
{
	struct rjd_condvar_osx* condvar_osx = rjd_condvar_get_osx(condvar);
	struct rjd_lock_osx* lock_osx = rjd_lock_get_osx(&condvar_osx->lock);

	struct timeval timeval = {0};
	gettimeofday(&timeval, NULL);

	struct timespec timespec = {
		.tv_sec = timeval.tv_sec + seconds,
        .tv_nsec = timeval.tv_usec * 1000,
	};
	int error = pthread_cond_timedwait(&condvar_osx->condition_variable, &lock_osx->lock, &timespec);
	struct rjd_result result = rjd_error_to_result(error);
   
	return result;
}

struct rjd_result rjd_lock_create(struct rjd_lock* lock)
{
	struct rjd_lock_osx* lock_osx = rjd_lock_get_osx(lock);

    int error = pthread_mutex_init(&lock_osx->lock, NULL);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_lock_destroy(struct rjd_lock* lock)
{
	struct rjd_lock_osx* lock_osx = rjd_lock_get_osx(lock);
	
	int error = pthread_mutex_destroy(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_lock_acquire(struct rjd_lock* lock)
{
	struct rjd_lock_osx* lock_osx = rjd_lock_get_osx(lock);
	
	int error = pthread_mutex_lock(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_lock_try_acquire(struct rjd_lock* lock)
{
	struct rjd_lock_osx* lock_osx = rjd_lock_get_osx(lock);
	
	int error = pthread_mutex_trylock(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_lock_release(struct rjd_lock* lock)
{
	struct rjd_lock_osx* lock_osx = rjd_lock_get_osx(lock);
	
	int error = pthread_mutex_unlock(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_rwlock_create(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_osx* lock_osx = rjd_rwlock_get_osx(lock);
	
	int error = pthread_rwlock_init(&lock_osx->lock, NULL);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_rwlock_destroy(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_osx* lock_osx = rjd_rwlock_get_osx(lock);
	
	int error = pthread_rwlock_destroy(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_rwlock_acquire_reader(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_osx* lock_osx = rjd_rwlock_get_osx(lock);
	
	int error = pthread_rwlock_rdlock(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_rwlock_acquire_writer(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_osx* lock_osx = rjd_rwlock_get_osx(lock);
	
	int error = pthread_rwlock_wrlock(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	if (rjd_result_isok(result)) {
		lock_osx->is_exclusively_locked = true;
		lock_osx->exclusive_owning_thread = rjd_thread_id_current();
	}
	return result;
}

struct rjd_result rjd_rwlock_try_acquire_reader(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_osx* lock_osx = rjd_rwlock_get_osx(lock);
	
	int error = pthread_rwlock_tryrdlock(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_rwlock_try_acquire_writer(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_osx* lock_osx = rjd_rwlock_get_osx(lock);
	
	int error = pthread_rwlock_trywrlock(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	if (rjd_result_isok(result)) {
		lock_osx->is_exclusively_locked = true;
		lock_osx->exclusive_owning_thread = rjd_thread_id_current();
	}
	return result;
}

struct rjd_result rjd_rwlock_release_reader(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_osx* lock_osx = rjd_rwlock_get_osx(lock);

    if (lock_osx->is_exclusively_locked) {
        const struct rjd_thread_id current_thread = rjd_thread_id_current();
        if (rjd_thread_id_equals(current_thread, lock_osx->exclusive_owning_thread)) {
			return RJD_RESULT("This is under a writer lock. Release via writer instead.");
		} else {
            return RJD_RESULT("This thread does not own this lock");
        }
    }
    
	int error = pthread_rwlock_unlock(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

struct rjd_result rjd_rwlock_release_writer(struct rjd_rwlock* lock)
{
	struct rjd_rwlock_osx* lock_osx = rjd_rwlock_get_osx(lock);
	if (lock_osx->is_exclusively_locked) {
		const struct rjd_thread_id current_thread = rjd_thread_id_current();
		if (!rjd_thread_id_equals(current_thread, lock_osx->exclusive_owning_thread)) {
			return RJD_RESULT("This thread does not own this lock");
		}
	}
    
    lock_osx->is_exclusively_locked = false;
	
	int error = pthread_rwlock_unlock(&lock_osx->lock);
	struct rjd_result result = rjd_error_to_result(error);
	return result;
}

////////////////////////////////////////////////////////////////////////////////
// Local helper implementation

static inline struct rjd_thread_id rjd_thread_id_from_pthread(pthread_t handle)
{
    struct rjd_thread_id thread_id = {0};
    struct rjd_thread_id_osx* id_osx = (struct rjd_thread_id_osx*)&thread_id;
    id_osx->handle = handle;
    return thread_id;
}
                  
static inline struct rjd_thread_osx* rjd_thread_get_osx(struct rjd_thread* thread)
{
	RJD_ASSERT(thread);
	return (struct rjd_thread_osx*)&thread->platform;
}

static inline struct rjd_condvar_osx* rjd_condvar_get_osx(struct rjd_condvar* condvar)
{
	RJD_ASSERT(condvar);
	return (struct rjd_condvar_osx*)condvar;
}

static inline struct rjd_lock_osx* rjd_lock_get_osx(struct rjd_lock* lock)
{
	RJD_ASSERT(lock);
	return (struct rjd_lock_osx*)lock;
}

static inline struct rjd_rwlock_osx* rjd_rwlock_get_osx(struct rjd_rwlock* rwlock)
{
	RJD_ASSERT(rwlock);
	return (struct rjd_rwlock_osx*)rwlock;
}

struct rjd_result rjd_error_to_result(int error)
{
	switch (error)
	{
		case 0:			return RJD_RESULT_OK();
		case EAGAIN:	return RJD_RESULT("Not enough system resources to create this object or system capacity is already at maximum. Try again later.");
		case EBUSY:		return RJD_RESULT("Unable to perform operation without blocking. If the object is a lock, the thread may already be holding it.");
		case EDEADLK:	return RJD_RESULT("Deadlock detected.");
		case EINVAL:	return RJD_RESULT("Invalid object.");
		case ENOMEM:	return RJD_RESULT("Not enough system memory available.");
		case EPERM: 	return RJD_RESULT("This operation requires higher permissions.");
		case ESRCH:		return RJD_RESULT("Object not found.");
		case ETIMEDOUT:	return RJD_RESULT("Timed out");
	}
	
	return RJD_RESULT("Unknown error");
}

static void* rjd_thread_entrypoint_osx(void* params_untyped)
{
	struct rjd_thread_params params = *(struct rjd_thread_params*)params_untyped;
	rjd_mem_free(params_untyped);

	if (*params.name) {
		pthread_setname_np(params.name);
	}
	params.entrypoint_func(params.userdata);
	return NULL;
}

#endif

#endif

////////////////////////////////////////////////////////////////////////////////
// rjd_strpool.h
////////////////////////////////////////////////////////////////////////////////

#pragma once
#define RJD_STRPOOL_H 1

struct rjd_strpool
{
	struct rjd_dict storage;
};

struct rjd_strref;

struct rjd_strpool rjd_strpool_init(struct rjd_mem_allocator* allocator, size_t initial_capacity);
void rjd_strpool_free(struct rjd_strpool* pool);
struct rjd_strref* rjd_strpool_add(struct rjd_strpool* pool, const char* str);
struct rjd_strref* rjd_strpool_addf(struct rjd_strpool* pool, const char* fmt, ...);
struct rjd_strref* rjd_strpool_addv(struct rjd_strpool* pool, const char* fmt, va_list args); 
struct rjd_strref* rjd_strpool_addl(struct rjd_strpool* pool, const char* inline_string, size_t length); // for non-null-terminated strings
void rjd_strref_release(struct rjd_strref* ref);
const char* rjd_strref_str(const struct rjd_strref* ref);
uint32_t rjd_strref_length(const struct rjd_strref* ref);

#if RJD_IMPL

struct rjd_strref
{
	const char* str;
	struct rjd_strpool* owner;
	int32_t refcount; // TODO atomic
	uint32_t length;
};

static struct rjd_strref* rjd_strpool_addimpl(struct rjd_strpool* pool, const char* str);

struct rjd_strpool rjd_strpool_init(struct rjd_mem_allocator* allocator, size_t initial_capacity)
{
	RJD_ASSERT(allocator);

	struct rjd_strpool pool = { rjd_dict_init(allocator, initial_capacity * 2) };
	return pool;
}

void rjd_strpool_free(struct rjd_strpool* pool)
{
	RJD_ASSERT(pool);

	void** refs = pool->storage.values;
	for (uint32_t i = 0; i < rjd_array_count(refs); ++i) {
		if (refs[i]) {
			struct rjd_strref* ref = refs[i];
			rjd_mem_free(ref); // struct and string are part of the same allocation block
		}
	}
	rjd_dict_free(&pool->storage);
}

struct rjd_strref* rjd_strpool_add(struct rjd_strpool* pool, const char* str)
{
	RJD_ASSERT(pool);

	return rjd_strpool_addimpl(pool, str);
}

struct rjd_strref* rjd_strpool_addf(struct rjd_strpool* pool, const char* format, ...)
{
	RJD_ASSERT(pool);
	RJD_ASSERT(format);

	struct rjd_strref* ref = NULL;

	va_list args;
	va_start(args, format);
		ref = rjd_strpool_addv(pool, format, args);
	va_end(args);

	return ref;
}

struct rjd_strref* rjd_strpool_addv(struct rjd_strpool* pool, const char* format, va_list args)
{
	RJD_ASSERT(pool);
	RJD_ASSERT(format);

	struct rjd_strref* ref = NULL;

	RJD_STRBUF_SCOPED(buffer, pool->storage.allocator, {
		rjd_strbuf_appendv(&buffer, format, args);
		ref = rjd_strpool_addimpl(pool, rjd_strbuf_str(&buffer));
	});

	return ref;
}

struct rjd_strref* rjd_strpool_addl(struct rjd_strpool* pool, const char* inline_string, size_t length)
{
	RJD_ASSERT(pool);
	RJD_ASSERT(inline_string);

	struct rjd_strref* ref = NULL;

	RJD_STRBUF_SCOPED(buffer, pool->storage.allocator, {
		rjd_strbuf_appendl(&buffer, inline_string, (uint32_t)length);
		ref = rjd_strpool_addimpl(pool, rjd_strbuf_str(&buffer));
	});

	return ref;
}

void rjd_strref_release(struct rjd_strref* ref)
{
	RJD_ASSERT(ref);

	struct rjd_strpool* pool = ref->owner;

	struct rjd_hash64 hash = rjd_hash64_data((const uint8_t*)ref->str, -1);
	RJD_ASSERTMSG(rjd_dict_get(&pool->storage, hash) == ref, "ref was not contained in string pool");

	--ref->refcount;
	if (ref->refcount <= 0) {
		rjd_mem_free(ref); // struct and string are part of the same allocation block
		rjd_dict_erase(&pool->storage, hash);
	}
}

const char* rjd_strref_str(const struct rjd_strref* ref)
{
	RJD_ASSERT(ref);
	return ref->str;
}

uint32_t rjd_strref_length(const struct rjd_strref* ref)
{
	RJD_ASSERT(ref);
	return ref->length;
}

static struct rjd_strref* rjd_strpool_addimpl(struct rjd_strpool* pool, const char* str) 
{
	RJD_ASSERT(pool);

	if (!str) {
		return NULL;
	}

	struct rjd_hash64 hash = rjd_hash64_data((const uint8_t*)str, -1);
	struct rjd_strref* ref = rjd_dict_get(&pool->storage, hash);
	if (!ref) {
		uint8_t* mem = rjd_mem_alloc_array(uint8_t, sizeof(struct rjd_strref) + strlen(str) + 1, pool->storage.allocator);
		ref = (struct rjd_strref*)mem;

		char* copied_str = (char*)(mem + sizeof(struct rjd_strref));
		strcpy(copied_str, str);

		ref->str = copied_str;
		ref->owner = pool;
		ref->refcount = 0;
		ref->length = (uint32_t)strlen(ref->str);

		rjd_dict_insert(&pool->storage, hash, ref);
	}
	++ref->refcount;

	return ref;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_slotmap.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_SLOTMAP_H 1

struct rjd_slot
{
	uint16_t index;
	uint16_t salt;
};

static inline bool rjd_slot_isvalid(struct rjd_slot slot);
static inline void rjd_slot_invalidate(struct rjd_slot* slot);

#define rjd_slotmap_alloc(type, capacity, allocator)	(rjd_slotmap_alloc_impl(sizeof(type), capacity, allocator))
#define rjd_slotmap_insert(map, data, out_slot)		    (rjd_slotmap_insert_impl((void**)(&map), (out_slot)), \
													        (map)[(out_slot)->index] = data)
#define rjd_slotmap_contains(map, slot)				    (rjd_slotmap_contains_impl((map), (slot)))
#define rjd_slotmap_get(map, slot)				    	((map) + rjd_slotmap_get_impl((map), (slot)))
#define rjd_slotmap_count(map)					    	(rjd_slotmap_count_impl(map))
#define rjd_slotmap_erase(map, slot)			    	(rjd_slotmap_erase_impl((map), slot))
#define rjd_slotmap_free(map)					    	(rjd_slotmap_free_impl(map))
#define rjd_slotmap_next(map, slot)				    	(rjd_slotmap_next_impl((map), (slot))) // pass null slot for first

void* rjd_slotmap_alloc_impl(size_t sizeof_type, uint32_t capacity, struct rjd_mem_allocator* allocator);
void rjd_slotmap_insert_impl(void** map_p, struct rjd_slot* out_slot);
bool rjd_slotmap_contains_impl(const void* map, struct rjd_slot slot);
uint32_t rjd_slotmap_get_impl(const void* map, struct rjd_slot slot);
uint32_t rjd_slotmap_count_impl(const void* map);
void rjd_slotmap_erase_impl(void* map, struct rjd_slot slot);
void rjd_slotmap_free_impl(void* map);
struct rjd_slot rjd_slotmap_next_impl(void* map, const struct rjd_slot* slot);

static inline bool rjd_slot_isvalid(struct rjd_slot slot)
{
	return slot.salt != 0;
}

static inline void rjd_slot_invalidate(struct rjd_slot* slot)
{
	RJD_ASSERT(slot);
	slot->salt = 0;
}

#if RJD_IMPL

////////////////////////////////////////////////////////////////////////////////
// private interface

struct rjd_slotmap_header
{
	struct rjd_mem_allocator* allocator;
	void* data;
	uint16_t* salts;
	bool* used;
	uint32_t* freelist;
	uint32_t sizeof_type;
    uint32_t capacity;
	uint32_t count;
	uint32_t debug_sentinel;
};

enum {
	RJD_SLOTMAP_DEBUG_SENTINEL = 0x5A5A5A5A,
};

static struct rjd_slotmap_header* rjd_slotmap_getheader(const void* map);
static void* rjd_slotmap_grow(void* oldmap, size_t sizeof_type, uint32_t capacity, struct rjd_mem_allocator* allocator);

////////////////////////////////////////////////////////////////////////////////
// public implementation

void* rjd_slotmap_alloc_impl(size_t sizeof_type, uint32_t capacity, struct rjd_mem_allocator* allocator)
{
	return rjd_slotmap_grow(NULL, sizeof_type, capacity, allocator);
}

void rjd_slotmap_insert_impl(void** map_p, struct rjd_slot* out_slot)
{
	RJD_ASSERT(map_p);
	RJD_ASSERT(*map_p);
	RJD_ASSERT(out_slot);

	void* map = *map_p;

	struct rjd_slotmap_header* header = rjd_slotmap_getheader(map);

	if (rjd_array_count(header->freelist) == 0) {
		map = rjd_slotmap_grow(map, header->sizeof_type, header->capacity * 2, header->allocator);
		header = rjd_slotmap_getheader(map);
		RJD_ASSERT(rjd_array_count(header->freelist) > 0);
		*map_p = map;
	}

	uint32_t index = rjd_array_pop(header->freelist);

	uint16_t* salt = header->salts + index;
	*salt += 1;

	header->used[index] = true;
    ++header->count;

	out_slot->index = rjd_math_truncate_u32_to_u16(index);
	out_slot->salt = *salt;
}

bool rjd_slotmap_contains_impl(const void* map, struct rjd_slot slot)
{
	RJD_ASSERT(map);

	const struct rjd_slotmap_header* header = rjd_slotmap_getheader(map);
	if (slot.index >= header->capacity) {
		return false;
	}
	uint32_t index = slot.index;
	return !rjd_array_contains(header->freelist, &index);
}

uint32_t rjd_slotmap_get_impl(const void* map, struct rjd_slot slot)
{
	RJD_ASSERT(map);

	const struct rjd_slotmap_header* header = rjd_slotmap_getheader(map);
	RJD_ASSERT(slot.index < header->capacity);
	uint32_t index = slot.index;
	RJD_ASSERTMSG(!rjd_array_contains(header->freelist, &index), "This slot is unallocated. Use rjd_slotmap_contains to check if the slot is valid first.");
    int16_t salt = header->salts[slot.index];
	RJD_ASSERT(salt == slot.salt);
	return slot.index;
}

uint32_t rjd_slotmap_count_impl(const void* map)
{
	RJD_ASSERT(map);

	const struct rjd_slotmap_header* header = rjd_slotmap_getheader(map);
	return header->count;
}

void rjd_slotmap_erase_impl(void* map, struct rjd_slot slot)
{
	RJD_ASSERT(map);
	struct rjd_slotmap_header* header = rjd_slotmap_getheader(map);
	RJD_ASSERT(slot.index < header->capacity);
	
	rjd_array_push(header->freelist, slot.index);
	header->used[slot.index] = false;
    --header->count;
}

void rjd_slotmap_free_impl(void* map)
{
	RJD_ASSERT(map);
	struct rjd_slotmap_header* header = rjd_slotmap_getheader(map);

    rjd_array_free(header->used);
	rjd_array_free(header->freelist);
	rjd_mem_free(header);
}

struct rjd_slot rjd_slotmap_next_impl(void* map, const struct rjd_slot* slot)
{
	RJD_ASSERT(map);
	struct rjd_slotmap_header* header = rjd_slotmap_getheader(map);

	uint32_t start = 0;
	if (slot) {
		start = slot->index + 1;
	}

	for (uint32_t i = start; i < header->capacity; ++i) {
		if (header->used[i]) {
			struct rjd_slot next = {
				.index = rjd_math_truncate_u32_to_u16(i),
				.salt = header->salts[i],
			};
			return next;
		}
	}

	struct rjd_slot next = {0};
	RJD_ASSERT(!rjd_slot_isvalid(next));
	return next;
}

////////////////////////////////////////////////////////////////////////////////
// private implementation

struct rjd_slotmap_header* rjd_slotmap_getheader(const void* map)
{
	char* raw = (char*)map;
	char* rawheader = (raw - sizeof(struct rjd_slotmap_header));
	struct rjd_slotmap_header* header = (struct rjd_slotmap_header*)rawheader;
	RJD_ASSERTMSG(header->debug_sentinel == RJD_SLOTMAP_DEBUG_SENTINEL, 
		"Debug sentinel does not match. Address %p does not point to a slotmap or there was a buffer underrun corruption.", map);
	return header;
}

void* rjd_slotmap_grow(void* oldmap, size_t sizeof_type, uint32_t capacity, struct rjd_mem_allocator* allocator)
{
	struct rjd_slotmap_header* oldheader = oldmap ? rjd_slotmap_getheader(oldmap) : NULL;

	uint32_t oldcapacity = oldheader ? oldheader->capacity : 0;
	if (capacity <= oldcapacity) {
		return oldmap;
	}

	size_t total_mem_size = sizeof(struct rjd_slotmap_header) + sizeof_type * capacity + sizeof(uint16_t) * capacity;
	char* mem = rjd_mem_alloc_array(char, total_mem_size, allocator);
	memset(mem, 0, total_mem_size);

	struct rjd_slotmap_header* header = (struct rjd_slotmap_header*)mem;
	header->allocator = allocator;
	header->sizeof_type = (uint32_t)sizeof_type;
	header->capacity = capacity;
    header->count = 0;
	header->data = (void*)(mem + sizeof(struct rjd_slotmap_header));
	header->salts = (uint16_t*)((char*)header->data + sizeof_type * capacity);
	header->used = rjd_array_alloc(bool, capacity, allocator);
	header->freelist = rjd_array_alloc(uint32_t, capacity, allocator);
	header->debug_sentinel = RJD_SLOTMAP_DEBUG_SENTINEL;

	memset(header->salts + oldcapacity, 0, (header->capacity - oldcapacity) * sizeof(*header->salts));

	rjd_array_resize(header->used, capacity);
	if (oldheader) {
		memcpy(header->used, oldheader->used, sizeof(*header->used) * oldheader->capacity);
        header->count = oldheader->count;
	}

	for (uint32_t i = oldcapacity; i < capacity; ++i) {
		rjd_array_push(header->freelist, i);
	}

	// copy existing data
	if (oldheader) {
		memcpy(header->data, oldheader->data, sizeof_type * oldheader->capacity);
		memcpy(header->salts, oldheader->salts, sizeof(uint16_t) * oldheader->capacity);
		rjd_slotmap_free(oldmap);
	}

	return header->data;
}

#endif


////////////////////////////////////////////////////////////////////////////////
// rjd_utf8.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_UTF8_H 1

const char* rjd_utf8_bom_skip(const char* string); // expects a NULL-terminated string
struct rjd_result rjd_utf8_bom_write(char* buffer, size_t size);
const char* rjd_utf8_next(const char* string); // returns NULL if string is not UTF8-encoded

#if RJD_IMPL

const char* rjd_utf8_bom_skip(const char* string)
{
	const uint8_t* s = (const uint8_t*)string;
	if (s != NULL &&
		*(s + 0) == 0xEF &&
		*(s + 1) == 0xBB &&
		*(s + 2) == 0xBF)
	{
		return string + 3;
	}
	return string;
}

struct rjd_result rjd_utf8_bom_write(char* buffer, size_t size)
{
	if (size <= 3) {
		return RJD_RESULT("Buffer must be at least 3 characters long.");
	}

	uint8_t* aliased = (uint8_t*)buffer;

	*(aliased + 0) = 0xEF;
	*(aliased + 1) = 0xBB;
	*(aliased + 2) = 0xBF;

	return RJD_RESULT_OK();
}

const char* rjd_utf8_next(const char* string)
{
	if (string == NULL || *string == '\0') {
		return string;
	}

	uint8_t byte = (uint8_t)*string;

    if ((byte >> 7) == 0x00) {
        return string + 1;
    } else if ((byte >> 5) == 0x06) { // 0b110
        return string + 2;
    } else if ((byte >> 4) == 0x0E) { // 0b1110
        return string + 3;
    } else if ((byte >> 3) == 0x1E) { //0b11110
        return string + 4;
    }

	// if we're in the middle of a character, skip to the end of the current character
    bool is_mid_character = (byte >> 6) == 0x02; // 0b10
	if (is_mid_character) {
		while (is_mid_character) {
			++string;
			byte = *string;
			if (byte == '\0') {
				break;
			}
            is_mid_character = (byte >> 6) == 0x02; //0b10
		}
		return string;
	}

	return NULL; // invalid UTF8 string
}

#endif


////////////////////////////////////////////////////////////////////////////////
// rjd_path.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_PATH_H 1

#ifndef RJD_PATH_BUFFER_LENGTH
	#define RJD_PATH_BUFFER_LENGTH 256
#endif

struct rjd_path
{
	uint32_t length;
	char str[RJD_PATH_BUFFER_LENGTH];
};

struct rjd_path_enumerator_state
{
	char impl[40];
};

enum RJD_PATH_ENUMERATE_MODE
{
	RJD_PATH_ENUMERATE_MODE_RECURSIVE,
	RJD_PATH_ENUMERATE_MODE_FLAT,
};

struct rjd_path rjd_path_create(void);
struct rjd_path rjd_path_create_with(const char* path);
void rjd_path_append(struct rjd_path* path, const char* str);
void rjd_path_join(struct rjd_path* path1, const struct rjd_path* path2);
const char* rjd_path_get(struct rjd_path* path);
void rjd_path_clear(struct rjd_path* path);
const char* rjd_path_extension(const struct rjd_path* path);
const char* rjd_path_extension_str(const char* path);

struct rjd_path_enumerator_state rjd_path_enumerate_create(const char* path, struct rjd_mem_allocator* allocator, enum RJD_PATH_ENUMERATE_MODE mode);
const char* rjd_path_enumerate_next(struct rjd_path_enumerator_state* state);
void rjd_path_enumerate_destroy(struct rjd_path_enumerator_state* state);

#if RJD_IMPL

#if RJD_PLATFORM_WINDOWS
	#define RJD_PATH_SLASH ('/')
#elif RJD_PLATFORM_OSX
	#define RJD_PATH_SLASH ('/')
#else
	#error "Unknown platform"
#endif

static uint32_t rjd_path_normalize_slashes(char* path, uint32_t length);

struct rjd_path rjd_path_create()
{
	struct rjd_path path = {0};
	return path;
}

struct rjd_path rjd_path_create_with(const char* initial_contents)
{
	struct rjd_path path;
	path.length = (uint32_t)strlen(initial_contents);
	RJD_ASSERTMSG(path.length < RJD_PATH_BUFFER_LENGTH, 
				"The static size of RJD_PATH_BUFFER_LENGTH (%u) is smaller than the passed string (%u).",
				RJD_PATH_BUFFER_LENGTH, path.length);

	strncpy(path.str, initial_contents, path.length);
	path.str[path.length] = 0;
	path.length = rjd_path_normalize_slashes(path.str, path.length);
	return path;
}

void rjd_path_append(struct rjd_path* path, const char* str)
{
    const char slash = RJD_PATH_SLASH;
    
	uint32_t start = path->length;
	uint32_t max_length = RJD_PATH_BUFFER_LENGTH - 1;
	if (start > 0 && start < max_length && path->str[start - 1] != slash && str[0] != slash) {
		path->str[start] = slash;
		++start;
		++path->length;
	}

	size_t append_length = strlen(str);
	size_t new_length = append_length + path->length;
	RJD_ASSERTMSG(new_length < RJD_PATH_BUFFER_LENGTH, 
				"The static size of RJD_PATH_BUFFER_LENGTH (%u) is smaller than the concatenated length (%u).",
				RJD_PATH_BUFFER_LENGTH, new_length);
	strncpy(path->str + path->length, str, append_length);
	path->str[new_length] = 0;
	path->length = rjd_path_normalize_slashes(path->str, (uint32_t)new_length);
}

void rjd_path_join(struct rjd_path* path1, const struct rjd_path* path2)
{
	rjd_path_append(path1, path2->str);
}

const char* rjd_path_get(struct rjd_path* path)
{
	return path->str;
}

const char* rjd_path_extension(const struct rjd_path* path)
{
	return rjd_path_extension_str(path->str);
}

const char* rjd_path_extension_str(const char* path)
{
    if (!path || !*path) {
        return NULL;
    }

	const char* extension = strrchr(path, '.');
	if (!extension) {
		return NULL;
	}

	// If a path ends with a period, it doesn't have an extension
	if (extension[1] == '\0') {
		return NULL;
	}

	return extension;
}

void rjd_path_clear(struct rjd_path* path)
{
	RJD_ASSERT(path);
	path->str[0] = '\0';
}

// local helpers
static uint32_t rjd_path_normalize_slashes(char* path, uint32_t length)
{
    if (length == 0) {
        return length;
    }

    for (int32_t i = length - 1; i > 0 && path[i] == RJD_PATH_SLASH; --i) {
		path[i] = '\0';
        --length;
	}

	char* end = path + length;
	for (char* start = end - 1; start > path; --start)
	{
		while (*start != RJD_PATH_SLASH && start > path) {
			--start;
		}

		char* slot = start;
        while (slot > path && *(slot - 1) == RJD_PATH_SLASH) {
            --slot;
        }

        if (start - slot > 0) {
            uint32_t sublength = (uint32_t)(end - start);
			memmove(slot, start, sublength + 1);
            
            uint32_t trimmed_size = (uint32_t)(start - slot);
            end -= trimmed_size;
		}
		start = slot;
	}

    size_t newlength = end - path;
    RJD_ASSERT(newlength == strlen(path));
    return (uint32_t)(end - path);
}

#if RJD_PLATFORM_WINDOWS

#include <wchar.h>
#include <shellapi.h>
#include <limits.h> // INT_MAX

struct rjd_path_enumerator_state_win32
{
	struct rjd_mem_allocator* allocator;
	char* nextpath;
	wchar_t** root_dirs;
	HANDLE handle;
	bool is_recursive;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_path_enumerator_state_win32) <= sizeof(struct rjd_path_enumerator_state));

struct rjd_path_enumerator_state rjd_path_enumerate_create(const char* path, struct rjd_mem_allocator* allocator, enum RJD_PATH_ENUMERATE_MODE mode)
{
	RJD_ASSERT(path);
	RJD_ASSERT(allocator);

	struct rjd_path_enumerator_state state = {0};
	struct rjd_path_enumerator_state_win32* state_win32 = (struct rjd_path_enumerator_state_win32*)&state;
	state_win32->allocator = allocator;
	state_win32->nextpath = NULL;
	state_win32->root_dirs = rjd_array_alloc(wchar_t*, 16, allocator);
	state_win32->handle = INVALID_HANDLE_VALUE;
	state_win32->is_recursive = (RJD_PATH_ENUMERATE_MODE_RECURSIVE == mode);

	wchar_t* path_wide = NULL;
	{
		const size_t path_length = mbstowcs(NULL, path, INT_MAX);
		path_wide = rjd_mem_alloc_array_noclear(wchar_t, path_length + 1, allocator);
		mbstowcs(path_wide, path, INT_MAX);
	}
	rjd_array_push(state_win32->root_dirs, path_wide);

	return state;
}

static wchar_t* rjd_path_enumerate_concat_paths(const wchar_t* a, const wchar_t* b, struct rjd_mem_allocator* allocator)
{
	const wchar_t path_separator[] = L"/";

	size_t length_a = wcslen(a);
	size_t length_b = wcslen(b);
	size_t length_separator = wcslen(path_separator);

	size_t length_total = length_a + length_separator + length_b;

	wchar_t* concat = rjd_mem_alloc_array_noclear(wchar_t, length_total + 1, allocator);
	wcscpy(concat, a);
	wcscpy(concat + length_a, path_separator);
	wcscpy(concat + length_a + length_separator, b);
	return concat;
}

const char* rjd_path_enumerate_next(struct rjd_path_enumerator_state* state)
{
	RJD_ASSERT(state);

	struct rjd_path_enumerator_state_win32* state_win32 = (struct rjd_path_enumerator_state_win32*)state;

	if (state_win32->nextpath) {
		rjd_mem_free(state_win32->nextpath);
		state_win32->nextpath = NULL;
	}

	WIN32_FIND_DATAW find_data = {0};
	while (!*find_data.cFileName && rjd_array_count(state_win32->root_dirs) > 0) {

		if (state_win32->handle == INVALID_HANDLE_VALUE) {
			wchar_t* root_with_search_spec = rjd_path_enumerate_concat_paths(state_win32->root_dirs[0], L"*", state_win32->allocator);
			state_win32->handle = FindFirstFileW(root_with_search_spec, &find_data);
			rjd_mem_free(root_with_search_spec);

			if (state_win32->handle == INVALID_HANDLE_VALUE) {
				find_data.cFileName[0] = '\0';
				rjd_mem_free(state_win32->root_dirs[0]);
				rjd_array_erase_unordered(state_win32->root_dirs, 0);
			}
		}

		if (state_win32->handle != INVALID_HANDLE_VALUE) {
			bool success = true;
			if (!*find_data.cFileName) {
				success = FindNextFileW(state_win32->handle, &find_data);
			}

			while (success && (!wcscmp(find_data.cFileName, L".") || !wcscmp(find_data.cFileName, L".."))) {
				success = FindNextFileW(state_win32->handle, &find_data);
			}

			if (!success) {
				find_data.cFileName[0] = '\0';
				state_win32->handle = INVALID_HANDLE_VALUE;
				rjd_mem_free(state_win32->root_dirs[0]);
				rjd_array_erase_unordered(state_win32->root_dirs, 0);
			}
		}

		if (*find_data.cFileName && state_win32->is_recursive) {
			if (find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
				wchar_t* new_root = rjd_path_enumerate_concat_paths(state_win32->root_dirs[0], find_data.cFileName, state_win32->allocator);
				rjd_array_push(state_win32->root_dirs, new_root);
			}
		}
	}

	if (*find_data.cFileName)
	{
		wchar_t* path = rjd_path_enumerate_concat_paths(state_win32->root_dirs[0], find_data.cFileName, state_win32->allocator);

		const size_t path_length = wcstombs(NULL, path, INT_MAX);
		state_win32->nextpath = rjd_mem_alloc_array_noclear(char, path_length + 1, state_win32->allocator);
		wcstombs(state_win32->nextpath, path, INT_MAX);

		rjd_mem_free(path);
	}

	return state_win32->nextpath;
}

void rjd_path_enumerate_destroy(struct rjd_path_enumerator_state* state)
{
	RJD_ASSERT(state);

	struct rjd_path_enumerator_state_win32* state_win32 = (struct rjd_path_enumerator_state_win32*)state;

	for (uint32_t i = 0; i < rjd_array_count(state_win32->root_dirs); ++i) {
		rjd_mem_free(state_win32->root_dirs + i);
	}
	rjd_array_free(state_win32->root_dirs);
	rjd_mem_free(state_win32->nextpath);

	FindClose(state_win32->handle);
}

#elif RJD_PLATFORM_OSX

#if !RJD_LANG_OBJC
	#error "rjd_path implementation on OSX uses Objective-C interfaces. You must #include this file in a .m file."
#endif

#import <Foundation/Foundation.h>

struct rjd_path_enumerator_state_osx
{
	NSDirectoryEnumerator<NSString*>* enumerator;
	struct rjd_mem_allocator* allocator;
    const char* root;
	const char* next;
	bool no_recursion;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_path_enumerator_state_osx) <= sizeof(struct rjd_path_enumerator_state));

struct rjd_path_enumerator_state rjd_path_enumerate_create(const char* path, struct rjd_mem_allocator* allocator, enum RJD_PATH_ENUMERATE_MODE mode)
{
	RJD_ASSERT(path);
	RJD_ASSERT(allocator);

	NSFileManager* manager = [NSFileManager defaultManager];
	NSString* startingPath = [NSString stringWithUTF8String:path];

	char* path_copy = NULL;
	{
		size_t len = strlen(path);
		path_copy = rjd_mem_alloc_array_noclear(char, len + 1, allocator);
		strcpy(path_copy, path);
	}

	// NSFileManager:enumeratorAtPath is threadsafe
	NSDirectoryEnumerator<NSString*>* enumerator = [manager enumeratorAtPath:startingPath];

	struct rjd_path_enumerator_state state = {0};
	struct rjd_path_enumerator_state_osx* state_osx = (struct rjd_path_enumerator_state_osx*)&state;
	state_osx->enumerator = enumerator;
	state_osx->allocator = allocator;
	state_osx->root = path_copy;
	state_osx->next = NULL;
	state_osx->no_recursion = (mode == RJD_PATH_ENUMERATE_MODE_FLAT);

	return state;
}

const char* rjd_path_enumerate_next(struct rjd_path_enumerator_state* state)
{
	RJD_ASSERT(state);
	struct rjd_path_enumerator_state_osx* state_osx = (struct rjd_path_enumerator_state_osx*)state;

	rjd_mem_free(state_osx->next);
	state_osx->next = NULL;

	if (state_osx->no_recursion) {
		[state_osx->enumerator skipDescendants];
	}

	NSString* next = (NSString*) [state_osx->enumerator nextObject];
	if (next) {
		const char* relative = next.UTF8String;
		const char path_separator[] = "/";

		size_t length_root = strlen(state_osx->root);
		size_t length_relative = strlen(relative);
		size_t length_separator = strlen(path_separator);

		size_t length_total = length_root + length_separator + length_relative;

		char* next_path = rjd_mem_alloc_array_noclear(char, length_total + 1, state_osx->allocator);
		strcpy(next_path, state_osx->root);
		strcpy(next_path + length_root, path_separator);
		strcpy(next_path + length_root + length_separator, relative);
        state_osx->next = next_path;
	}

	return state_osx->next;
}

void rjd_path_enumerate_destroy(struct rjd_path_enumerator_state* state)
{
	RJD_ASSERT(state);

	struct rjd_path_enumerator_state_osx* state_osx = (struct rjd_path_enumerator_state_osx*)state;
	state_osx->enumerator = nil;
	
    rjd_mem_free(state_osx->root);
    rjd_mem_free(state_osx->next);
}

#endif // RJD_PLATFORM_OSX && RJD_LANG_OBJC
#endif // RJD_IMPL

////////////////////////////////////////////////////////////////////////////////
// rjd_stream.h
////////////////////////////////////////////////////////////////////////////////

#define RJD_STREAM_H 1

// rjd_istream API design based on Fabien Giesen's Buffer-Centric IO:
// https://fgiesen.wordpress.com/2011/11/21/buffer-centric-io/

struct rjd_istream;

typedef struct rjd_result rjd_istream_refill_func(struct rjd_istream* stream);
typedef void rjd_istream_close_func(struct rjd_istream* stream);

struct rjd_istream
{
	const uint8_t* start;
	const uint8_t* end;
	const uint8_t* cursor;
	void* userdata;
	struct rjd_result result;
	rjd_istream_refill_func* refill;
	rjd_istream_close_func* close;
};

// Pass this as buffer_size in rjd_istream_from_file to read the entire file into memory
enum
{
	RJD_ISTREAM_FILE_BUFFER_SIZE_ALL = 0,
};

enum rjd_ostream_type
{
	RJD_OSTREAM_TYPE_MEMORY,
	RJD_OSTREAM_TYPE_FILE,
};

struct rjd_ostream_memory
{
	uint8_t* buffer;
	uint32_t size;
	uint64_t cursor;
};

struct rjd_ostream_file
{
	FILE* file;
};

struct rjd_ostream
{
	enum rjd_ostream_type type;
	union {
		struct rjd_ostream_memory memory;
		struct rjd_ostream_file file;
	} state;
};

enum rjd_ostream_mode
{
	RJD_OSTREAM_MODE_REPLACE,
	RJD_OSTREAM_MODE_APPEND,
};

struct rjd_mem_allocator;

struct rjd_istream rjd_istream_from_zeroes(void);
struct rjd_istream rjd_istream_from_memory(const void* buffer, size_t size);
struct rjd_istream rjd_istream_from_file(const char* filepath, struct rjd_mem_allocator* allocator, size_t buffer_size);
struct rjd_result rjd_istream_read(struct rjd_istream* stream, void* buffer, size_t size); 
void rjd_istream_close(struct rjd_istream* stream);

struct rjd_ostream rjd_ostream_from_memory(void* buffer, size_t size);
struct rjd_ostream rjd_ostream_from_file(const char* filepath, enum rjd_ostream_mode);
struct rjd_result rjd_ostream_write(struct rjd_ostream* stream, const void* buffer, size_t size);
void rjd_ostream_close(struct rjd_ostream* stream);

#if RJD_IMPL

static struct rjd_result rjd_istream_fail(struct rjd_istream* stream, const char* reason);
static struct rjd_result rjd_istream_refill_zeroes(struct rjd_istream* stream);
static struct rjd_result rjd_istream_refill_memory(struct rjd_istream* stream);
static struct rjd_result rjd_istream_refill_file(struct rjd_istream* stream);
static void rjd_istream_close_file(struct rjd_istream* stream);

struct rjd_istream rjd_istream_from_zeroes()
{
	struct rjd_istream stream = 
	{
		.start = NULL,
		.end = NULL,
		.cursor = NULL,
		.userdata = NULL,
		.result = RJD_RESULT_OK(),
		.refill = rjd_istream_refill_zeroes,
		.close = NULL,
	};
	stream.refill(&stream);
	return stream;
}

struct rjd_istream rjd_istream_from_memory(const void* buffer, size_t size)
{
	const uint8_t* cbuffer = buffer;

	struct rjd_istream stream =
	{
		.start = cbuffer,
		.end = cbuffer + size,
		.cursor = cbuffer,
		.userdata = NULL,
		.result = RJD_RESULT_OK(),
		.refill = rjd_istream_refill_memory,
		.close = NULL,
	};
	return stream;
}

struct rjd_istream rjd_istream_from_file(const char* filepath, struct rjd_mem_allocator* allocator, size_t buffer_size)
{
	RJD_ASSERT(filepath);
	RJD_ASSERT(allocator);

	uint8_t* buffer = NULL;
	struct rjd_result result = RJD_RESULT_OK();
	FILE* file = fopen(filepath, "rb");

	if (file) {
		if (buffer_size == RJD_ISTREAM_FILE_BUFFER_SIZE_ALL) {
			result = RJD_RESULT("Failed to get file length");
			if (fseek(file, 0, SEEK_END) == 0) {
				long int length = ftell(file);
				if (length >= 0) {
					if (fseek(file, 0, SEEK_SET) == 0) {
						buffer_size = (size_t)length;
						result = RJD_RESULT_OK();
					}
				}
			}
		}
	} else {
		result = RJD_RESULT("Failed to open file");
	}

	if (rjd_result_isok(result)) {
		buffer = rjd_mem_alloc_array(uint8_t, buffer_size, allocator);
	}

	struct rjd_istream stream =
	{
		.start = buffer,
		.end = buffer + buffer_size,
		.cursor = buffer,
		.userdata = file,
		.refill = rjd_istream_refill_file,
		.close = rjd_istream_close_file,
	};
	stream.result = stream.refill(&stream);
	return stream;
}

struct rjd_result rjd_istream_read(struct rjd_istream* stream, void* buffer, size_t size)
{
	RJD_ASSERT(stream);
	RJD_ASSERT(buffer);
	RJD_ASSERT(size > 0);

    uint8_t* offset_buffer = buffer;
	size_t bytes_remaining = size;
	while (bytes_remaining > 0) {
		if (stream->cursor == stream->end) {
			stream->result = stream->refill(stream);
		}
        RJD_ASSERT(stream->end >= stream->cursor)
		ptrdiff_t buffersize = stream->end - stream->cursor;
		size_t readsize = (size_t)rjd_math_minu64((size_t)buffersize, bytes_remaining);

		memcpy(offset_buffer, stream->cursor, readsize);
        
        offset_buffer += readsize;
		bytes_remaining -= readsize;
		stream->cursor += readsize;
	}

	return stream->result;
}

void rjd_istream_close(struct rjd_istream* stream)
{
	RJD_ASSERT(stream);

	if (stream->close) {
		stream->close(stream);
	}
}

struct rjd_ostream rjd_ostream_from_memory(void* buffer, size_t size)
{
	struct rjd_ostream stream = 
	{
		.type = RJD_OSTREAM_TYPE_MEMORY,
		.state = {
			.memory = { buffer, (uint32_t)size, 0 },
		},
	};
	return stream;
}

struct rjd_ostream rjd_ostream_from_file(const char* filepath, enum rjd_ostream_mode mode)
{
	const char* writemode = NULL;
	switch (mode)
	{
		case RJD_OSTREAM_MODE_REPLACE: writemode = "wb"; break;
		case RJD_OSTREAM_MODE_APPEND:  writemode = "ab"; break;
	}
	RJD_ASSERT(writemode);
	FILE* file = fopen(filepath, writemode);

	struct rjd_ostream stream =
	{
		.type = RJD_OSTREAM_TYPE_FILE,
		.state = {
			.file = { file },
		},
	};
	return stream;
}

struct rjd_result rjd_ostream_write(struct rjd_ostream* stream, const void* buffer, size_t size)
{
	if (stream->type == RJD_OSTREAM_TYPE_MEMORY) {
		struct rjd_ostream_memory* state = &stream->state.memory;
		RJD_ASSERT(state->size >= state->cursor);

		const size_t bytes_remaining = state->size - state->cursor;
		if (size > bytes_remaining) {
			return RJD_RESULT("attempted to write more data than the buffer can hold");
		}

		const uint8_t* cbuffer = buffer;
		RJD_ASSERTMSG(!(cbuffer >= state->buffer && cbuffer < state->buffer + state->size), 
					"source and destination buffers must not overlap");

		memcpy(state->buffer + state->cursor, buffer, size);
		state->cursor += size;
	} else if (stream->type == RJD_OSTREAM_TYPE_FILE) {
		struct rjd_ostream_file* state = &stream->state.file;
		if (state->file == NULL) {
			return RJD_RESULT("failed to open file for writing");
		}
		
		size_t bytes_written = fwrite(buffer, 1, size, state->file);
		if (bytes_written != size) {
			return RJD_RESULT("failed to write all data to file");
		}
	}

	return RJD_RESULT_OK();
}

void rjd_ostream_close(struct rjd_ostream* stream)
{
	if (stream->type == RJD_OSTREAM_TYPE_MEMORY) {
		stream->state.memory.buffer = NULL;
	} else if (stream->type == RJD_OSTREAM_TYPE_FILE) {
		fclose(stream->state.file.file);
	}
}

////////////////////////////////////////////////////////////////////////////////
// static helpers

static struct rjd_result rjd_istream_fail(struct rjd_istream* stream, const char* reason)
{
	stream->result = RJD_RESULT(reason);
	stream->refill = rjd_istream_refill_zeroes;
	return stream->refill(stream);
}

static struct rjd_result rjd_istream_refill_zeroes(struct rjd_istream* stream)
{
	static uint8_t zeroes[128] = {0};

	stream->start = zeroes;
	stream->end = zeroes + sizeof(zeroes);
	stream->cursor = stream->start;
	return stream->result;
}

static struct rjd_result rjd_istream_refill_memory(struct rjd_istream* stream)
{
	return rjd_istream_fail(stream, "reached end of memory buffer");
}

static struct rjd_result rjd_istream_refill_file(struct rjd_istream* stream)
{
	FILE* file = (FILE*)stream->userdata;

	 // cast to non-const since we know the file buffer is ok to write to
	void* writable_buffer = (void*)stream->start;
	ptrdiff_t bytes_wanted = stream->end - stream->start;
	int32_t bytes_read = (int32_t)fread(writable_buffer, 1, bytes_wanted, file);

    RJD_ASSERT(bytes_read <= bytes_wanted);
    
	if (bytes_read < bytes_wanted) {
		if (feof(file)) {
			if (bytes_read == 0) {
				rjd_istream_close_file(stream);
				rjd_istream_fail(stream, "end of file reached, no more data available");
			} else {
				stream->end = stream->start + bytes_read;
                stream->cursor = stream->start;
                stream->result = RJD_RESULT_OK();
			}
		} else {
			rjd_istream_close_file(stream);
			rjd_istream_fail(stream, "error reading file contents into memory");
		}
	} else {
        if (feof(file)) {
            rjd_istream_fail(stream, "end of file reached, no more data available");
        } else {
            stream->cursor = stream->start;
        }
    }

	return stream->result;
}

static void rjd_istream_close_file(struct rjd_istream* stream)
{
	rjd_mem_free(stream->start);
	FILE* file = (FILE*)stream->userdata;
	if (file) {
		fclose(file);
	}

	stream->userdata = NULL;
	stream->refill = rjd_istream_refill_zeroes;
	stream->close = NULL;

	stream->refill(stream);
}

#endif


////////////////////////////////////////////////////////////////////////////////
// rjd_binrw.h
////////////////////////////////////////////////////////////////////////////////

#define RJD_BINRW_H 1

struct rjd_istream;
struct rjd_ostream;

struct rjd_binrw_state
{
	struct rjd_istream* istream;
	struct rjd_ostream* ostream;
};

static inline struct rjd_result rjd_binrw_read_int8(struct rjd_istream* stream, int8_t* value);
static inline struct rjd_result rjd_binrw_read_int16(struct rjd_istream* stream, int16_t* value);
static inline struct rjd_result rjd_binrw_read_int32(struct rjd_istream* stream, int32_t* value);
static inline struct rjd_result rjd_binrw_read_int64(struct rjd_istream* stream, int64_t* value);
static inline struct rjd_result rjd_binrw_read_uint8(struct rjd_istream* stream, uint8_t* value);
static inline struct rjd_result rjd_binrw_read_uint16(struct rjd_istream* stream, uint16_t* value);
static inline struct rjd_result rjd_binrw_read_uint32(struct rjd_istream* stream, uint32_t* value);
static inline struct rjd_result rjd_binrw_read_uint64(struct rjd_istream* stream, uint64_t* value);

static inline struct rjd_result rjd_binrw_write_int8(struct rjd_ostream* stream, int8_t value);
static inline struct rjd_result rjd_binrw_write_int16(struct rjd_ostream* stream, int16_t value);
static inline struct rjd_result rjd_binrw_write_int32(struct rjd_ostream* stream, int32_t value);
static inline struct rjd_result rjd_binrw_write_int64(struct rjd_ostream* stream, int64_t value);
static inline struct rjd_result rjd_binrw_write_uint8(struct rjd_ostream* stream, uint8_t value);
static inline struct rjd_result rjd_binrw_write_uint16(struct rjd_ostream* stream, uint16_t value);
static inline struct rjd_result rjd_binrw_write_uint32(struct rjd_ostream* stream, uint32_t value);
static inline struct rjd_result rjd_binrw_write_uint64(struct rjd_ostream* stream, uint64_t value);

static inline struct rjd_result rjd_binrw_readwrite_int8(struct rjd_binrw_state* state, int8_t* value);
static inline struct rjd_result rjd_binrw_readwrite_int16(struct rjd_binrw_state* state, int16_t* value);
static inline struct rjd_result rjd_binrw_readwrite_int32(struct rjd_binrw_state* state, int32_t* value);
static inline struct rjd_result rjd_binrw_readwrite_int64(struct rjd_binrw_state* state, int64_t* value);
static inline struct rjd_result rjd_binrw_readwrite_uint8(struct rjd_binrw_state* state, uint8_t* value);
static inline struct rjd_result rjd_binrw_readwrite_uint16(struct rjd_binrw_state* state, uint16_t* value);
static inline struct rjd_result rjd_binrw_readwrite_uint32(struct rjd_binrw_state* state, uint32_t* value);
static inline struct rjd_result rjd_binrw_readwrite_uint64(struct rjd_binrw_state* state, uint64_t* value);

////////////////////////////////////////////////////////////////////////////////
// implementation

#define RJD_BINRW_DEFINE_READ_IMPL(type, name)										\
	static inline struct rjd_result name(struct rjd_istream* stream, type* value) {	\
		RJD_ASSERT(stream && value);												\
		return rjd_istream_read(stream, value, sizeof(*value));						\
	}

#define RJD_BINRW_DEFINE_WRITE_IMPL(type, name)										\
	static inline struct rjd_result name(struct rjd_ostream* stream, type value) {	\
		RJD_ASSERT(stream);															\
		return rjd_ostream_write(stream, &value, sizeof(value));					\
	}

#define RJD_BINRW_DEFINE_READWRITE_IMPL(type, type2, name)								\
	static inline struct rjd_result name(struct rjd_binrw_state* state, type* value) {	\
		RJD_ASSERT(state && value && (state->istream || state->ostream));				\
		if (state->istream) {															\
			return rjd_binrw_read_ ## type2(state->istream, value);						\
		} else {																		\
			return rjd_binrw_write_ ## type2(state->ostream, *value);					\
		}																				\
	}

RJD_BINRW_DEFINE_READ_IMPL(int8_t, rjd_binrw_read_int8)
RJD_BINRW_DEFINE_READ_IMPL(int16_t, rjd_binrw_read_int16)
RJD_BINRW_DEFINE_READ_IMPL(int32_t, rjd_binrw_read_int32)
RJD_BINRW_DEFINE_READ_IMPL(int64_t, rjd_binrw_read_int64)
RJD_BINRW_DEFINE_READ_IMPL(uint8_t, rjd_binrw_read_uint8)
RJD_BINRW_DEFINE_READ_IMPL(uint16_t, rjd_binrw_read_uint16)
RJD_BINRW_DEFINE_READ_IMPL(uint32_t, rjd_binrw_read_uint32)
RJD_BINRW_DEFINE_READ_IMPL(uint64_t, rjd_binrw_read_uint64)

RJD_BINRW_DEFINE_WRITE_IMPL(int8_t, rjd_binrw_write_int8)
RJD_BINRW_DEFINE_WRITE_IMPL(int16_t, rjd_binrw_write_int16)
RJD_BINRW_DEFINE_WRITE_IMPL(int32_t, rjd_binrw_write_int32)
RJD_BINRW_DEFINE_WRITE_IMPL(int64_t, rjd_binrw_write_int64)
RJD_BINRW_DEFINE_WRITE_IMPL(uint8_t, rjd_binrw_write_uint8)
RJD_BINRW_DEFINE_WRITE_IMPL(uint16_t, rjd_binrw_write_uint16)
RJD_BINRW_DEFINE_WRITE_IMPL(uint32_t, rjd_binrw_write_uint32)
RJD_BINRW_DEFINE_WRITE_IMPL(uint64_t, rjd_binrw_write_uint64)

RJD_BINRW_DEFINE_READWRITE_IMPL(int8_t, int8, rjd_binrw_readwrite_int8)
RJD_BINRW_DEFINE_READWRITE_IMPL(int16_t, int16, rjd_binrw_readwrite_int16)
RJD_BINRW_DEFINE_READWRITE_IMPL(int32_t, int32, rjd_binrw_readwrite_int32)
RJD_BINRW_DEFINE_READWRITE_IMPL(int64_t, int64, rjd_binrw_readwrite_int64)
RJD_BINRW_DEFINE_READWRITE_IMPL(uint8_t, uint8, rjd_binrw_readwrite_uint8)
RJD_BINRW_DEFINE_READWRITE_IMPL(uint16_t, uint16, rjd_binrw_readwrite_uint16)
RJD_BINRW_DEFINE_READWRITE_IMPL(uint32_t, uint32, rjd_binrw_readwrite_uint32)
RJD_BINRW_DEFINE_READWRITE_IMPL(uint64_t, uint64, rjd_binrw_readwrite_uint64)


////////////////////////////////////////////////////////////////////////////////
// rjd_strhash.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_STRHASH_H 1

struct rjd_strhash
{
	struct rjd_hash64 hash;
	struct rjd_strref* debug_string;
};

void rjd_strhash_global_init(struct rjd_mem_allocator* debug_allocator, uint32_t initial_capacity);
void rjd_strhash_global_destroy(void);

struct rjd_strhash rjd_strhash_init(const char* str);
bool rjd_strhash_isequal(struct rjd_strhash a, struct rjd_strhash b);
int rjd_strhash_compare(const struct rjd_strhash* a, const struct rjd_strhash* b);

#define RJD_STRHASH(string) (rjd_strhash_init(string))

#if RJD_IMPL

struct rjd_strpool* g_strhash_strpool;

void rjd_strhash_global_init(struct rjd_mem_allocator* debug_allocator, uint32_t initial_capacity)
{
	if (initial_capacity == 0) {
		initial_capacity = 128;
	}

	g_strhash_strpool = rjd_mem_alloc(struct rjd_strpool, debug_allocator);
	*g_strhash_strpool = rjd_strpool_init(debug_allocator, initial_capacity);
}

void rjd_strhash_global_destroy(void)
{
	rjd_strpool_free(g_strhash_strpool);
	rjd_mem_free(g_strhash_strpool);
	g_strhash_strpool = NULL;
}

struct rjd_strhash rjd_strhash_init(const char* str)
{
    struct rjd_hash64 hash = rjd_hash64_str(str);
    struct rjd_strref* debug_string = NULL;
    if (g_strhash_strpool && hash.value != 0)
    {
        // TODO make threadsafe
        debug_string = rjd_strpool_add(g_strhash_strpool, str);
    }

	struct rjd_strhash strhash = {
		.debug_string = debug_string,
		.hash = hash,
	};
	return strhash;
}

bool rjd_strhash_isequal(struct rjd_strhash a, struct rjd_strhash b)
{
	return a.hash.value == b.hash.value;
}

int rjd_strhash_compare(const struct rjd_strhash* a, const struct rjd_strhash* b)
{
	return a->hash.value < b->hash.value;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_resource_types.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_RESOURCE_TYPES_H 1

struct rjd_resource_id
{
	struct rjd_strhash hash;
};

struct rjd_resource_type_id
{
	struct rjd_strhash hash;
};

struct rjd_resource_handle
{
	struct rjd_slot slot;
};

static inline struct rjd_resource_id rjd_resource_id_from_str(const char* str);
static inline struct rjd_resource_id rjd_resource_id_none(void);
static inline bool rjd_resource_id_equals(struct rjd_resource_id a, struct rjd_resource_id b);
static inline bool rjd_resource_id_isvalid(struct rjd_resource_id id);

static inline struct rjd_resource_type_id rjd_resource_type_id_from_str(const char* str);
static inline struct rjd_resource_type_id rjd_resource_type_id_none(void);
static inline bool rjd_resource_type_id_equals(struct rjd_resource_type_id a, struct rjd_resource_type_id b);
static inline bool rjd_resource_type_id_isvalid(struct rjd_resource_type_id id);

static inline struct rjd_resource_handle rjd_resource_handle_none(void);
static inline bool rjd_resource_handle_equals(struct rjd_resource_handle a, struct rjd_resource_handle b);
static inline bool rjd_resource_handle_isvalid(struct rjd_resource_handle handle);

////////////////////////////////////////////////////////////////////////////////
// static inline implementation

static inline struct rjd_resource_id rjd_resource_id_from_str(const char* str)
{
	struct rjd_resource_id id = {
		.hash = rjd_strhash_init(str),
	};
	return id;
}

static inline struct rjd_resource_id rjd_resource_id_none(void)
{
	return rjd_resource_id_from_str(NULL);
}

static inline bool rjd_resource_id_equals(struct rjd_resource_id a, struct rjd_resource_id b)
{
	return a.hash.hash.value == b.hash.hash.value;
}

static inline bool rjd_resource_id_isvalid(struct rjd_resource_id id)
{
	return id.hash.hash.value != 0;
}

static inline struct rjd_resource_type_id rjd_resource_type_id_from_str(const char* str)
{
	struct rjd_resource_type_id id = {
		.hash = rjd_strhash_init(str),
	};
	return id;
}

static inline struct rjd_resource_type_id rjd_resource_type_id_none(void)
{
	return rjd_resource_type_id_from_str(NULL);
}

static inline bool rjd_resource_type_id_equals(struct rjd_resource_type_id a, struct rjd_resource_type_id b)
{
	return a.hash.hash.value == b.hash.hash.value;
}

static inline bool rjd_resource_type_id_isvalid(struct rjd_resource_type_id id)
{
	return id.hash.hash.value != 0;
}

static inline struct rjd_resource_handle rjd_resource_handle_none(void)
{
	struct rjd_resource_handle handle;
	handle.slot.index = 0;
	handle.slot.salt = 0;
	return handle;
}

static inline bool rjd_resource_handle_equals(struct rjd_resource_handle a, struct rjd_resource_handle b)
{
	return a.slot.index == b.slot.index &&
			a.slot.salt == b.slot.salt;
}

static inline bool rjd_resource_handle_isvalid(struct rjd_resource_handle handle)
{
	return rjd_slot_isvalid(handle.slot);
}


////////////////////////////////////////////////////////////////////////////////
// rjd_resource_loader.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_RESOURCE_LOADER_H 1

struct rjd_resource_loader;

typedef void rjd_resource_loader_destroy_func(struct rjd_resource_loader* loader);
typedef struct rjd_result rjd_resource_loader_get_type_func(struct rjd_resource_loader* loader, struct rjd_resource_id id, struct rjd_resource_type_id* out);
typedef struct rjd_result rjd_resource_loader_load_func(struct rjd_resource_loader* loader, struct rjd_resource_id id, struct rjd_mem_allocator* allocator, struct rjd_istream* out);

struct rjd_resource_loader
{
	void* impl;
	rjd_resource_loader_destroy_func* destroy_func;
	rjd_resource_loader_get_type_func* get_type_func;
	rjd_resource_loader_load_func* load_func;
};

enum rjd_resource_loader_type
{
	RJD_RESOURCE_LOADER_TYPE_FILESYSTEM, // recursively crawls a root directory to find all resource files
	//RJD_RESOURCE_LOADER_TYPE_REMOTE, // requests manifest from a given http endpoint
	//RJD_RESOURCE_LOADER_TYPE_PACK, // reads manifest embedded inside given pack files
};

struct rjd_resource_extension_to_type_id
{
	struct rjd_resource_type_id type;
	const char* extension;
};

struct rjd_resource_loader_desc
{
	enum rjd_resource_loader_type type;
	struct rjd_mem_allocator* allocator;
	union
	{
		struct {
			const char* root;
			const struct rjd_resource_extension_to_type_id* type_mappings;
			uint32_t type_mappings_count;
			uint32_t manifest_capacity;
		} filesystem;
	};
};

struct rjd_result rjd_resource_loader_create(struct rjd_resource_loader* out, struct rjd_resource_loader_desc desc);
static inline void rjd_resource_loader_destroy(struct rjd_resource_loader* loader);
static inline struct rjd_result rjd_resource_loader_get_type(struct rjd_resource_loader* loader, struct rjd_resource_id id, struct rjd_resource_type_id* out);
static inline struct rjd_result rjd_resource_loader_load(struct rjd_resource_loader* loader, struct rjd_resource_id id, struct rjd_mem_allocator* allocator, struct rjd_istream* out);

////////////////////////////////////////////////////////////////////////////////
// Inline implementation

static inline void rjd_resource_loader_destroy(struct rjd_resource_loader* loader)
{
	RJD_ASSERT(loader);
	RJD_ASSERT(loader->destroy_func);

	loader->destroy_func(loader);
}

static inline struct rjd_result rjd_resource_loader_get_type(struct rjd_resource_loader* loader, struct rjd_resource_id id, struct rjd_resource_type_id* out)
{
	RJD_ASSERT(loader);
	RJD_ASSERT(loader->get_type_func);

	return loader->get_type_func(loader, id, out);
}

static inline struct rjd_result rjd_resource_loader_load(struct rjd_resource_loader* loader, struct rjd_resource_id id, struct rjd_mem_allocator* allocator, struct rjd_istream* out)
{
	RJD_ASSERT(loader);
	RJD_ASSERT(loader->load_func);

	return loader->load_func(loader, id, allocator, out);
}

#if RJD_IMPL

struct rjd_resource_manifest_entry_filesystem
{
	struct rjd_resource_id id;
	struct rjd_resource_type_id type;
	struct rjd_strref* path;
};

// private types
struct rjd_resource_loader_filesystem
{
	enum rjd_resource_loader_type debug_sentinel;
	struct rjd_strpool strpool;
	struct rjd_resource_extension_to_type_id* type_mappings;
	struct rjd_strref* root;
	struct rjd_resource_manifest_entry_filesystem* manifest_entries; // TODO could be sorted by resource id
};

// static helpers

static int32_t RJD_COMPILER_MSVC_ONLY(__cdecl) rjd_resource_loader_manifest_entry_comparer(const void* a, const void* b);
static struct rjd_resource_loader_filesystem* rjd_resource_loader_to_filesystem_loader(struct rjd_resource_loader* loader);
static void rjd_resource_loader_filesystem_destroy(struct rjd_resource_loader* loader);
static struct rjd_result rjd_resource_loader_filesystem_get_type(struct rjd_resource_loader* loader, struct rjd_resource_id id, struct rjd_resource_type_id* out);
static struct rjd_result rjd_resource_loader_filesystem_load(struct rjd_resource_loader* loader, struct rjd_resource_id id, struct rjd_mem_allocator* allocator, struct rjd_istream* out);

// public implementation

struct rjd_result rjd_resource_loader_create(struct rjd_resource_loader* out, struct rjd_resource_loader_desc desc)
{
	void* impl_any = NULL;

	if (desc.type == RJD_RESOURCE_LOADER_TYPE_FILESYSTEM)
	{
		uint32_t manifest_capacity = desc.filesystem.manifest_capacity == 0 ? 1024 : desc.filesystem.manifest_capacity;

		struct rjd_resource_loader_filesystem* impl = rjd_mem_alloc(struct rjd_resource_loader_filesystem, desc.allocator);
		impl->debug_sentinel = RJD_RESOURCE_LOADER_TYPE_FILESYSTEM;
		impl->strpool = rjd_strpool_init(desc.allocator, 64);
		impl->type_mappings = rjd_array_alloc(struct rjd_resource_extension_to_type_id, desc.filesystem.type_mappings_count, desc.allocator);
		impl->root = rjd_strpool_add(&impl->strpool, desc.filesystem.root);
		impl->manifest_entries = rjd_array_alloc(struct rjd_resource_manifest_entry_filesystem, manifest_capacity, desc.allocator);

		for (uint32_t i = 0; i < desc.filesystem.type_mappings_count; ++i)
		{
			rjd_array_push(impl->type_mappings, desc.filesystem.type_mappings[i]);
		}

		const size_t length_root_path = strlen(desc.filesystem.root) + 1; // +1 to skip path separator
		struct rjd_path_enumerator_state path_enumerator = rjd_path_enumerate_create(desc.filesystem.root, desc.allocator, RJD_PATH_ENUMERATE_MODE_RECURSIVE);
		for (const char* path = rjd_path_enumerate_next(&path_enumerator); path != NULL; path = rjd_path_enumerate_next(&path_enumerator))
		{
			const char* relative_path = path + length_root_path;
			const char* extension = rjd_path_extension_str(relative_path);
			if (extension)
			{
				struct rjd_resource_type_id type = {0};
				for (uint32_t i = 0; i < rjd_array_count(impl->type_mappings); ++i)
				{
					if (strcmp(impl->type_mappings[i].extension, extension) == 0) // TODO case-insensitive compare
					{
						type = impl->type_mappings[i].type;
					}
				}

				if (type.hash.hash.value != 0)
				{
					struct rjd_strref* pathref = rjd_strpool_add(&impl->strpool, relative_path);
					struct rjd_resource_manifest_entry_filesystem entry = {
						.id = rjd_strhash_init(relative_path),
						.type = type,
						.path = pathref,
					};
					rjd_array_push(impl->manifest_entries, entry);
				}
			}
		}

		rjd_path_enumerate_destroy(&path_enumerator);

		// since the enumerator doesn't return entries in a sorted manner, make sure the manifest order
		// is deterministic
		rjd_array_sort(impl->manifest_entries, rjd_resource_loader_manifest_entry_comparer);

		impl_any = impl;
	}
	else
	{
		return RJD_RESULT("unimplemented support for this type of loader");
	}

	struct rjd_resource_loader loader = {
		.impl = impl_any,
		.destroy_func = rjd_resource_loader_filesystem_destroy,
		.get_type_func = rjd_resource_loader_filesystem_get_type,
		.load_func = rjd_resource_loader_filesystem_load,
	};
	*out = loader;

	return RJD_RESULT_OK();
}

// private implementation

static int32_t RJD_COMPILER_MSVC_ONLY(__cdecl) rjd_resource_loader_manifest_entry_comparer(const void* a, const void* b)
{
	const struct rjd_resource_manifest_entry_filesystem* aa = a;
	const struct rjd_resource_manifest_entry_filesystem* bb = b;

	const char* path_a = rjd_strref_str(aa->path);
	const char* path_b = rjd_strref_str(bb->path);

	return strcmp(path_a, path_b);
}

static struct rjd_resource_loader_filesystem* rjd_resource_loader_to_filesystem_loader(struct rjd_resource_loader* loader)
{
	RJD_ASSERT(loader);

	struct rjd_resource_loader_filesystem* impl = (struct rjd_resource_loader_filesystem*)loader->impl;
	RJD_ASSERT(impl->debug_sentinel == RJD_RESOURCE_LOADER_TYPE_FILESYSTEM);
	return impl;
}

static void rjd_resource_loader_filesystem_destroy(struct rjd_resource_loader* loader)
{
	struct rjd_resource_loader_filesystem* impl = rjd_resource_loader_to_filesystem_loader(loader);
	rjd_array_free(impl->manifest_entries);
	rjd_array_free(impl->type_mappings);
	rjd_strpool_free(&impl->strpool);
	rjd_mem_free(impl);
	memset(loader, 0, sizeof(*loader));
}

static struct rjd_result rjd_resource_loader_filesystem_get_type(struct rjd_resource_loader* loader, struct rjd_resource_id id, struct rjd_resource_type_id* out)
{
	struct rjd_resource_loader_filesystem* impl = rjd_resource_loader_to_filesystem_loader(loader);
	for (uint32_t i = 0; i < rjd_array_count(impl->manifest_entries); ++i) {
		if (rjd_resource_id_equals(impl->manifest_entries[i].id, id)) {
			*out = impl->manifest_entries[i].type;
			return RJD_RESULT_OK();
		}
	}

	return RJD_RESULT("Resource id not found in loader manifest.");
}

static struct rjd_result rjd_resource_loader_filesystem_load(struct rjd_resource_loader* loader, struct rjd_resource_id id, struct rjd_mem_allocator* allocator, struct rjd_istream* out)
{
	struct rjd_resource_loader_filesystem* impl = rjd_resource_loader_to_filesystem_loader(loader);
	for (uint32_t i = 0; i < rjd_array_count(impl->manifest_entries); ++i) {
		if (rjd_resource_id_equals(impl->manifest_entries[i].id, id)) {
            const char* root = rjd_strref_str(impl->root);
            const char* relative_path = rjd_strref_str(impl->manifest_entries[i].path);
            
            struct rjd_path fullpath = rjd_path_create();
            rjd_path_append(&fullpath, root);
            rjd_path_append(&fullpath, relative_path);

			*out = rjd_istream_from_file(rjd_path_get(&fullpath), allocator, 1024 * 512);
			return out->result;
		}
	}

	return RJD_RESULT("Resource id not found in loader manifest.");
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_resource.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_RESOURCE_H 1

// TODO update all the RJD_LOGs to a resource channel
struct rjd_result;
struct rjd_resource_type;
struct rjd_resource;
struct rjd_resource_loader;
struct rjd_resource_load_begin_params;
struct rjd_resource_load_end_params;
struct rjd_resource_unload_params;
struct rjd_resource_load_dependency_params;
struct rjd_resource_get_dependency_params;

enum rjd_resource_status
{
	RJD_RESOURCE_STATUS_INVALID,
	RJD_RESOURCE_STATUS_LOAD_BEGIN,
	RJD_RESOURCE_STATUS_LOAD_RESOLVE,
	RJD_RESOURCE_STATUS_LOAD_END,
	RJD_RESOURCE_STATUS_FAILED,
	RJD_RESOURCE_STATUS_READY,
};

struct rjd_resource_dependency
{
    enum rjd_resource_status status;
    void* typed_resource_data;
};

// Loading takes place in 2 passes, where resources get a chance to declare any dependencies they want loaded before
// their load function gets called.
typedef struct rjd_result rjd_resource_load_begin_func(struct rjd_resource_load_begin_params* params);
typedef struct rjd_result rjd_resource_load_end_func(struct rjd_resource_load_end_params* params);
typedef void rjd_resource_unload_func(struct rjd_resource_unload_params* params);
typedef struct rjd_result rjd_resource_add_dependency_func(struct rjd_resource_load_dependency_params* params, struct rjd_resource_id dependency, struct rjd_resource_handle* child);
typedef struct rjd_resource_dependency rjd_resource_get_dependency_func(struct rjd_resource_get_dependency_params* params, struct rjd_resource_handle handle);

struct rjd_resource_load_begin_params
{
	struct rjd_istream stream_data;
	uint32_t filesize;
	void* typed_resource_data;
	void* userdata;
	struct rjd_mem_allocator* allocator;
	struct rjd_mem_allocator* scratch_allocator;

	// for loading dependent resources
	rjd_resource_add_dependency_func* load_dependency_func;
	struct rjd_resource_load_dependency_params* dependency_params;
};

struct rjd_resource_load_end_params
{
	void* typed_resource_data;
	void* userdata;
	struct rjd_mem_allocator* allocator;
	struct rjd_mem_allocator* scratch_allocator;

	struct rjd_resource_get_dependency_params* get_dependency_params;
	rjd_resource_get_dependency_func* get_dependency_func;
};

struct rjd_resource_unload_params
{
	void* typed_resource_data;
	void* userdata;

	struct rjd_resource_get_dependency_params* get_dependency_params;
	rjd_resource_get_dependency_func* get_dependency_func;
};

struct rjd_resource_type
{
	struct rjd_resource_type_id id;
	struct rjd_mem_allocator* optional_allocator;
	void* userdata;
	rjd_resource_load_begin_func* load_begin_func;
	rjd_resource_load_end_func* optional_load_end_func;
	rjd_resource_unload_func* optional_unload_func;
	uint32_t in_memory_size;
};

struct rjd_resource_lib_desc
{
	struct rjd_mem_allocator* allocator;
	struct rjd_resource_loader* loader;

	struct rjd_resource_type* types;
	uint32_t count_types;
	uint32_t initial_capacity_types;
	uint32_t initial_capacity_resources;
	uint32_t initial_capacity_buffers;
};

struct rjd_resource_lib
{
	struct rjd_mem_allocator* allocator;
	struct rjd_resource_loader* loader;
	struct rjd_resource_type* registered_types; // should only be accessed from one thread, TODO enforce
	struct rjd_resource* resources; // TODO make threadsafe

	// TODO make these threadsafe queues
	struct {
		struct rjd_resource_handle* begin;
		struct rjd_resource_handle* resolving_dependencies;
		struct rjd_resource_handle* end;
	} load_stage_queues;

	struct rjd_resource_handle* unload_queue;
};

struct rjd_resource_id rjd_resource_id_from_path(const char* path);

void rjd_resource_lib_create(struct rjd_resource_lib* lib, struct rjd_resource_lib_desc desc);
struct rjd_result rjd_resource_lib_destroy(struct rjd_resource_lib* lib);
struct rjd_result rjd_resource_lib_register_type(struct rjd_resource_lib* lib, struct rjd_resource_type type);
// TODO have the system return fallback handles for resources that failed to load
//struct rjd_result rjd_resource_lib_register_fallback(struct rjd_resource_lib* lib, struct rjd_resource_type type, struct rjd_resource_handle fallback);
void rjd_resource_lib_pump(struct rjd_resource_lib* lib, struct rjd_mem_allocator* scratch_allocator);
void rjd_resource_lib_wait(struct rjd_resource_lib* lib, struct rjd_resource_handle* resources, size_t count);
void rjd_resource_lib_waitall(struct rjd_resource_lib* lib);

struct rjd_result rjd_resource_load(struct rjd_resource_lib* lib, struct rjd_resource_id id, struct rjd_resource_handle* out);
enum rjd_resource_status rjd_resource_lib_status(struct rjd_resource_lib* lib, struct rjd_resource_handle handle);
bool rjd_resource_is_loading(struct rjd_resource_lib* lib, struct rjd_resource_handle handle);
void* rjd_resource_get(struct rjd_resource_lib* lib, struct rjd_resource_handle id);
void rjd_resource_unload(struct rjd_resource_lib* lib, struct rjd_resource_handle handle);

#if RJD_IMPL

// NOTE: We explicitly don't have refcounting in this system. Clients can build their own refcount on top of this if they want.
struct rjd_resource
{
	struct rjd_resource_id id;
	void* typed_resource_data;
	struct rjd_resource_handle* dependencies;
	enum rjd_resource_status status;
	uint32_t refcount; // TODO atomic
	uint32_t registry_index;
};

struct rjd_resource_load_dependency_params
{
	struct rjd_resource_lib* lib;
	struct rjd_resource_handle parent;
};

static struct rjd_result rjd_resource_add_dependency(struct rjd_resource_load_dependency_params* params, struct rjd_resource_id id, struct rjd_resource_handle* child);
static struct rjd_resource_dependency rjd_resource_get_dependency(struct rjd_resource_get_dependency_params* params, struct rjd_resource_handle handle);

void rjd_resource_lib_create(struct rjd_resource_lib* lib, struct rjd_resource_lib_desc desc)
{
	if (desc.initial_capacity_types == 0) {
		desc.initial_capacity_types = 32;
	}

	if (desc.initial_capacity_resources == 0) {
		desc.initial_capacity_resources = 256;
	}

	if (desc.initial_capacity_buffers == 0) {
		desc.initial_capacity_buffers = 64;
	}

	RJD_ASSERTMSG(desc.loader, "You must create a loader with rjd_resource_loader_create() and set it in rjd_resource_lib_desc");

	lib->allocator = desc.allocator;
	lib->loader = desc.loader;
	lib->registered_types = rjd_array_alloc(struct rjd_resource_type, desc.initial_capacity_types, desc.allocator);
	lib->resources = rjd_slotmap_alloc(struct rjd_resource, desc.initial_capacity_resources, desc.allocator);
	lib->load_stage_queues.begin = rjd_array_alloc(struct rjd_resource_handle, desc.initial_capacity_buffers, desc.allocator);
	lib->load_stage_queues.resolving_dependencies = rjd_array_alloc(struct rjd_resource_handle, desc.initial_capacity_buffers, desc.allocator);
	lib->load_stage_queues.end = rjd_array_alloc(struct rjd_resource_handle, desc.initial_capacity_buffers, desc.allocator);
	lib->unload_queue = rjd_array_alloc(struct rjd_resource_handle, desc.initial_capacity_buffers, desc.allocator);
}

struct rjd_result rjd_resource_lib_destroy(struct rjd_resource_lib* lib)
{
	RJD_ASSERT(lib);

	if (rjd_slotmap_count(lib->resources) > 0) {
		return RJD_RESULT("You must unload all resources before destroying the lib");
	}

	rjd_array_free(lib->unload_queue);
	rjd_array_free(lib->load_stage_queues.end);
	rjd_array_free(lib->load_stage_queues.resolving_dependencies);
	rjd_array_free(lib->load_stage_queues.begin);
	rjd_slotmap_free(lib->resources);
	rjd_array_free(lib->registered_types);
	rjd_resource_loader_destroy(lib->loader);

	return RJD_RESULT_OK();
}

struct rjd_result rjd_resource_lib_register_type(struct rjd_resource_lib* lib, struct rjd_resource_type type)
{
	RJD_ASSERT(lib);
	RJD_ASSERT(type.load_begin_func);
	RJD_ASSERT(type.in_memory_size > 0);

	for (uint32_t i = 0; i < rjd_array_count(lib->registered_types); ++i)
	{
		if (rjd_strhash_isequal(lib->registered_types[i].id.hash, type.id.hash))
		{
			return RJD_RESULT("Resource type has already been registered.");
		}
	}

	rjd_array_push(lib->registered_types, type);

	return RJD_RESULT_OK();
}

void rjd_resource_lib_pump(struct rjd_resource_lib* lib, struct rjd_mem_allocator* scratch_allocator)
{
	RJD_ASSERT(lib);

	if (!rjd_array_empty(lib->load_stage_queues.end)) {
		struct rjd_resource_handle handle = rjd_array_pop(lib->load_stage_queues.end);
		struct rjd_resource* resource = rjd_slotmap_get(lib->resources, handle.slot);
		RJD_ASSERT(resource);
		RJD_ASSERT(resource->status == RJD_RESOURCE_STATUS_LOAD_END);
	
		struct rjd_result result = RJD_RESULT_OK();
		const struct rjd_resource_type* type = lib->registered_types + resource->registry_index;
		if (type->optional_load_end_func) {
			struct rjd_resource_load_end_params params = {
				.typed_resource_data = resource->typed_resource_data,
				.userdata = type->userdata,
				.allocator = lib->allocator,
				.scratch_allocator = scratch_allocator,
				.get_dependency_params = (struct rjd_resource_get_dependency_params*)lib,
				.get_dependency_func = rjd_resource_get_dependency,
			};
			result = type->optional_load_end_func(&params);
		}
	
		if (rjd_result_isok(result)) {
			resource->status = RJD_RESOURCE_STATUS_READY;
			//RJD_LOG("Loaded resource '%s'", resource->filepath);
		} else {
			resource->status = RJD_RESOURCE_STATUS_FAILED;
			//RJD_LOG("Failed ending load for resource '%s'", resource->filepath);
		}
	}

	if (!rjd_array_empty(lib->load_stage_queues.resolving_dependencies)) {
		struct rjd_resource_handle handle_resource = rjd_array_last(lib->load_stage_queues.resolving_dependencies);
		struct rjd_resource* res = rjd_slotmap_get(lib->resources, handle_resource.slot);
		RJD_ASSERT(res);

		bool all_loaded = true;
		for (uint32_t i = 0; i < rjd_array_count(res->dependencies); ++i)
		{
			struct rjd_resource_handle handle_dependency = res->dependencies[i];
			struct rjd_resource* dependency = rjd_slotmap_get(lib->resources, handle_dependency.slot);
			RJD_ASSERT(dependency);
            // failures to load dependencies don't automatically fail resources; we leave it up to
            // the resource to decide what to do in the end stage
            // TODO use the "backup resource" as a replacement?
			if (dependency->status != RJD_RESOURCE_STATUS_READY && dependency->status != RJD_RESOURCE_STATUS_FAILED) {
				all_loaded = false;
				break;
			}
		}

		if (all_loaded) {
			// struct rjd_resource_handle handle_resource = rjd_array_pop(lib->load_stage_queues.resolving_dependencies);
			rjd_array_pop(lib->load_stage_queues.resolving_dependencies);
            res->status = RJD_RESOURCE_STATUS_LOAD_END;
			rjd_array_push(lib->load_stage_queues.end, handle_resource);
		}
	}

	if (!rjd_array_empty(lib->load_stage_queues.begin)) {
		struct rjd_resource_handle handle = rjd_array_pop(lib->load_stage_queues.begin);
		struct rjd_resource* resource = rjd_slotmap_get(lib->resources, handle.slot);
		RJD_ASSERT(resource);
		RJD_ASSERT(resource->status == RJD_RESOURCE_STATUS_LOAD_BEGIN);
	
		struct rjd_istream stream = {0};
		struct rjd_result result = rjd_resource_loader_load(lib->loader, resource->id, scratch_allocator, &stream);
		if (rjd_result_isok(result))
		{
	        struct rjd_resource_type* type = rjd_array_get(lib->registered_types, resource->registry_index);
	        struct rjd_mem_allocator* resource_allocator = type->optional_allocator ? type->optional_allocator : lib->allocator;
	        
	        resource->typed_resource_data = rjd_mem_alloc_array(uint8_t, type->in_memory_size, resource_allocator);
	        memset(resource->typed_resource_data, 0, type->in_memory_size);
	        
	        result = RJD_RESULT_OK();
			if (type->load_begin_func)
			{
				struct rjd_resource_load_dependency_params dependency_params = {
					.lib = lib,
					.parent = handle,
				};
	
				struct rjd_resource_load_begin_params load_params = {
					.stream_data = stream,
					.typed_resource_data = resource->typed_resource_data,
					.userdata = type->userdata,
					.allocator = resource_allocator,
					.scratch_allocator = scratch_allocator,
					.load_dependency_func = &rjd_resource_add_dependency,
					.dependency_params = &dependency_params,
				};
	
				result = type->load_begin_func(&load_params);
			}
	
	        if (rjd_result_isok(result)) {
	            resource->status = RJD_RESOURCE_STATUS_LOAD_RESOLVE;
	            rjd_array_push(lib->load_stage_queues.resolving_dependencies, handle);
	        } else {
	            //RJD_LOG("Failed beginning load for resource '%s': %s", resource->filepath, result.error);
	            resource->status = RJD_RESOURCE_STATUS_FAILED;
	        }
	
			rjd_istream_close(&stream);
		}
		else
		{
			//RJD_LOG("Failed loading resource '%s': %s", resource_id.hash.debug_string, result.error);
			resource->status = RJD_RESOURCE_STATUS_FAILED;
		}
	}

	if (!rjd_array_empty(lib->unload_queue)) {
		struct rjd_resource_handle handle = rjd_array_pop(lib->unload_queue);
		struct rjd_resource* resource = rjd_slotmap_get(lib->resources, handle.slot);

		// The resource could have been already freed if it was inserted into the unload queue more than once
		if (resource)
		{
			struct rjd_resource_type* type = rjd_array_get(lib->registered_types, resource->registry_index);
			if (type->optional_unload_func) {
				struct rjd_resource_unload_params params = {
					.typed_resource_data = resource->typed_resource_data,
					.userdata = type->userdata,
					.get_dependency_params = (struct rjd_resource_get_dependency_params*)lib,
					.get_dependency_func = rjd_resource_get_dependency,
				};
				type->optional_unload_func(&params);
			}
            rjd_mem_free(resource->typed_resource_data);
            rjd_array_free(resource->dependencies);
			rjd_slotmap_erase(lib->resources, handle.slot);
		}
	}

	// TODO get change notifications from loader to insert resources for reload
	// NOTE make sure to preserve the original resource until the reload is complete!
}

void rjd_resource_lib_wait(struct rjd_resource_lib* lib, struct rjd_resource_handle* resources, size_t count)
{
	const size_t K_SCRATCH_SIZE = RJD_MB * 4;
	void* scratch_buffer = rjd_mem_alloc_array_noclear(char, K_SCRATCH_SIZE, lib->allocator);
	struct rjd_mem_allocator scratch_allocator = rjd_mem_allocator_init_linear(scratch_buffer, K_SCRATCH_SIZE);

	for (uint32_t i = 0; i < count; ++i)
	{
		while (rjd_resource_is_loading(lib, resources[i])) {
			rjd_resource_lib_pump(lib, &scratch_allocator);
			rjd_mem_allocator_reset(&scratch_allocator);
		}
	}

	rjd_mem_free(scratch_buffer);
}

void rjd_resource_lib_waitall(struct rjd_resource_lib* lib)
{
	RJD_ASSERT(lib);

	const size_t K_SCRATCH_SIZE = RJD_MB * 4;
	void* scratch_buffer = rjd_mem_alloc_array_noclear(char, K_SCRATCH_SIZE, lib->allocator);
	struct rjd_mem_allocator scratch_allocator = rjd_mem_allocator_init_linear(scratch_buffer, K_SCRATCH_SIZE);

	while (!rjd_array_empty(lib->load_stage_queues.begin) ||
			!rjd_array_empty(lib->load_stage_queues.resolving_dependencies) ||
			!rjd_array_empty(lib->load_stage_queues.end) ||
            !rjd_array_empty(lib->unload_queue))
	{
		rjd_resource_lib_pump(lib, &scratch_allocator);
		rjd_mem_allocator_reset(&scratch_allocator);
	}

	rjd_mem_free(scratch_buffer);
}

struct rjd_result rjd_resource_load(struct rjd_resource_lib* lib, struct rjd_resource_id id, struct rjd_resource_handle* out)
{
	RJD_ASSERT(lib);
	RJD_ASSERT(out);

	// exists already
	for (struct rjd_slot s = rjd_slotmap_next(lib->resources, NULL); rjd_slot_isvalid(s); s = rjd_slotmap_next(lib->resources, &s))
	{
		struct rjd_resource* resource = rjd_slotmap_get(lib->resources, s);
		if (rjd_resource_id_equals(resource->id, id)) {
			++resource->refcount;
			out->slot = s;
			return RJD_RESULT_OK();
		}
	}

	// cancel unload
	for (uint32_t i = 0; i < rjd_array_count(lib->unload_queue); ++i)
	{
		struct rjd_resource_handle handle = lib->unload_queue[i];
		struct rjd_resource* resource = rjd_slotmap_get(lib->resources, handle.slot);
		if (rjd_resource_id_equals(resource->id, id)) {
			rjd_array_erase_unordered(lib->resources, i);
			++resource->refcount;
			*out = handle;
			return RJD_RESULT_OK();
		}
	}

	// kickoff the load
	struct rjd_resource_type_id type = {0};
	struct rjd_result result = rjd_resource_loader_get_type(lib->loader, id, &type);
	if (rjd_result_isok(result))
	{
		int32_t registry_index = RJD_ARRAY_NOT_FOUND;
		for (uint32_t i = 0; i < rjd_array_count(lib->registered_types); ++i) {
			if (rjd_resource_type_id_equals(lib->registered_types[i].id, type)) {
				registry_index = (int32_t)i;
				break;
			}
		}

		if (registry_index == RJD_ARRAY_NOT_FOUND) {
			return RJD_RESULT("No resource type was found for the given type id. Did you forget to register it?");
		} else {
			struct rjd_resource resource = {
				.id = id,
				.status = RJD_RESOURCE_STATUS_LOAD_BEGIN,
				.registry_index = registry_index,
				.dependencies = NULL,
				.typed_resource_data = NULL,
				.refcount = 1,
			};

			rjd_slotmap_insert(lib->resources, resource, &out->slot);

			rjd_array_push(lib->load_stage_queues.begin, *out);

			result = RJD_RESULT_OK();
		}
	}

	return result;
}

enum rjd_resource_status rjd_resource_lib_status(struct rjd_resource_lib* lib, struct rjd_resource_handle handle)
{
	RJD_ASSERT(lib);

    if (rjd_slot_isvalid(handle.slot))
    {
        if (rjd_slotmap_contains(lib->resources, handle.slot)) {
            struct rjd_resource* res = rjd_slotmap_get(lib->resources, handle.slot);
            if (res) {
                return res->status;
            }
        }
    }
	return RJD_RESOURCE_STATUS_INVALID;
}

bool rjd_resource_is_loading(struct rjd_resource_lib* lib, struct rjd_resource_handle handle)
{
	enum rjd_resource_status status = rjd_resource_lib_status(lib, handle);
	return status == RJD_RESOURCE_STATUS_LOAD_BEGIN ||
			status == RJD_RESOURCE_STATUS_LOAD_RESOLVE ||
			status == RJD_RESOURCE_STATUS_LOAD_END;
}

void* rjd_resource_get(struct rjd_resource_lib* lib, struct rjd_resource_handle handle)
{
	RJD_ASSERT(lib);

	struct rjd_resource* resource = rjd_slotmap_get(lib->resources, handle.slot);
	if (resource && resource->status == RJD_RESOURCE_STATUS_READY) {
		return resource->typed_resource_data;
	}
	return NULL;
}

void rjd_resource_unload(struct rjd_resource_lib* lib, struct rjd_resource_handle handle)
{
	RJD_ASSERT(lib);

	struct rjd_resource* resource = rjd_slotmap_get(lib->resources, handle.slot);
	if (resource) {
		--resource->refcount;
		if (resource->refcount == 0) {
			rjd_array_push(lib->unload_queue, handle);
			for (uint32_t i = 0; i < rjd_array_count(resource->dependencies); ++i) {
				rjd_resource_unload(lib, resource->dependencies[i]);
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
// private implementation

static struct rjd_result rjd_resource_add_dependency(struct rjd_resource_load_dependency_params* params, struct rjd_resource_id id, struct rjd_resource_handle* child)
{
	RJD_ASSERT(params);

	struct rjd_resource* parent = rjd_slotmap_get(params->lib->resources, params->parent.slot);
	RJD_ASSERT(parent);

	struct rjd_result result = rjd_resource_load(params->lib, id, child);
	if (rjd_result_isok(result)) {
        if (parent->dependencies == NULL) {
            parent->dependencies = rjd_array_alloc(struct rjd_resource_handle, 8, params->lib->allocator);
        }
		rjd_array_push(parent->dependencies, *child);
	}

	return result;
}

static struct rjd_resource_dependency rjd_resource_get_dependency(struct rjd_resource_get_dependency_params* params, struct rjd_resource_handle handle)
{
	struct rjd_resource_lib* lib = (struct rjd_resource_lib*)params;
    enum rjd_resource_status status = rjd_resource_lib_status(lib, handle);
	void* typed_resource_data = rjd_resource_get(lib, handle);
    
    struct rjd_resource_dependency dependency = {
        .status = status,
        .typed_resource_data = typed_resource_data,
    };
    return dependency;
}

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_window.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_WINDOW_H 1

struct rjd_window;
struct rjd_window_environment;

typedef void rjd_window_environment_init_func(const struct rjd_window_environment* env);
typedef void rjd_window_environment_close_func(const struct rjd_window_environment* env);
typedef void rjd_window_on_init_func(struct rjd_window* window, const struct rjd_window_environment* env);
typedef bool rjd_window_on_update_func(struct rjd_window* window, const struct rjd_window_environment* env);
typedef void rjd_window_on_close_func(struct rjd_window* window, const struct rjd_window_environment* env);

// Note that we use void* instead of the win32 types HINSTANCE and HWND to avoid taking a dependency 
// on a windows header.

struct rjd_window_data_win32
{
#if RJD_PLATFORM_WINDOWS
	void* hinstance; // HINSTANCE
#else
	char unused;
#endif
};

struct rjd_window_environment
{
	void* userdata;
	const char** argv;
	int argc;

	struct rjd_window_data_win32 win32;
};

struct rjd_window_size
{
	uint16_t width;
	uint16_t height;
};

struct rjd_window_desc
{
    const char* title;
	struct rjd_window_size requested_size;
    struct rjd_window_environment env;
    
    rjd_window_on_init_func* init_func;
    rjd_window_on_update_func* update_func;
    rjd_window_on_close_func* close_func;
};

struct rjd_window
{
	char impl[64];
};

void rjd_window_enter_windowed_environment(struct rjd_window_environment env, rjd_window_environment_init_func* init_func, rjd_window_environment_close_func* close_func);
struct rjd_result rjd_window_create(struct rjd_window* out, struct rjd_window_desc desc);
void rjd_window_runloop(struct rjd_window* window);
struct rjd_window_size rjd_window_size_get(const struct rjd_window* window);
void rjd_window_close(struct rjd_window* window);

#if RJD_PLATFORM_WINDOWS
	void* rjd_window_win32_get_hwnd(const struct rjd_window* window);
#elif RJD_PLATFORM_OSX
	#if RJD_LANG_OBJC
		@class MTKView;
		RJD_STATIC_ASSERT(sizeof(MTKView*) == sizeof(void*));
		@class BasicView;
		RJD_STATIC_ASSERT(sizeof(BasicView*) == sizeof(void*));
		@class NSWindow;
		RJD_STATIC_ASSERT(sizeof(NSWindow*) == sizeof(void*));
	#else
		typedef void MTKView;
		typedef void BasicView;
		typedef void NSWindow;
	#endif
	MTKView* rjd_window_osx_get_mtkview(const struct rjd_window* window);
	BasicView* rjd_window_osx_get_basicview(const struct rjd_window* window);
	NSWindow* rjd_window_osx_get_nswindow(const struct rjd_window* window);
#endif

////////////////////////////////////////////////////////////////////////////////
// implementation

#if RJD_IMPL

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// windows os

static struct rjd_atomic_uint32 global_window_count = {0};

#if RJD_PLATFORM_WINDOWS


struct rjd_window_win32
{
	struct rjd_window_environment env;
	rjd_window_on_init_func* init_func;
	rjd_window_on_update_func* update_func;
	rjd_window_on_close_func* close_func;
	void* hwnd; // HWND
};
RJD_STATIC_ASSERT(sizeof(struct rjd_window) >= sizeof(struct rjd_window_win32));

static LRESULT CALLBACK WindowProc(HWND handle_window, UINT msg, WPARAM wparam, LPARAM lparam);

void rjd_window_enter_windowed_environment(struct rjd_window_environment env, rjd_window_environment_init_func* init_func, rjd_window_environment_close_func* close_func)
{
	if (init_func) {
		init_func(&env);
	}

	while (rjd_atomic_uint32_get(&global_window_count) > 0)
	{
		// other threads could be running their own window loops, so just wait until
		// all of them are closed before exiting
	}

	if (close_func) {
		close_func(&env);
	}
}

struct rjd_result rjd_window_create(struct rjd_window* out, struct rjd_window_desc desc)
{
	if (desc.title == NULL) {
		desc.title = "";
	}

	static bool s_did_register_window_class = false;
	if (!s_did_register_window_class) {
		s_did_register_window_class = true;

		WNDCLASSEX window_class = { 0 };
		window_class.cbSize = sizeof(WNDCLASSEX);
		window_class.style = CS_HREDRAW | CS_VREDRAW;
		window_class.lpfnWndProc = WindowProc;
		window_class.hInstance = desc.env.win32.hinstance;
		window_class.lpszClassName = "rjd_window_class";
		window_class.hCursor = LoadCursor(NULL, IDC_ARROW);
		//window_class.hIcon = LoadImage(NULL, IDI_APPLICATION, IMAGE_ICON, 0, 0, LR_DEFAULTSIZE | LR_SHARED);
		if (!RegisterClassEx(&window_class))
		{
			return RJD_RESULT("Failed to create window class");
		}
	}

	const DWORD window_style = WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_SYSMENU;
	RECT window_rect = {0, 0, desc.requested_size.width, desc.requested_size.height};
	if (!AdjustWindowRect(&window_rect, window_style, FALSE))
	{
		return RJD_RESULT("Failed to adjust window rect");
	} 

	HWND hwnd = CreateWindowEx(0,
		"rjd_window_class",
		desc.title,
		window_style, 
		1024, 80,
		window_rect.right - window_rect.left, window_rect.bottom - window_rect.top,
		NULL,
		NULL,
		desc.env.win32.hinstance,
		NULL);
	if (!hwnd)
	{
		return RJD_RESULT("Failed to create window from class");
	}

	struct rjd_window_win32* window_win32 = (struct rjd_window_win32*)out;
	window_win32->env = desc.env;
	window_win32->init_func = desc.init_func;
	window_win32->update_func = desc.update_func;
	window_win32->close_func = desc.close_func;
	window_win32->hwnd = hwnd;	

	return RJD_RESULT_OK();
}

void rjd_window_runloop(struct rjd_window* window)
{
	rjd_atomic_uint32_inc(&global_window_count);

	struct rjd_window_win32* window_win32 = (struct rjd_window_win32*)window;
	if (window_win32->init_func) {
		window_win32->init_func(window, &window_win32->env);
	}

	// TODO support running multiple windows in the same thread?
	bool running = true;
	while (running)
	{
		MSG msg = {0};
		while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);

			if (msg.message == WM_QUIT)
			{
				running = false;
			}
		}

		if (running && window_win32->update_func) {
			running = window_win32->update_func(window, &window_win32->env);
		}
	}

	if (window_win32->close_func) {
		window_win32->close_func(window, &window_win32->env);
	}

	if (IsWindow(window_win32->hwnd)) {
		DestroyWindow(window_win32->hwnd);
	}

	rjd_atomic_uint32_dec(&global_window_count);
}

struct rjd_window_size rjd_window_size_get(const struct rjd_window* window)
{
	struct rjd_window_win32* window_win32 = (struct rjd_window_win32*)window;

	RECT rect = {0};
	GetClientRect(window_win32->hwnd, &rect);

	uint32_t width = rect.right - rect.left;
	uint32_t height = rect.bottom - rect.top;

	RJD_ASSERT(width <= UINT16_MAX);
	RJD_ASSERT(height <= UINT16_MAX);

	struct rjd_window_size size = 
	{
		.width = (uint16_t)width,
		.height = (uint16_t)height,
	};
	return size;
}

void rjd_window_close(struct rjd_window* window)
{
	struct rjd_window_win32* window_win32 = (struct rjd_window_win32*)window;
	PostMessageA(window_win32->hwnd, WM_CLOSE, 0, 0);
}

void* rjd_window_win32_get_hwnd(const struct rjd_window* window)
{
	struct rjd_window_win32* window_win32 = (struct rjd_window_win32*)window;
	return window_win32->hwnd;
}

////////////////////////////////////////////////////////////////////////////////
// Local helpers

LRESULT CALLBACK WindowProc(HWND handle_window, UINT msg, WPARAM wparam, LPARAM lparam)
{
    const POINT kMinSize = {1, 1};
    switch (msg)
    {
	case WM_CLOSE:
		PostQuitMessage(0);
		break;
    case WM_GETMINMAXINFO:
        ((MINMAXINFO*)lparam)->ptMinTrackSize = kMinSize;
        return 0;

	// TODO forward resize message
    //case WM_SIZE:
	//	//width = LOWORD(lparam);
	//	//height = HIWORD(lparam);
	//	//glViewport(0, 0, g_window_size.width, g_window_size.height);
    //    break;
    default:
    	return DefWindowProc(handle_window, msg, wparam, lparam);
    }

    return 0;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// osx os

#elif RJD_PLATFORM_OSX

#if !RJD_LANG_OBJC
    #error "rjd_window.h must be implemented in a .m file on OSX"
#endif

#import <Cocoa/Cocoa.h>
#import <Carbon/Carbon.h>
#import <MetalKit/MetalKit.h>

struct rjd_window_osx
{
    NSWindow* nswindow;
    MTKView* view_metal;
    BasicView* view_basic;
    
    rjd_window_on_init_func* init_func;
    rjd_window_on_update_func* update_func;
    rjd_window_on_close_func* close_func;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_window) >= sizeof(struct rjd_window_osx));

bool s_is_app_initialized = false;

@interface AppDelegate : NSObject <NSApplicationDelegate>
@property (retain) NSWindow *window;
-(instancetype)initWithEnvFunc:(rjd_window_environment_init_func*)init_func closeFunc:(rjd_window_environment_close_func*)close_func env:(struct rjd_window_environment)env;
@end

@interface CustomViewController : NSViewController
-(instancetype)initWithWidth:(uint16_t)width height:(uint16_t)height window:(struct rjd_window*)window env:(struct rjd_window_environment)env;
@end

@interface CustomWindow : NSWindow
@end

@interface Renderer : NSObject <MTKViewDelegate>
-(instancetype)initWithWindow:(struct rjd_window*)window env:(struct rjd_window_environment)env;
@end

@interface BasicView : NSView
@end

@interface BasicWindowDelegate : NSObject <NSWindowDelegate>
-(instancetype)initWithWindow:(struct rjd_window*)window env:(struct rjd_window_environment)env;
@end

////////////////////////////////////////////////////////////////////////////////
// interface implementation

void rjd_window_enter_windowed_environment(struct rjd_window_environment env, rjd_window_environment_init_func* init_func, rjd_window_environment_close_func* close_func)
{
	NSApplicationLoad();
    AppDelegate* delegate = [[AppDelegate alloc] initWithEnvFunc:init_func closeFunc:close_func env:env];
    NSApplication* app = [NSApplication sharedApplication];
    [app setDelegate:delegate];
	[app activateIgnoringOtherApps:YES];
    
    // The applicationDidFinishLaunching notification isn't sent multiple times. We need to keep track
    // to ensure the init_func() is called upon reentry to this function
    if (s_is_app_initialized && init_func) {
        init_func(&env);
    }
    [app run];
    if (close_func) {
    	close_func(&env);
    }
}

struct rjd_result rjd_window_create(struct rjd_window* out, struct rjd_window_desc desc)
{
    if (desc.title == NULL) {
        desc.title = "";
    }
    
    NSRect rect = {0};
    rect.size.height = 320;
    rect.size.width = 480;
    
    NSWindowStyleMask style =   NSWindowStyleMaskResizable |
                                NSWindowStyleMaskTitled    |
                                NSWindowStyleMaskClosable  |
                                NSWindowStyleMaskMiniaturizable;

    NSWindow* nswindow = [[CustomWindow alloc] initWithContentRect:rect styleMask:style backing:NSBackingStoreBuffered defer:false];
    nswindow.title = [NSString stringWithUTF8String:desc.title];
    
    struct rjd_window_size size = desc.requested_size;

    CustomViewController* viewController = [[CustomViewController alloc]
                                          initWithWidth:size.width height:size.height window:out env:desc.env];
    MTKView* view = [[MTKView alloc] initWithFrame:rect device:MTLCreateSystemDefaultDevice()];

    viewController.view = view;
    [viewController loadView];
    nswindow.contentViewController = viewController;

	RJD_ASSERT(nswindow.canBecomeKeyWindow == YES);
	RJD_ASSERT(nswindow.canBecomeMainWindow == YES);
    [nswindow makeKeyAndOrderFront:nil];

	rjd_atomic_uint32_inc(&global_window_count);

    struct rjd_window_osx* window_osx = (struct rjd_window_osx*)out;
    window_osx->nswindow = nswindow;
    window_osx->init_func = desc.init_func;
    window_osx->update_func = desc.update_func;
    window_osx->close_func = desc.close_func;
    window_osx->view_metal = view.device != nil ? view : NULL;
	window_osx->view_basic = view.device == nil ? (BasicView*)viewController.view : NULL;

    if (window_osx->init_func) {
        window_osx->init_func((struct rjd_window*)window_osx, &desc.env);
    }

    return RJD_RESULT_OK();
}

void rjd_window_runloop(struct rjd_window* window)
{
	// no-op since OSX is event driven
	RJD_UNUSED_PARAM(window);
}

struct rjd_window_size rjd_window_size_get(const struct rjd_window* window)
{
	const struct rjd_window_osx* window_osx = (const struct rjd_window_osx*)window;

	CGSize size = window_osx->view_metal ? window_osx->view_metal.drawableSize : window_osx->view_basic.bounds.size;

	struct rjd_window_size windowsize = {
		.width = size.width,
		.height = size.height,
	};
	return windowsize;
}

void rjd_window_close(struct rjd_window* window)
{
	const struct rjd_window_osx* window_osx = (const struct rjd_window_osx*)window;
	[window_osx->nswindow close];
	rjd_atomic_uint32_dec(&global_window_count);
}

MTKView* rjd_window_osx_get_mtkview(const struct rjd_window* window)
{
    const struct rjd_window_osx* window_osx = (const struct rjd_window_osx*)window;
	return window_osx->view_metal;
}

BasicView* rjd_window_osx_get_basicview(const struct rjd_window* window)
{
    const struct rjd_window_osx* window_osx = (const struct rjd_window_osx*)window;
	return window_osx->view_basic;
}

NSWindow* rjd_window_osx_get_nswindow(const struct rjd_window* window)
{
    const struct rjd_window_osx* window_osx = (const struct rjd_window_osx*)window;
	return window_osx->nswindow;
}

////////////////////////////////////////////////////////////////////////////////
// local helpers

@implementation AppDelegate
{
    rjd_window_environment_init_func* init_func;
    rjd_window_environment_close_func* close_func;
	struct rjd_window_environment env;
}

-(instancetype)initWithEnvFunc:(rjd_window_environment_init_func*)_init_func closeFunc:(rjd_window_environment_close_func*)_close_func env:(struct rjd_window_environment)_env
{
    if (self = [super init]) {
        self->init_func = _init_func;
        self->close_func = _close_func;
		self->env = _env;
    }
    return self;
}

-(void)applicationDidFinishLaunching:(NSNotification*)notification
{
	RJD_UNUSED_PARAM(notification);
    
    NSMenuItem* testItem = [[NSMenuItem alloc] initWithTitle:@"TestItem" action:nil keyEquivalent:@""];

    NSMenu* menu = [[NSMenu alloc] initWithTitle:@"TestMenu"];
    [menu addItem:testItem];
    NSApplication.sharedApplication.mainMenu = menu;
    
    s_is_app_initialized = true;

	if (self->init_func) {
		self->init_func(&self->env);
	}
}

-(BOOL)applicationShouldTerminateAfterLastWindowClosed:(NSApplication*)sender
{
	RJD_UNUSED_PARAM(sender);
    
	// The NSApplication event loop will only check the stop flag *after* it handles an event.
    [sender stop:nil];
	NSEvent* force_handler_event = [NSEvent otherEventWithType:NSEventTypeApplicationDefined
                  location:NSZeroPoint
             modifierFlags:0
                 timestamp:0
              windowNumber:0
                   context:nil
                   subtype:0
                     data1:0
                     data2:0];
    [NSApp postEvent:force_handler_event atStart:TRUE];

    return NO;
}

@end

@implementation CustomViewController
{
    Renderer* renderer;
	BasicWindowDelegate* basic_delegate;

    uint16_t width;
    uint16_t height;
    struct rjd_window* window;
    struct rjd_window_environment env;
}

-(instancetype)initWithWidth:(uint16_t)_width height:(uint16_t)_height window:(struct rjd_window*)_window env:(struct rjd_window_environment)_env
{
    if (self = [super init]) {
        self->width = _width;
        self->height = _height;
        self->window = _window;
        self->env = _env;
    }
    return self;
}

-(void)loadView
{
    MTKView* view = (MTKView*)self.view;
    if(view.device) {
	    // We need to hold a strong reference to the Renderer or it will go out of scope
	    // after this function and be destroyed. MTKView.delegate is a weak reference.
	    self->renderer = [[Renderer alloc] initWithWindow:self->window env:self->env];
	    [self->renderer mtkView:view drawableSizeWillChange:view.bounds.size];
	    view.delegate = self->renderer;
	    self.view = view;
	} else {
        NSLog(@"Metal is not supported on this device. Falling back to basic NSView with timer updates.");
		self->basic_delegate = [[BasicWindowDelegate alloc] initWithWindow:window env:self->env];
       	BasicView* view = [[BasicView alloc] initWithFrame:self.view.frame];
		self.view = view;
    }
}
@end

@implementation CustomWindow
{
}

-(BOOL)canBecomeMainWindow
{
	return YES;
}

-(BOOL)canBecomeKeyWindow
{
	return YES;
}
@end

@implementation Renderer
{
	struct rjd_window* window;
	struct rjd_window_environment env;
}

-(instancetype)initWithWindow:(struct rjd_window*)_window env:(struct rjd_window_environment)_env
{
	if (self = [super init]) {
		self->window = _window;
		self->env = _env;
        
        struct rjd_window_osx* window_osx = (struct rjd_window_osx*)window;

        [[NSNotificationCenter defaultCenter]    addObserver:self
                                                selector:@selector(windowWillClose:)
                                                name:NSWindowWillCloseNotification
                                                object:window_osx->nswindow];
	}
    
    return self;
}

-(void)drawInMTKView:(MTKView*)view
{
	RJD_UNUSED_PARAM(view);

    struct rjd_window_osx* window_osx = (struct rjd_window_osx*)self->window;
	if (window_osx->update_func) {
		if (window_osx->update_func(self->window, &self->env) == false) {
			rjd_window_close(self->window);
		}
	}
}

-(void)windowWillClose:(NSNotification*)notification
{
	RJD_UNUSED_PARAM(notification);

    struct rjd_window_osx* window_osx = (struct rjd_window_osx*)window;

    [[NSNotificationCenter defaultCenter] removeObserver:self name:NSWindowWillCloseNotification object:window_osx->nswindow];

    if (window_osx->close_func) {
        window_osx->close_func(self->window, &self->env);
    }
}

-(void)mtkView:(MTKView*)view drawableSizeWillChange:(CGSize)size
{
	RJD_UNUSED_PARAM(view);
	RJD_UNUSED_PARAM(size);
}
@end

@implementation BasicView
@end

@implementation BasicWindowDelegate
{
	struct rjd_window* window;
	struct rjd_window_environment env;

	NSTimer* ticker;
}

-(instancetype)initWithWindow:(struct rjd_window*)_window env:(struct rjd_window_environment)_env
{
	self->window = _window;
	self->env = _env;

	struct rjd_window_osx* window_osx = (struct rjd_window_osx*)self->window;

	[[NSNotificationCenter defaultCenter]	addObserver:self
											selector:@selector(windowWillClose:)
											name:NSWindowWillCloseNotification
											object:window_osx->nswindow];


	void (^update_tick_block)(NSTimer*) = ^void(NSTimer* timer) {
		[self timerUpdate:timer];
	};

	self->ticker = [NSTimer scheduledTimerWithTimeInterval:1.0/60.0 repeats:YES block:update_tick_block];

	return self;
}

-(void)timerUpdate:(NSTimer*)timer
{
	RJD_UNUSED_PARAM(timer);

	struct rjd_window_osx* window_osx = (struct rjd_window_osx*)self->window;
	if (window_osx->update_func) {
		if (window_osx->update_func(self->window, &self->env) == false) {
			rjd_window_close(self->window);
		}
	}
}

-(void)windowWillClose:(NSNotification*)notification
{
	RJD_UNUSED_PARAM(notification);

    struct rjd_window_osx* window_osx = (struct rjd_window_osx*)window;

    [[NSNotificationCenter defaultCenter] removeObserver:self name:NSWindowWillCloseNotification object:window_osx->nswindow];

    if (window_osx->close_func) {
        window_osx->close_func(self->window, &self->env);
    }
    
	[self->ticker invalidate];
    self->ticker = nil;
}

@end

#else
	#error Unsupported platform.
#endif

#endif // RJD_IMPL


////////////////////////////////////////////////////////////////////////////////
// rjd_input.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_INPUT_H 1

struct rjd_input
{
	char impl[1024];
};

enum rjd_input_keyboard
{
	RJD_INPUT_KEYBOARD_CONTROL_LEFT,
	RJD_INPUT_KEYBOARD_CONTROL_RIGHT,
	RJD_INPUT_KEYBOARD_SHIFT_LEFT,
	RJD_INPUT_KEYBOARD_SHIFT_RIGHT,
	RJD_INPUT_KEYBOARD_OPTION_LEFT, // OSX only
	RJD_INPUT_KEYBOARD_OPTION_RIGHT, // OSX only
	RJD_INPUT_KEYBOARD_COMMAND_LEFT, // OSX only
	RJD_INPUT_KEYBOARD_COMMAND_RIGHT, // OSX only
	RJD_INPUT_KEYBOARD_ALT_LEFT, // Windows only
	RJD_INPUT_KEYBOARD_ALT_RIGHT, // Windows only
	RJD_INPUT_KEYBOARD_HOME,
	RJD_INPUT_KEYBOARD_END,
	RJD_INPUT_KEYBOARD_DELETE,
	RJD_INPUT_KEYBOARD_BACKSPACE, // TODO OSX
	RJD_INPUT_KEYBOARD_PAGEUP,
	RJD_INPUT_KEYBOARD_PAGEDOWN,
    RJD_INPUT_KEYBOARD_RETURN,
	RJD_INPUT_KEYBOARD_ESCAPE,
	RJD_INPUT_KEYBOARD_PAUSE, // TODO OSX
	RJD_INPUT_KEYBOARD_CAPSLOCK, // TODO OSX
	RJD_INPUT_KEYBOARD_PRINTSCREEN, // TODO OSX
	RJD_INPUT_KEYBOARD_INSERT, // TODO OSX
	RJD_INPUT_KEYBOARD_ARROW_LEFT,
	RJD_INPUT_KEYBOARD_ARROW_RIGHT,
	RJD_INPUT_KEYBOARD_ARROW_UP,
	RJD_INPUT_KEYBOARD_ARROW_DOWN,
	RJD_INPUT_KEYBOARD_NUMPAD_0,
	RJD_INPUT_KEYBOARD_NUMPAD_END = RJD_INPUT_KEYBOARD_NUMPAD_0 + 9,
	RJD_INPUT_KEYBOARD_FUNCTION_0,
	RJD_INPUT_KEYBOARD_FUNCTION_END = RJD_INPUT_KEYBOARD_FUNCTION_0 + 15,
	RJD_INPUT_KEYBOARD_ASCII_BEGIN,
	RJD_INPUT_KEYBOARD_ASCII_END = RJD_INPUT_KEYBOARD_ASCII_BEGIN + 127,
	RJD_INPUT_KEYBOARD_COUNT,
};

enum
{
	RJD_INPUT_MOUSE_MAX_BUTTONS = 16,
};

enum rjd_input_mouse
{
	RJD_INPUT_MOUSE_X,
	RJD_INPUT_MOUSE_Y,
	RJD_INPUT_MOUSE_SCROLLWHEEL_DELTA_X,
	RJD_INPUT_MOUSE_SCROLLWHEEL_DELTA_Y,
	RJD_INPUT_MOUSE_BUTTON_BEGIN, // Add the index of the desired button to this value
	RJD_INPUT_MOUSE_BUTTON_END = RJD_INPUT_MOUSE_BUTTON_BEGIN + RJD_INPUT_MOUSE_MAX_BUTTONS,
	RJD_INPUT_MOUSE_COUNT,

	// Convenience values
	RJD_INPUT_MOUSE_BUTTON_LEFT = RJD_INPUT_MOUSE_BUTTON_BEGIN,
	RJD_INPUT_MOUSE_BUTTON_RIGHT
};

enum rjd_input_sim_type
{
	RJD_INPUT_SIM_TYPE_KEYBOARD,
	RJD_INPUT_SIM_TYPE_MOUSE,
};

struct rjd_input_sim_event
{
	enum rjd_input_sim_type type;
	union
	{
		struct
		{
			enum rjd_input_keyboard key;
			bool is_down;
		} keyboard;

		struct 
		{
			enum rjd_input_mouse button;
			float value;
		} mouse;
	};
};

// TODO could add support for controllers, joysticks, driving wheels, etc
// TODO debug record/replay

void rjd_input_create(struct rjd_input* out, struct rjd_mem_allocator* allocator);
void rjd_input_destroy(struct rjd_input* input);
struct rjd_result rjd_input_hook(struct rjd_input* input, const struct rjd_window* window, const struct rjd_window_environment* env);
void rjd_input_unhook(struct rjd_input* input);
void rjd_input_markframe(struct rjd_input* input);

bool rjd_input_keyboard_now(const struct rjd_input* input, enum rjd_input_keyboard code);
bool rjd_input_keyboard_prev(const struct rjd_input* input, enum rjd_input_keyboard code);

float rjd_input_mouse_now(const struct rjd_input* input, enum rjd_input_mouse code);
float rjd_input_mouse_prev(const struct rjd_input* input, enum rjd_input_mouse code);

static inline bool rjd_input_keyboard_triggered(const struct rjd_input* input, enum rjd_input_keyboard code); // key was pressed starting this frame
static inline bool rjd_input_mouse_triggered(const struct rjd_input* input, enum rjd_input_mouse code); // button was pressed starting this frame

void rjd_input_simulate(struct rjd_input* input, struct rjd_input_sim_event event);

const char* rjd_input_keyboard_tostring(enum rjd_input_keyboard code);

////////////////////////////////////////////////////////////////////////////////
// Inline implementation

static inline bool rjd_input_keyboard_triggered(const struct rjd_input* input, enum rjd_input_keyboard code)
{
	return rjd_input_keyboard_now(input, code) && !rjd_input_keyboard_prev(input, code);
}

static inline bool rjd_input_mouse_triggered(const struct rjd_input* input, enum rjd_input_mouse code)
{
	return rjd_input_mouse_now(input, code) && !rjd_input_mouse_prev(input, code);
}

#if RJD_IMPL

////////////////////////////////////////////////////////////////////////////////
// platform-independent impl

struct rjd_input_keyboard_state
{
	uint8_t values[RJD_INPUT_KEYBOARD_COUNT];
};

struct rjd_input_mouse_state
{
	float values[RJD_INPUT_MOUSE_MAX_BUTTONS];
};

struct rjd_input_common
{
	struct rjd_input_keyboard_state keyboard[2];
	struct rjd_input_mouse_state mouse[2];
	uint8_t now_index;
};

const char* RJD_INPUT_KEYBOARD_STRINGS[] =
{
	"RJD_INPUT_KEYBOARD_CONTROL_LEFT",
	"RJD_INPUT_KEYBOARD_CONTROL_RIGHT",
	"RJD_INPUT_KEYBOARD_SHIFT_LEFT",
	"RJD_INPUT_KEYBOARD_SHIFT_RIGHT",
	"RJD_INPUT_KEYBOARD_OPTION_LEFT", // OSX only
	"RJD_INPUT_KEYBOARD_OPTION_RIGHT", // OSX only
	"RJD_INPUT_KEYBOARD_COMMAND_LEFT", // OSX only
	"RJD_INPUT_KEYBOARD_COMMAND_RIGHT", // OSX only
	"RJD_INPUT_KEYBOARD_ALT_LEFT", // Windows only
	"RJD_INPUT_KEYBOARD_ALT_RIGHT", // Windows only
	"RJD_INPUT_KEYBOARD_HOME",
	"RJD_INPUT_KEYBOARD_END",
	"RJD_INPUT_KEYBOARD_DELETE",
	"RJD_INPUT_KEYBOARD_BACKSPACE",
	"RJD_INPUT_KEYBOARD_PAGEUP",
	"RJD_INPUT_KEYBOARD_PAGEDOWN",
    "RJD_INPUT_KEYBOARD_RETURN",
	"RJD_INPUT_KEYBOARD_ESCAPE",
	"RJD_INPUT_KEYBOARD_PAUSE",
	"RJD_INPUT_KEYBOARD_CAPSLOCK",
	"RJD_INPUT_KEYBOARD_PRINTSCREEN",
	"RJD_INPUT_KEYBOARD_INSERT",
	"RJD_INPUT_KEYBOARD_ARROW_LEFT",
	"RJD_INPUT_KEYBOARD_ARROW_RIGHT",
	"RJD_INPUT_KEYBOARD_ARROW_UP",
	"RJD_INPUT_KEYBOARD_ARROW_DOWN",
	"RJD_INPUT_KEYBOARD_NUMPAD_0",
	"RJD_INPUT_KEYBOARD_NUMPAD_1",
	"RJD_INPUT_KEYBOARD_NUMPAD_2",
	"RJD_INPUT_KEYBOARD_NUMPAD_3",
	"RJD_INPUT_KEYBOARD_NUMPAD_4",
	"RJD_INPUT_KEYBOARD_NUMPAD_5",
	"RJD_INPUT_KEYBOARD_NUMPAD_6",
	"RJD_INPUT_KEYBOARD_NUMPAD_7",
	"RJD_INPUT_KEYBOARD_NUMPAD_8",
	"RJD_INPUT_KEYBOARD_NUMPAD_9",
	"RJD_INPUT_KEYBOARD_FUNCTION_0",
	"RJD_INPUT_KEYBOARD_FUNCTION_1",
	"RJD_INPUT_KEYBOARD_FUNCTION_2",
	"RJD_INPUT_KEYBOARD_FUNCTION_3",
	"RJD_INPUT_KEYBOARD_FUNCTION_4",
	"RJD_INPUT_KEYBOARD_FUNCTION_5",
	"RJD_INPUT_KEYBOARD_FUNCTION_6",
	"RJD_INPUT_KEYBOARD_FUNCTION_7",
	"RJD_INPUT_KEYBOARD_FUNCTION_8",
	"RJD_INPUT_KEYBOARD_FUNCTION_9",
	"RJD_INPUT_KEYBOARD_FUNCTION_10",
	"RJD_INPUT_KEYBOARD_FUNCTION_11",
	"RJD_INPUT_KEYBOARD_FUNCTION_12",
	"RJD_INPUT_KEYBOARD_FUNCTION_13",
	"RJD_INPUT_KEYBOARD_FUNCTION_14",
	"RJD_INPUT_KEYBOARD_FUNCTION_15",
	"NUL",
	"SOH",
	"STX",
	"ETX",
	"EOT",
	"ENQ",
	"ACK",
	"BEL",
	"BS",
	"HT",
	"LF",
	"VT",
	"FF",
	"CR",
	"SO",
	"SI",
	"DLE",
	"DC1",
	"DC2",
	"DC3",
	"DC4",
	"NAK",
	"SYN",
	"ETB",
	"CAN",
	"EM",
	"SUB",
	"ESC",
	"FS",
	"GS",
	"RS",
	"US",
	"space",
	"!",
	",",
	"#",
	"$",
	"%",
	"&",
	"'",
	"(",
	")",
	"*",
	"+",
	",",
	"-",
	".",
	"/",
	"0",
	"1",
	"2",
	"3",
	"4",
	"5",
	"6",
	"7",
	"8",
	"9",
	":",
	";",
	"<",
	"=",
	">",
	"?",
	"@",
	"A",
	"B",
	"C",
	"D",
	"E",
	"F",
	"G",
	"H",
	"I",
	"J",
	"K",
	"L",
	"M",
	"N",
	"O",
	"P",
	"Q",
	"R",
	"S",
	"T",
	"U",
	"V",
	"W",
	"X",
	"Y",
	"Z",
	"[",
	"\\",
	"]",
	"^",
	"_",
	"`",
	"a",
	"b",
	"c",
	"d",
	"e",
	"f",
	"g",
	"h",
	"i",
	"j",
	"k",
	"l",
	"m",
	"n",
	"o",
	"p",
	"q",
	"r",
	"s",
	"t",
	"u",
	"v",
	"w",
	"x",
	"y",
	"z",
	"{",
	"|",
	"}",
	"~",
	"DEL",
};

RJD_STATIC_ASSERT(rjd_countof(RJD_INPUT_KEYBOARD_STRINGS) == RJD_INPUT_KEYBOARD_COUNT);

const char* rjd_input_keyboard_tostring(enum rjd_input_keyboard code)
{
	if (code < rjd_countof(RJD_INPUT_KEYBOARD_STRINGS)) {
		return RJD_INPUT_KEYBOARD_STRINGS[code];
	}
	return NULL;
}

void rjd_input_markframe_common(struct rjd_input_common* input)
{
	RJD_ASSERT(input);

	uint32_t prev_index = input->now_index;
	input->now_index = (input->now_index + 1) % 2;

	memcpy(input->keyboard + input->now_index, input->keyboard + prev_index, sizeof(*input->keyboard));
	memcpy(input->mouse + input->now_index, input->mouse + prev_index, sizeof(*input->mouse));

	struct rjd_input_mouse_state* mouse_now = input->mouse + input->now_index;
	mouse_now->values[RJD_INPUT_MOUSE_SCROLLWHEEL_DELTA_X] = 0;
	mouse_now->values[RJD_INPUT_MOUSE_SCROLLWHEEL_DELTA_Y] = 0;
}

bool rjd_input_keyboard_now_common(const struct rjd_input_common* input, enum rjd_input_keyboard code)
{
	RJD_ASSERT(input);

	const struct rjd_input_keyboard_state* state = input->keyboard + input->now_index;
	RJD_ASSERT(code < rjd_countof(state->values));
	bool value = state->values[code];
	return value;
}

bool rjd_input_keyboard_prev_common(const struct rjd_input_common* input, enum rjd_input_keyboard code)
{
	RJD_ASSERT(input);

	uint32_t prev_index = (input->now_index + 1) % 2;
	const struct rjd_input_keyboard_state* state = input->keyboard + prev_index;
	RJD_ASSERT(code < rjd_countof(state->values));
	bool value = state->values[code];
	return value;
}

float rjd_input_mouse_now_common(const struct rjd_input_common* input, enum rjd_input_mouse code)
{
	RJD_ASSERT(input);

	const struct rjd_input_mouse_state* state = input->mouse + input->now_index;
	RJD_ASSERT(code < rjd_countof(state->values));
	float value = state->values[code];
	return value;
}

float rjd_input_mouse_prev_common(const struct rjd_input_common* input, enum rjd_input_mouse code)
{
	RJD_ASSERT(input);

	uint32_t prev_index = (input->now_index + 1) % 2;
	const struct rjd_input_mouse_state* state = input->mouse + prev_index;
	RJD_ASSERT(code < rjd_countof(state->values));
	float value = state->values[code];
	return value;
}

#if RJD_PLATFORM_WINDOWS

#define WIN32_LEAN_AND_MEAN
#define WIN32_EXTRA_LEAN
#define NOMINMAX
#include <windows.h>
#include <windowsx.h> // GET_X_LPARAM, GET_Y_LPARAM

struct rjd_input_win32
{
	const struct rjd_window* window;

	HHOOK hook_handle_wndproc;
	HHOOK hook_handle_getmessage;

	struct rjd_input_common common;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_input_win32) <= sizeof(struct rjd_input));

enum
{
	RJD_INPUT_WIN32_WINDOW_PTR_INDEX = GWLP_USERDATA,
};

LRESULT CALLBACK rjd_input_wndproc_hook(int nCode, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK rjd_input_getmessage_hook(int nCode, WPARAM wParam, LPARAM lParam);
LRESULT rjd_input_hook_common(struct rjd_input_win32* input_win32, UINT message, WPARAM wParam, LPARAM lParam, int nCode, WPARAM hook_wparam, LPARAM hook_lparam);

const enum rjd_input_keyboard RJD_INPUT_WIN32_KEYCODE_TO_ENUM[] =
{
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x00 invalid
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x01 VK_LBUTTON
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x02 VK_RBUTTON
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x03 VK_CANCEL
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x04 VK_MBUTTON
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x05 VK_XBUTTON1
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x06 VK_XBUTTON2
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x07 reserved
	RJD_INPUT_KEYBOARD_BACKSPACE,			// 0x08 VK_BACK
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '	',	// 0x09 VK_TAB
	RJD_INPUT_KEYBOARD_COUNT,				// 0x0A undefined
	RJD_INPUT_KEYBOARD_COUNT,				// 0x0B undefined
	RJD_INPUT_KEYBOARD_COUNT,				// 0x0C VK_CLEAR
	RJD_INPUT_KEYBOARD_RETURN,				// 0x0D VK_RETURN
	RJD_INPUT_KEYBOARD_COUNT,				// 0x0E undefined
	RJD_INPUT_KEYBOARD_COUNT,				// 0x0F undefined
	RJD_INPUT_KEYBOARD_COUNT,				// 0x10 VK_SHIFT (but we use L and R versions)
	RJD_INPUT_KEYBOARD_COUNT,				// 0x11 VK_CONTROL (but we use L and R versions)
	RJD_INPUT_KEYBOARD_COUNT,				// 0x12 VK_MENU (alt, but we use L and R versions)
	RJD_INPUT_KEYBOARD_PAUSE,				// 0x13 VK_PAUSE
	RJD_INPUT_KEYBOARD_CAPSLOCK,			// 0x14 VK_CAPITAL
	RJD_INPUT_KEYBOARD_COUNT,				// 0x15 VK_KANA/VK_HANGEUL/VK_HANGUL
	RJD_INPUT_KEYBOARD_COUNT,				// 0x16 undefined
	RJD_INPUT_KEYBOARD_COUNT,				// 0x17 VK_JUNJA
	RJD_INPUT_KEYBOARD_COUNT,				// 0x18 VK_FINAL
	RJD_INPUT_KEYBOARD_COUNT,				// 0x19 VK_KANJI
	RJD_INPUT_KEYBOARD_COUNT,				// 0x1A undefined
	RJD_INPUT_KEYBOARD_ESCAPE,				// 0x1B VK_ESCAPE
	RJD_INPUT_KEYBOARD_COUNT,				// 0x1C VK_CONVERT
	RJD_INPUT_KEYBOARD_COUNT,				// 0x1D VK_NONCONVERT
	RJD_INPUT_KEYBOARD_COUNT,				// 0x1E VK_ACCEPT
	RJD_INPUT_KEYBOARD_COUNT,				// 0x1F VK_MODECHANGE
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + ' ',	// 0x20 VK_SPACE
	RJD_INPUT_KEYBOARD_PAGEUP,				// 0x21 VK_PRIOR
	RJD_INPUT_KEYBOARD_PAGEDOWN,			// 0x22 VK_NEXT
	RJD_INPUT_KEYBOARD_END,					// 0x23 VK_END
	RJD_INPUT_KEYBOARD_HOME,				// 0x24 VK_HOME
	RJD_INPUT_KEYBOARD_ARROW_LEFT,			// 0x25 VK_LEFT
	RJD_INPUT_KEYBOARD_ARROW_UP,			// 0x26 VK_UP
	RJD_INPUT_KEYBOARD_ARROW_RIGHT,			// 0x27 VK_RIGHT
	RJD_INPUT_KEYBOARD_ARROW_DOWN,			// 0x28 VK_DOWN
	RJD_INPUT_KEYBOARD_COUNT,				// 0x29 VK_SELECT
	RJD_INPUT_KEYBOARD_COUNT,				// 0x2A VK_PRINT
	RJD_INPUT_KEYBOARD_COUNT,				// 0x2B VK_EXECUTE
	RJD_INPUT_KEYBOARD_PRINTSCREEN,			// 0x2C VK_SNAPSHOT
	RJD_INPUT_KEYBOARD_INSERT,				// 0x2D VK_INSERT
	RJD_INPUT_KEYBOARD_DELETE,				// 0x2E VK_DELETE
	RJD_INPUT_KEYBOARD_COUNT,				// 0x2F VK_HELP
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '0',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '1',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '2',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '3',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '4',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '5',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '6',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '7',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '8',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '9',
	RJD_INPUT_KEYBOARD_COUNT,				// 0x3A
	RJD_INPUT_KEYBOARD_COUNT,				// 0x3B
	RJD_INPUT_KEYBOARD_COUNT,				// 0x3C
	RJD_INPUT_KEYBOARD_COUNT,				// 0x3D
	RJD_INPUT_KEYBOARD_COUNT,				// 0x3E
	RJD_INPUT_KEYBOARD_COUNT,				// 0x3F
	RJD_INPUT_KEYBOARD_COUNT,				// 0x40
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'a',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'b',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'c',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'd',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'e',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'f',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'g',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'h',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'i',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'j',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'k',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'l',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'm',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'n',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'o',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'p',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'q',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'r',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 's',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 't',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'u',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'v',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'w',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'x',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'y',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'z',
	RJD_INPUT_KEYBOARD_COUNT,				// 0x5B VK_LWIN
	RJD_INPUT_KEYBOARD_COUNT,				// 0x5C VK_RWIN
	RJD_INPUT_KEYBOARD_COUNT,				// 0x5D VK_APPS
	RJD_INPUT_KEYBOARD_COUNT,				// 0x5E reserved
	RJD_INPUT_KEYBOARD_COUNT,				// 0x5F VK_SLEEP
	RJD_INPUT_KEYBOARD_NUMPAD_0 + 0,
	RJD_INPUT_KEYBOARD_NUMPAD_0 + 1,
	RJD_INPUT_KEYBOARD_NUMPAD_0 + 2,
	RJD_INPUT_KEYBOARD_NUMPAD_0 + 3,
	RJD_INPUT_KEYBOARD_NUMPAD_0 + 4,
	RJD_INPUT_KEYBOARD_NUMPAD_0 + 5,
	RJD_INPUT_KEYBOARD_NUMPAD_0 + 6,
	RJD_INPUT_KEYBOARD_NUMPAD_0 + 7,
	RJD_INPUT_KEYBOARD_NUMPAD_0 + 8,
	RJD_INPUT_KEYBOARD_NUMPAD_0 + 9,
	RJD_INPUT_KEYBOARD_COUNT,				// 0x6A VK_MULTIPLY
	RJD_INPUT_KEYBOARD_COUNT,				// 0x6B VK_ADD
	RJD_INPUT_KEYBOARD_COUNT,				// 0x6C VK_SEPARATOR
	RJD_INPUT_KEYBOARD_COUNT,				// 0x6D VK_SUBTRACT
	RJD_INPUT_KEYBOARD_COUNT,				// 0x6E VK_DECIMAL
	RJD_INPUT_KEYBOARD_COUNT,				// 0x6F VK_DIVIDE
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 1,		// 0x70 VK_F1
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 2,		// 0x71 VK_F2
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 3,		// 0x72 VK_F3
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 4,		// 0x73 VK_F4
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 5,		// 0x74 VK_F5
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 6,		// 0x75 VK_F6
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 7,		// 0x76 VK_F7
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 8,		// 0x77 VK_F8
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 9,		// 0x78 VK_F9
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 10,		// 0x79 VK_F10
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 11,		// 0x7A VK_F11
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 12,		// 0x7B VK_F12
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 13,		// 0x7C VK_F13
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 14,		// 0x7D VK_F14
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 15,		// 0x7E VK_F15

	RJD_INPUT_KEYBOARD_COUNT,				// 0x88 VK_NAVIGATION_VIEW
	RJD_INPUT_KEYBOARD_COUNT,				// 0x89 VK_NAVIGATION_MENU
	RJD_INPUT_KEYBOARD_COUNT,				// 0x8A VK_NAVIGATION_UP
	RJD_INPUT_KEYBOARD_COUNT,				// 0x8B VK_NAVIGATION_DOWN
	RJD_INPUT_KEYBOARD_COUNT,				// 0x8C VK_NAVIGATION_LEFT
	RJD_INPUT_KEYBOARD_COUNT,				// 0x8D VK_NAVIGATION_RIGHT
	RJD_INPUT_KEYBOARD_COUNT,				// 0x8E VK_NAVIGATION_ACCEPT
	RJD_INPUT_KEYBOARD_COUNT,				// 0x8F VK_NAVIGATION_CANCEL
	RJD_INPUT_KEYBOARD_COUNT,				// 0x90 VK_NUMLOCK
	RJD_INPUT_KEYBOARD_COUNT,				// 0x91 VK_SCROLL
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '=',	// 0x92 VK_OEM_NEC_EQUAL
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x92 VK_OEM_FJ_JISHO
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x93 VK_OEM_FJ_MASSHOU
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x94 VK_OEM_FJ_TOUROKU
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x95 VK_OEM_FJ_LOYA
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x96 VK_OEM_FJ_ROYA
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x97 reserved          
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x98 reserved          
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x99 reserved          
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x9A reserved          
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x9B reserved          
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x9C reserved          
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x9D reserved          
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x9E reserved          
	RJD_INPUT_KEYBOARD_COUNT, 				// 0x9F reserved          
	RJD_INPUT_KEYBOARD_SHIFT_LEFT, 			// 0xA0 VK_LSHIFT         
	RJD_INPUT_KEYBOARD_SHIFT_RIGHT, 		// 0xA1 VK_RSHIFT         
	RJD_INPUT_KEYBOARD_CONTROL_LEFT, 		// 0xA2 VK_LCONTROL       
	RJD_INPUT_KEYBOARD_CONTROL_RIGHT, 		// 0xA3 VK_RCONTROL       
	RJD_INPUT_KEYBOARD_ALT_LEFT, 			// 0xA4 VK_LMENU          
	RJD_INPUT_KEYBOARD_ALT_RIGHT, 			// 0xA5 VK_RMENU          
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xA6 VK_BROWSER_BACK        
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xA7 VK_BROWSER_FORWARD     
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xA8 VK_BROWSER_REFRESH     
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xA9 VK_BROWSER_STOP        
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xAA VK_BROWSER_SEARCH      
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xAB VK_BROWSER_FAVORITES   
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xAC VK_BROWSER_HOME        
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xAD VK_VOLUME_MUTE         
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xAE VK_VOLUME_DOWN         
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xAF VK_VOLUME_UP           
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xB0 VK_MEDIA_NEXT_TRACK    
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xB1 VK_MEDIA_PREV_TRACK    
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xB2 VK_MEDIA_STOP          
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xB3 VK_MEDIA_PLAY_PAUSE    
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xB4 VK_LAUNCH_MAIL         
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xB5 VK_LAUNCH_MEDIA_SELECT 
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xB6 VK_LAUNCH_APP1         
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xB7 VK_LAUNCH_APP2         
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xB8 reserved          
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xB9 reserved          
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + ';',	// 0xBA VK_OEM_1        ';:' for US
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '=',	// 0xBB VK_OEM_PLUS     '+' any country
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + ',',	// 0xBC VK_OEM_COMMA    ',' any country
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '-',	// 0xBD VK_OEM_MINUS    '-' any country
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '.',	// 0xBE VK_OEM_PERIOD   '.' any country
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '/',	// 0xBF VK_OEM_2        '/?' for US
	RJD_INPUT_KEYBOARD_COUNT,				// 0xC0 VK_OEM_3  '`~' for US
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + ';',	// 0xC1 reserved          
	RJD_INPUT_KEYBOARD_COUNT,				// 0xC2 reserved          
	RJD_INPUT_KEYBOARD_COUNT,				// 0xC3 VK_GAMEPAD_A
	RJD_INPUT_KEYBOARD_COUNT,				// 0xC4 VK_GAMEPAD_B
	RJD_INPUT_KEYBOARD_COUNT,				// 0xC5 VK_GAMEPAD_X
	RJD_INPUT_KEYBOARD_COUNT,				// 0xC6 VK_GAMEPAD_Y
	RJD_INPUT_KEYBOARD_COUNT,				// 0xC7 VK_GAMEPAD_RIGHT_SHOULDER
	RJD_INPUT_KEYBOARD_COUNT,				// 0xC8 VK_GAMEPAD_LEFT_SHOULDER
	RJD_INPUT_KEYBOARD_COUNT,				// 0xC9 VK_GAMEPAD_LEFT_TRIGGER
	RJD_INPUT_KEYBOARD_COUNT,				// 0xCA VK_GAMEPAD_RIGHT_TRIGGER
	RJD_INPUT_KEYBOARD_COUNT,				// 0xCB VK_GAMEPAD_DPAD_UP
	RJD_INPUT_KEYBOARD_COUNT,				// 0xCC VK_GAMEPAD_DPAD_DOWN
	RJD_INPUT_KEYBOARD_COUNT,				// 0xCD VK_GAMEPAD_DPAD_LEFT
	RJD_INPUT_KEYBOARD_COUNT,				// 0xCE VK_GAMEPAD_DPAD_RIGHT
	RJD_INPUT_KEYBOARD_COUNT,				// 0xCF VK_GAMEPAD_MENU
	RJD_INPUT_KEYBOARD_COUNT,				// 0xD0 VK_GAMEPAD_VIEW
	RJD_INPUT_KEYBOARD_COUNT,				// 0xD1 VK_GAMEPAD_LEFT_THUMBSTICK_BUTTON
	RJD_INPUT_KEYBOARD_COUNT,				// 0xD2 VK_GAMEPAD_RIGHT_THUMBSTICK_BUTTON
	RJD_INPUT_KEYBOARD_COUNT,				// 0xD3 VK_GAMEPAD_LEFT_THUMBSTICK_UP
	RJD_INPUT_KEYBOARD_COUNT,				// 0xD4 VK_GAMEPAD_LEFT_THUMBSTICK_DOWN
	RJD_INPUT_KEYBOARD_COUNT,				// 0xD5 VK_GAMEPAD_LEFT_THUMBSTICK_RIGHT
	RJD_INPUT_KEYBOARD_COUNT,				// 0xD6 VK_GAMEPAD_LEFT_THUMBSTICK_LEFT
	RJD_INPUT_KEYBOARD_COUNT,				// 0xD7 VK_GAMEPAD_RIGHT_THUMBSTICK_UP
	RJD_INPUT_KEYBOARD_COUNT,				// 0xD8 VK_GAMEPAD_RIGHT_THUMBSTICK_DOWN
	RJD_INPUT_KEYBOARD_COUNT,				// 0xD9 VK_GAMEPAD_RIGHT_THUMBSTICK_RIGHT
	RJD_INPUT_KEYBOARD_COUNT,				// 0xDA VK_GAMEPAD_RIGHT_THUMBSTICK_LEFT
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '[',	// 0xDB VK_OEM_4  '[{' for US
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '\\',	// 0xDC VK_OEM_5  '\|' for US
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + ']',	// 0xDD VK_OEM_6  ']}' for US
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '"',	// 0xDE VK_OEM_7  ''"' for US
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xDF VK_OEM_8
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xE0 reserved
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xE1 VK_OEM_AX
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xE2 VK_OEM_102
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xE3 VK_ICO_HELP
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xE4 VK_ICO_00
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xE5 VK_PROCESSKEY
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xE6 VK_ICO_CLEAR
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xE7 VK_PACKET
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xE9 VK_OEM_RESET
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xEA VK_OEM_JUMP
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xEB VK_OEM_PA1
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xEC VK_OEM_PA2
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xED VK_OEM_PA3
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xEE VK_OEM_WSCTRL
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xEF VK_OEM_CUSEL
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xF0 VK_OEM_ATTN
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xF1 VK_OEM_FINISH
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xF2 VK_OEM_COPY
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xF3 VK_OEM_AUTO
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xF4 VK_OEM_ENLW
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xF5 VK_OEM_BACKTAB
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xF6 VK_ATTN
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xF7 VK_CRSEL
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xF8 VK_EXSEL
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xF9 VK_EREOF
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xFA VK_PLAY
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xFB VK_ZOOM
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xFC VK_NONAME
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xFD VK_PA1
	RJD_INPUT_KEYBOARD_COUNT, 				// 0xFE VK_OEM_CLEAR
};

////////////////////////////////////////////////////////////////////////////////
// public implementation

void rjd_input_create(struct rjd_input* out, struct rjd_mem_allocator* allocator)
{
	RJD_UNUSED_PARAM(allocator);
	memset(out, 0, sizeof(*out));
}

void rjd_input_destroy(struct rjd_input* input)
{
	rjd_input_unhook(input);
	memset(input, 0, sizeof(*input));
}

struct rjd_result rjd_input_hook(struct rjd_input* input, const struct rjd_window* window, const struct rjd_window_environment* env)
{
	RJD_ASSERT(input);
	RJD_ASSERT(window);
	RJD_ASSERT(env);

	void* hinstance = env->win32.hinstance;
	void* hwnd = rjd_window_win32_get_hwnd(window);

	if (GetWindowLongPtrW(hwnd, RJD_INPUT_WIN32_WINDOW_PTR_INDEX) != 0) {
		return RJD_RESULT("Another system aleady has the slot for RJD_INPUT_WIN32_WINDOW_PTR_INDEX.");
	}
	
	SetWindowLongPtrW(hwnd, RJD_INPUT_WIN32_WINDOW_PTR_INDEX, (LONG_PTR)input);

	struct rjd_input_win32* input_win32 = (struct rjd_input_win32*)input;

	input_win32->window = window;
	input_win32->hook_handle_wndproc = SetWindowsHookExW(WH_CALLWNDPROC, rjd_input_wndproc_hook, hinstance, GetCurrentThreadId());
	if (input_win32->hook_handle_wndproc == NULL) {
		return RJD_RESULT("Failed to hook window proc. Check GetLastError() for more info.");
	}

	input_win32->hook_handle_getmessage = SetWindowsHookExW(WH_GETMESSAGE, rjd_input_getmessage_hook, hinstance, GetCurrentThreadId());
	if (input_win32->hook_handle_getmessage == NULL) {
		return RJD_RESULT("Failed to hook getmessage. Check GetLastError() for more info.");
	}

	return RJD_RESULT_OK();
}

void rjd_input_unhook(struct rjd_input* input)
{
	struct rjd_input_win32* input_win32 = (struct rjd_input_win32*)input;
	if (input_win32->hook_handle_wndproc || input_win32->hook_handle_getmessage) {
		void* hwnd = rjd_window_win32_get_hwnd(input_win32->window);
		SetWindowLongPtrW(hwnd, RJD_INPUT_WIN32_WINDOW_PTR_INDEX, 0);
		UnhookWindowsHookEx(input_win32->hook_handle_wndproc);
		UnhookWindowsHookEx(input_win32->hook_handle_getmessage);

		input_win32->hook_handle_wndproc = NULL;
		input_win32->hook_handle_getmessage = NULL;
	}
}

void rjd_input_markframe(struct rjd_input* input)
{
	struct rjd_input_win32* input_win32 = (struct rjd_input_win32*)input;
	rjd_input_markframe_common(&input_win32->common);
}

bool rjd_input_keyboard_now(const struct rjd_input* input, enum rjd_input_keyboard code)
{
	struct rjd_input_win32* input_win32 = (struct rjd_input_win32*)input;
	return rjd_input_keyboard_now_common(&input_win32->common, code);
}

bool rjd_input_keyboard_prev(const struct rjd_input* input, enum rjd_input_keyboard code)
{
	struct rjd_input_win32* input_win32 = (struct rjd_input_win32*)input;
	return rjd_input_keyboard_prev_common(&input_win32->common, code);
}

float rjd_input_mouse_now(const struct rjd_input* input, enum rjd_input_mouse code)
{
	struct rjd_input_win32* input_win32 = (struct rjd_input_win32*)input;
	return rjd_input_mouse_now_common(&input_win32->common, code);
}

float rjd_input_mouse_prev(const struct rjd_input* input, enum rjd_input_mouse code)
{
	struct rjd_input_win32* input_win32 = (struct rjd_input_win32*)input;
	return rjd_input_mouse_prev_common(&input_win32->common, code);
}

void rjd_input_simulate(struct rjd_input* input, struct rjd_input_sim_event event)
{
	struct rjd_input_win32* input_win32 = (struct rjd_input_win32*)input;
	void* hwnd = rjd_window_win32_get_hwnd(input_win32->window);

	UINT msg = 0;
	WPARAM wparam = {0};
	LPARAM lparam = {0};

	switch (event.type)
	{
		case RJD_INPUT_SIM_TYPE_KEYBOARD:
		{
			msg = event.keyboard.is_down ? WM_KEYDOWN : WM_KEYUP;

			bool found = false;
			for (uint32_t i = 0; i < rjd_countof(RJD_INPUT_WIN32_KEYCODE_TO_ENUM); ++i) {
				if (RJD_INPUT_WIN32_KEYCODE_TO_ENUM[i] == event.keyboard.key) {
					wparam = i;
					found = true;
					break;
				}
			}
			RJD_ASSERTMSG(found, "No virtual key lookup found for enum rjd_input_keyboard value %d", event.keyboard.key);
			break;
		}

		case RJD_INPUT_SIM_TYPE_MOUSE:
		{
			switch (event.mouse.button)
			{
				case RJD_INPUT_MOUSE_X:
				{
					msg = WM_MOUSEMOVE;
					int16_t x = (int16_t)event.mouse.value;
					int16_t y = (int16_t)rjd_input_mouse_now(input, RJD_INPUT_MOUSE_Y);
					lparam = (y << 16) | (x);
					break;
				}
				case RJD_INPUT_MOUSE_Y:
				{
					msg = WM_MOUSEMOVE;
					int16_t x = (int16_t)rjd_input_mouse_now(input, RJD_INPUT_MOUSE_X);
					int16_t y = (int16_t)event.mouse.value;
					lparam = (y << 16) | (x);
					break;
				}
				case RJD_INPUT_MOUSE_SCROLLWHEEL_DELTA_X:
				case RJD_INPUT_MOUSE_SCROLLWHEEL_DELTA_Y:
				{
					msg = WM_MOUSEWHEEL;
					wparam = (uint16_t)(event.mouse.value * WHEEL_DELTA) << 16;
					break;
				}
				case RJD_INPUT_MOUSE_BUTTON_LEFT:
				{
					msg = (event.mouse.value == 0.0f) ? WM_LBUTTONUP : WM_LBUTTONDOWN;
					break;
				}
				case RJD_INPUT_MOUSE_BUTTON_RIGHT:
				{
					msg = (event.mouse.value == 0.0f) ? WM_LBUTTONUP : WM_LBUTTONDOWN;
					break;
				}
				default:
				{
					if (event.mouse.button == RJD_INPUT_MOUSE_BUTTON_BEGIN + 2) {
						msg = (event.mouse.value == 0.0f) ? WM_MBUTTONUP : WM_MBUTTONDOWN;
					} else if (event.mouse.button == RJD_INPUT_MOUSE_BUTTON_BEGIN + 3) {
						msg = (event.mouse.value == 0.0f) ? WM_XBUTTONUP : WM_XBUTTONDOWN;
						wparam = XBUTTON1 << 16;
					} else if (event.mouse.button == RJD_INPUT_MOUSE_BUTTON_BEGIN + 4) {
						msg = (event.mouse.value == 0.0f) ? WM_XBUTTONUP : WM_XBUTTONDOWN;
						wparam = XBUTTON2 << 16;
					}
				}
			}
		}
	}

	SendMessageW(hwnd, msg, wparam, lparam);
}

////////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK rjd_input_wndproc_hook(int nCode, WPARAM wParam, LPARAM lParam)
{
	const CWPSTRUCT* msg = (const CWPSTRUCT*)lParam;

	struct rjd_input_win32* input_win32 = (struct rjd_input_win32*)GetWindowLongPtrW(msg->hwnd, RJD_INPUT_WIN32_WINDOW_PTR_INDEX);
	if (nCode < 0 || input_win32 == NULL) {
		return CallNextHookEx(NULL, nCode, wParam, lParam);
	};

	return rjd_input_hook_common(input_win32, msg->message, msg->wParam, msg->lParam, nCode, wParam, lParam);
}

LRESULT CALLBACK rjd_input_getmessage_hook(int nCode, WPARAM wParam, LPARAM lParam)
{
	const MSG* msg = (const MSG*)lParam;

	struct rjd_input_win32* input_win32 = (struct rjd_input_win32*)GetWindowLongPtrW(msg->hwnd, RJD_INPUT_WIN32_WINDOW_PTR_INDEX);
	if (nCode < 0 || input_win32 == NULL) {
		return CallNextHookEx(NULL, nCode, wParam, lParam);
	};

	return rjd_input_hook_common(input_win32, msg->message, msg->wParam, msg->lParam, nCode, wParam, lParam);
}

LRESULT rjd_input_hook_common(struct rjd_input_win32* input_win32, UINT message, WPARAM wParam, LPARAM lParam, int nCode, WPARAM hook_wparam, LPARAM hook_lparam)
{
	const uint32_t now_index = input_win32->common.now_index;

	switch (message)
	{
		case WM_KEYDOWN:
		case WM_KEYUP:
		{
			// const uint32_t repeat_count = (0xFFFF & lParam);
			const uint32_t scan_code = (0xFF0000 & lParam) >> 16;
			const bool is_extended = (0x01000000 & lParam) != 0;
			const bool is_down = (message == WM_KEYDOWN);

			uint32_t virtual_key = (uint32_t)wParam;
			if (wParam == VK_SHIFT) {
				virtual_key = MapVirtualKey(scan_code, MAPVK_VSC_TO_VK_EX);
			} else if (wParam == VK_CONTROL) {
				virtual_key = is_extended ? VK_RCONTROL : VK_LCONTROL;
			} else if (wParam == VK_MENU) {
				virtual_key = is_extended ? VK_RMENU : VK_LMENU;
			}

			if (virtual_key < rjd_countof(RJD_INPUT_WIN32_KEYCODE_TO_ENUM)) {
				enum rjd_input_keyboard key = RJD_INPUT_WIN32_KEYCODE_TO_ENUM[virtual_key];

				input_win32->common.keyboard[now_index].values[key] = is_down;
			}
			break;
		}
		case WM_LBUTTONDOWN:
			input_win32->common.mouse[now_index].values[RJD_INPUT_MOUSE_BUTTON_LEFT] = 1.0f;
			break;
		case WM_LBUTTONUP:
			input_win32->common.mouse[now_index].values[RJD_INPUT_MOUSE_BUTTON_LEFT] = 0.0f;
			break;
		case WM_RBUTTONDOWN:
			input_win32->common.mouse[now_index].values[RJD_INPUT_MOUSE_BUTTON_RIGHT] = 1.0f;
			break;
		case WM_RBUTTONUP:
			input_win32->common.mouse[now_index].values[RJD_INPUT_MOUSE_BUTTON_RIGHT] = 0.0f;
			break;
		case WM_MBUTTONDOWN:
			input_win32->common.mouse[now_index].values[RJD_INPUT_MOUSE_BUTTON_BEGIN + 2] = 1.0f;
			break;
		case WM_MBUTTONUP:
			input_win32->common.mouse[now_index].values[RJD_INPUT_MOUSE_BUTTON_BEGIN + 2] = 0.0f;
			break;
		case WM_XBUTTONDOWN:
		{
			uint32_t button_index = (((wParam & 0xFFFF0000) >> 16) == XBUTTON1) ? 3 : 4;
			input_win32->common.mouse[now_index].values[RJD_INPUT_MOUSE_BUTTON_BEGIN + button_index] = 1.0f;
			break;
		}
		case WM_XBUTTONUP:
		{
			uint32_t button_index = (((wParam & 0xFFFF0000) >> 16) == XBUTTON1) ? 3 : 4;
			input_win32->common.mouse[now_index].values[RJD_INPUT_MOUSE_BUTTON_BEGIN + button_index] = 0.0f;
			break;
		}
		case WM_MOUSEWHEEL:
		{
			float delta = (float)GET_WHEEL_DELTA_WPARAM(wParam) / WHEEL_DELTA;
			input_win32->common.mouse[now_index].values[RJD_INPUT_MOUSE_SCROLLWHEEL_DELTA_Y] = delta;
			break;
		}
		case WM_MOUSEHWHEEL:
		{
			float delta = (float)GET_WHEEL_DELTA_WPARAM(wParam) / WHEEL_DELTA;
			input_win32->common.mouse[now_index].values[RJD_INPUT_MOUSE_SCROLLWHEEL_DELTA_X] = delta;
			break;
		}
		case WM_MOUSEMOVE:
		{
			float x = (float)GET_X_LPARAM(lParam);
			float y = (float)GET_Y_LPARAM(lParam);
			input_win32->common.mouse[now_index].values[RJD_INPUT_MOUSE_X] = x;
			input_win32->common.mouse[now_index].values[RJD_INPUT_MOUSE_Y] = y;
			break;
		}
	}

	return CallNextHookEx(NULL, nCode, hook_wparam, hook_lparam);
}

#elif RJD_PLATFORM_OSX

#include <Carbon/Carbon.h>

////////////////////////////////////////////////////////////////////////////////
// Local helpers

struct rjd_input_osx;

@interface InputResponder : NSResponder
	@property(readonly) BOOL acceptsFirstResponder;
	-(instancetype)initWithInput:(struct rjd_input_osx*)_input;
@end

struct rjd_input_osx
{
	InputResponder* responder;
	const struct rjd_window* window;

	struct rjd_input_common common;
};

RJD_STATIC_ASSERT(sizeof(struct rjd_input_osx) <= sizeof(struct rjd_input));

////////////////////////////////////////////////////////////////////////////////
// Local data

const uint8_t RJD_INPUT_OSX_KEYCODE_TO_ENUM[] =
{
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'a',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 's',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'd',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'f',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'h',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'g',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'z',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'x',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'c',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'v',
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'b',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'q',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'w',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'e',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'r',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'y',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 't',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '1',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '2',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '3',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '4',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '6',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '5',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '=',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '9',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '7',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '-',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '8',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '0',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + ']',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'o',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'u',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '[',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'i',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'p',
	RJD_INPUT_KEYBOARD_RETURN,
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'l',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'j',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '\'',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'k',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + ';',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '\\',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + ',',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '/',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'n',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + 'm',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '.',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '\t',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + ' ',
	RJD_INPUT_KEYBOARD_ASCII_BEGIN + '~',
	RJD_INPUT_KEYBOARD_DELETE,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_ESCAPE,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT, // command (OSX)
	RJD_INPUT_KEYBOARD_COUNT, // shift (OSX)
	RJD_INPUT_KEYBOARD_COUNT, // option (OSX)
	RJD_INPUT_KEYBOARD_COUNT, // control (OSX)
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT, // numpad .
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT, // numpad *
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT, // numpad +
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT, // numpad /
	RJD_INPUT_KEYBOARD_COUNT, // numpad enter
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT, // numpad -
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT, // numpad =
	RJD_INPUT_KEYBOARD_NUMPAD_0,
	RJD_INPUT_KEYBOARD_NUMPAD_0 + 1,
	RJD_INPUT_KEYBOARD_NUMPAD_0 + 2,
	RJD_INPUT_KEYBOARD_NUMPAD_0 + 3,
	RJD_INPUT_KEYBOARD_NUMPAD_0 + 4,
	RJD_INPUT_KEYBOARD_NUMPAD_0 + 5,
	RJD_INPUT_KEYBOARD_NUMPAD_0 + 6,
	RJD_INPUT_KEYBOARD_NUMPAD_0 + 7,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_NUMPAD_0 + 8,
	RJD_INPUT_KEYBOARD_NUMPAD_0 + 9,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 5,
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 6,
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 7,
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 3,
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 8,
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 9,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 10,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 12,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 4,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 2,
	RJD_INPUT_KEYBOARD_COUNT,
	RJD_INPUT_KEYBOARD_FUNCTION_0 + 1,
	RJD_INPUT_KEYBOARD_ARROW_LEFT,
	RJD_INPUT_KEYBOARD_ARROW_RIGHT,
	RJD_INPUT_KEYBOARD_ARROW_DOWN,
	RJD_INPUT_KEYBOARD_ARROW_UP,
	//RJD_INPUT_KEYBOARD_HOME,
	//RJD_INPUT_KEYBOARD_END,
	//RJD_INPUT_KEYBOARD_PAGEUP,
	//RJD_INPUT_KEYBOARD_PAGEDOWN,
};

////////////////////////////////////////////////////////////////////////////////
// Interface implementation

void rjd_input_create(struct rjd_input* out, struct rjd_mem_allocator* allocator)
{
	RJD_ASSERT(out);
	RJD_ASSERT(allocator);

	memset(out, 0, sizeof(*out));
}

void rjd_input_destroy(struct rjd_input* input)
{
	RJD_ASSERT(input);

	rjd_input_unhook(input);
	memset(input, 0, sizeof(*input));
}

struct rjd_result rjd_input_hook(struct rjd_input* input, const struct rjd_window* window, const struct rjd_window_environment* env)
{
	RJD_ASSERT(input);
	RJD_ASSERT(env);
	RJD_ASSERT(window);
	RJD_UNUSED_PARAM(env); // used in win32

	struct rjd_input_osx* input_osx = (struct rjd_input_osx*)input;

	NSWindow* nswindow = rjd_window_osx_get_nswindow(window);
	if (nswindow == nil) {
		return RJD_RESULT("No window available to hook. Did the window initialize correctly?");
	}

	NSView* view = rjd_window_osx_get_mtkview(window);
	if (view == nil) {
		view = rjd_window_osx_get_basicview(window);
		if (view == nil) {
			return RJD_RESULT("No view available in the window to hook. Did the window initialize correctly?");
		}
	}

	input_osx->responder = [[InputResponder alloc] initWithInput:input_osx];
	if (input_osx->responder == nil) {
		return RJD_RESULT("Failed to allocate InputResponder. Are you out of memory?");
	}

	view.nextResponder = input_osx->responder;
	nswindow.acceptsMouseMovedEvents = YES;
	nswindow.nextResponder = input_osx->responder;

	input_osx->window = window;

	return RJD_RESULT_OK();
}

void rjd_input_unhook(struct rjd_input* input)
{
	RJD_ASSERT(input);

	struct rjd_input_osx* input_osx = (struct rjd_input_osx*)input;

	NSWindow* nswindow = rjd_window_osx_get_nswindow(input_osx->window);
	if (nswindow && nswindow.firstResponder == input_osx->responder) {
		[nswindow makeFirstResponder:nswindow];
	}
	input_osx->responder = nil;
	input_osx->window = NULL;
}

void rjd_input_markframe(struct rjd_input* input)
{
	struct rjd_input_osx* input_osx = (struct rjd_input_osx*)input;
	rjd_input_markframe_common(&input_osx->common);
}

bool rjd_input_keyboard_now(const struct rjd_input* input, enum rjd_input_keyboard code)
{
	struct rjd_input_osx* input_osx = (struct rjd_input_osx*)input;
	return rjd_input_keyboard_now_common(&input_osx->common, code);
}

bool rjd_input_keyboard_prev(const struct rjd_input* input, enum rjd_input_keyboard code)
{
	struct rjd_input_osx* input_osx = (struct rjd_input_osx*)input;
	return rjd_input_keyboard_prev_common(&input_osx->common, code);
}

float rjd_input_mouse_now(const struct rjd_input* input, enum rjd_input_mouse code)
{
	struct rjd_input_osx* input_osx = (struct rjd_input_osx*)input;
	return rjd_input_mouse_now_common(&input_osx->common, code);
}

float rjd_input_mouse_prev(const struct rjd_input* input, enum rjd_input_mouse code)
{
	struct rjd_input_osx* input_osx = (struct rjd_input_osx*)input;
	return rjd_input_mouse_prev_common(&input_osx->common, code);
}

void rjd_input_simulate(struct rjd_input* input, struct rjd_input_sim_event event)
{
	RJD_ASSERT(input);

	struct rjd_input_osx* input_osx = (struct rjd_input_osx*)input;

	switch (event.type)
	{
		case RJD_INPUT_SIM_TYPE_KEYBOARD:
		{
            NSEventModifierFlags modifier_flag = 0;
			modifier_flag |= rjd_input_keyboard_now(input, RJD_INPUT_KEYBOARD_SHIFT_LEFT)   	? NX_DEVICELSHIFTKEYMASK : 0;
			modifier_flag |= rjd_input_keyboard_now(input, RJD_INPUT_KEYBOARD_SHIFT_RIGHT)		? NX_DEVICERSHIFTKEYMASK : 0;
			modifier_flag |= rjd_input_keyboard_now(input, RJD_INPUT_KEYBOARD_CONTROL_LEFT) 	? NX_DEVICELCTLKEYMASK : 0;
			modifier_flag |= rjd_input_keyboard_now(input, RJD_INPUT_KEYBOARD_CONTROL_RIGHT)	? NX_DEVICERCTLKEYMASK : 0;
			modifier_flag |= rjd_input_keyboard_now(input, RJD_INPUT_KEYBOARD_OPTION_LEFT)		? NX_DEVICELALTKEYMASK : 0;
			modifier_flag |= rjd_input_keyboard_now(input, RJD_INPUT_KEYBOARD_OPTION_RIGHT)		? NX_DEVICERALTKEYMASK : 0;
			modifier_flag |= rjd_input_keyboard_now(input, RJD_INPUT_KEYBOARD_COMMAND_LEFT)		? NX_DEVICELCMDKEYMASK : 0;
			modifier_flag |= rjd_input_keyboard_now(input, RJD_INPUT_KEYBOARD_COMMAND_RIGHT)	? NX_DEVICERCMDKEYMASK : 0;

			NSEventModifierFlags key_bit = 0;
            switch (event.keyboard.key)
            {
                case RJD_INPUT_KEYBOARD_SHIFT_LEFT:     key_bit = NX_DEVICELSHIFTKEYMASK; break;
                case RJD_INPUT_KEYBOARD_SHIFT_RIGHT:    key_bit = NX_DEVICERSHIFTKEYMASK; break;
                case RJD_INPUT_KEYBOARD_CONTROL_LEFT:   key_bit = NX_DEVICELCTLKEYMASK; break;
                case RJD_INPUT_KEYBOARD_CONTROL_RIGHT:  key_bit = NX_DEVICERCTLKEYMASK; break;
                case RJD_INPUT_KEYBOARD_OPTION_LEFT:    key_bit = NX_DEVICELALTKEYMASK; break;
                case RJD_INPUT_KEYBOARD_OPTION_RIGHT:   key_bit = NX_DEVICERALTKEYMASK; break;
                case RJD_INPUT_KEYBOARD_COMMAND_LEFT:   key_bit = NX_DEVICELCMDKEYMASK; break;
                case RJD_INPUT_KEYBOARD_COMMAND_RIGHT:  key_bit = NX_DEVICERCMDKEYMASK; break;
                default: break;
            }

            if (key_bit) {
				if (event.keyboard.is_down) {
					modifier_flag |= key_bit;
				} else {
					modifier_flag &= ~(key_bit);
				}

				NSEvent* nsevent = [NSEvent keyEventWithType:NSEventTypeKeyDown
					location:NSZeroPoint
					modifierFlags:modifier_flag
					timestamp:[NSDate date].timeIntervalSince1970
					windowNumber:0
					context:nil
					characters:@""
					charactersIgnoringModifiers:@""
					isARepeat:false
					keyCode:0];
                  
                [input_osx->responder flagsChanged:nsevent];
            } else {
                int32_t keycode = -1;
                for (int32_t i = 0; i < (int32_t)rjd_countof(RJD_INPUT_OSX_KEYCODE_TO_ENUM); ++i) {
                    if (RJD_INPUT_OSX_KEYCODE_TO_ENUM[i] == event.keyboard.key) {
                        keycode = i;
                        break;
                    }
                }
                if (keycode < 0) {
                    RJD_ASSERT(keycode >= 0);
                    return;
                }

                NSEvent* nsevent = [NSEvent keyEventWithType:event.keyboard.is_down ? NSEventTypeKeyDown : NSEventTypeKeyUp
					location:NSZeroPoint
					modifierFlags:0
					timestamp:[NSDate date].timeIntervalSince1970
					windowNumber:0
					context:nil
					characters:@""
					charactersIgnoringModifiers:@""
					isARepeat:false
					keyCode:keycode];

                if (event.keyboard.is_down) {
                    [input_osx->responder keyDown:nsevent];
                } else {
                    [input_osx->responder keyUp:nsevent];
                }
            }
			break;
		}

		case RJD_INPUT_SIM_TYPE_MOUSE:
		{
			switch (event.mouse.button)
			{
				case RJD_INPUT_MOUSE_X:
				case RJD_INPUT_MOUSE_Y:
				{
					const MTKView* mtkview = rjd_window_osx_get_mtkview(input_osx->window);
					const NSPoint origin_in_window = {0,0};
					const NSPoint origin_in_view = [mtkview convertPoint:origin_in_window fromView:nil];

					NSPoint xy = {
						.x = rjd_input_mouse_now(input, RJD_INPUT_MOUSE_X),
						.y = rjd_input_mouse_now(input, RJD_INPUT_MOUSE_Y),
					};

					if (event.mouse.button == RJD_INPUT_MOUSE_X) {
						xy.x = event.mouse.value;
					} else {
						xy.y = event.mouse.value;
					}

					xy.x -= origin_in_view.x;
					xy.y -= origin_in_view.y;

					NSEvent* nsevent = [NSEvent mouseEventWithType:NSEventTypeMouseMoved
                       location:xy
                  modifierFlags:0
                      timestamp:[NSDate date].timeIntervalSince1970
                   windowNumber:0
                        context:nil
                    eventNumber:0
                     clickCount:0
                       pressure:0];

					[input_osx->responder mouseMoved:nsevent];
					break;
				}

				case RJD_INPUT_MOUSE_SCROLLWHEEL_DELTA_X:
				case RJD_INPUT_MOUSE_SCROLLWHEEL_DELTA_Y:
				{
					CGWheelCount count_wheels = 2; // range in [1,3] where axes are [Y,X,Z]
					int32_t dx = 0;
					int32_t dy = 0;
					if (event.mouse.button == RJD_INPUT_MOUSE_SCROLLWHEEL_DELTA_X) {
						dx = event.mouse.value;
					} else {
						dy = event.mouse.value;
					}

					CGEventRef cgevent = CGEventCreateScrollWheelEvent(NULL, kCGScrollEventUnitLine, count_wheels, dy, dx);
					NSEvent* nsevent = [NSEvent eventWithCGEvent:cgevent];
					[input_osx->responder scrollWheel:nsevent];
                    break;
				}

				case RJD_INPUT_MOUSE_BUTTON_LEFT:
                {
					if (event.mouse.value) {
						[input_osx->responder mouseDown:[[NSEvent alloc] init]];
					} else {
						[input_osx->responder mouseUp:[[NSEvent alloc] init]];
					}
					break;
                }

				case RJD_INPUT_MOUSE_BUTTON_RIGHT:
                {
					if (event.mouse.value) {
						[input_osx->responder rightMouseDown:[[NSEvent alloc] init]];
					} else {
						[input_osx->responder rightMouseUp:[[NSEvent alloc] init]];
					}
					break;
                }

				default:
					// The rest of the events are intentionally left unhandled
					break;
			}
			break;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
// Local helpers

@implementation InputResponder
{
	struct rjd_input_osx* input;
}

-(instancetype)initWithInput:(struct rjd_input_osx*)_input
{
    if (self = [super init]) {
		self->input = _input;
    }
    return self;
}

-(BOOL)acceptsFirstResponder
{
	return YES;
}

-(BOOL)becomeFirstResponder
{
	return YES;
}

-(void)keyDown:(NSEvent*)event
{
	if (event.keyCode < rjd_countof(RJD_INPUT_OSX_KEYCODE_TO_ENUM)) {
		enum rjd_input_keyboard code = RJD_INPUT_OSX_KEYCODE_TO_ENUM[event.keyCode];
		input->common.keyboard[input->common.now_index].values[code] = 1;
	}
}

-(void)keyUp:(NSEvent*)event
{
	if (event.keyCode < rjd_countof(RJD_INPUT_OSX_KEYCODE_TO_ENUM)) {
		enum rjd_input_keyboard code = RJD_INPUT_OSX_KEYCODE_TO_ENUM[event.keyCode];
		input->common.keyboard[input->common.now_index].values[code] = 0;
	}
}

-(void)flagsChanged:(NSEvent*)event
{
	struct rjd_input_keyboard_state* state = input->common.keyboard + input->common.now_index;

	state->values[RJD_INPUT_KEYBOARD_SHIFT_LEFT] = (event.modifierFlags & NX_DEVICELSHIFTKEYMASK) ? 1 : 0;
	state->values[RJD_INPUT_KEYBOARD_SHIFT_RIGHT] = (event.modifierFlags & NX_DEVICERSHIFTKEYMASK) ? 1 : 0;
	state->values[RJD_INPUT_KEYBOARD_CONTROL_LEFT] = (event.modifierFlags & NX_DEVICELCTLKEYMASK) ? 1 : 0;
	state->values[RJD_INPUT_KEYBOARD_CONTROL_RIGHT] = (event.modifierFlags & NX_DEVICERCTLKEYMASK) ? 1 : 0;
	state->values[RJD_INPUT_KEYBOARD_OPTION_LEFT] = (event.modifierFlags & NX_DEVICELALTKEYMASK) ? 1 : 0;
	state->values[RJD_INPUT_KEYBOARD_OPTION_RIGHT] = (event.modifierFlags & NX_DEVICERALTKEYMASK) ? 1 : 0;
	state->values[RJD_INPUT_KEYBOARD_COMMAND_LEFT] = (event.modifierFlags & NX_DEVICELCMDKEYMASK) ? 1 : 0;
	state->values[RJD_INPUT_KEYBOARD_COMMAND_RIGHT] = (event.modifierFlags & NX_DEVICERCMDKEYMASK) ? 1 : 0;
}

-(void)mouseDown:(NSEvent*)event
{
	RJD_UNUSED_PARAM(event);
    input->common.mouse[input->common.now_index].values[RJD_INPUT_MOUSE_BUTTON_LEFT] = 1;
}

-(void)mouseUp:(NSEvent*)event
{
	RJD_UNUSED_PARAM(event);
    input->common.mouse[input->common.now_index].values[RJD_INPUT_MOUSE_BUTTON_LEFT] = 0;
}
                  
-(void)rightMouseDown:(NSEvent*)event
{
	RJD_UNUSED_PARAM(event);
	input->common.mouse[input->common.now_index].values[RJD_INPUT_MOUSE_BUTTON_RIGHT] = 1;
}

-(void)rightMouseUp:(NSEvent*)event
{
	RJD_UNUSED_PARAM(event);
	input->common.mouse[input->common.now_index].values[RJD_INPUT_MOUSE_BUTTON_RIGHT] = 0;
}
                  
-(void)otherMouseDown:(NSEvent*)event
{
	RJD_UNUSED_PARAM(event);
	for (uint32_t button = RJD_INPUT_MOUSE_BUTTON_BEGIN; button < RJD_INPUT_MOUSE_BUTTON_END; ++button) {
		uint32_t bit = 1 << (button - RJD_INPUT_MOUSE_BUTTON_BEGIN);
		bool pressed = (NSEvent.pressedMouseButtons & bit) != 0;
		input->common.mouse[input->common.now_index].values[button] = pressed;
	}
}

-(void)otherMouseUp:(NSEvent*)event
{
	RJD_UNUSED_PARAM(event);
	for (uint32_t button = RJD_INPUT_MOUSE_BUTTON_BEGIN; button < RJD_INPUT_MOUSE_BUTTON_END; ++button) {
		uint32_t bit = 1 << (button - RJD_INPUT_MOUSE_BUTTON_BEGIN);
		bool pressed = (NSEvent.pressedMouseButtons & bit) != 0;
		input->common.mouse[input->common.now_index].values[button] = pressed;
	}
}

-(void)mouseMoved:(NSEvent*)event
{
	NSView* view = rjd_window_osx_get_mtkview(input->window);
    if (view == nil) {
        view = rjd_window_osx_get_basicview(input->window);
    }
	NSPoint locationInView = [view convertPoint:event.locationInWindow fromView:nil];

	int x = locationInView.x;
	int y = locationInView.y;

	struct rjd_window_size size = rjd_window_size_get(input->window);
	if (x >= 0 && x <= size.width && y >= 0 && y <= size.height) {
		input->common.mouse[input->common.now_index].values[RJD_INPUT_MOUSE_X] = (float)x;
		input->common.mouse[input->common.now_index].values[RJD_INPUT_MOUSE_Y] = (float)y;
	}
}

-(void)scrollWheel:(NSEvent*)event
{
	input->common.mouse[input->common.now_index].values[RJD_INPUT_MOUSE_SCROLLWHEEL_DELTA_X] = (float)event.scrollingDeltaX;
	input->common.mouse[input->common.now_index].values[RJD_INPUT_MOUSE_SCROLLWHEEL_DELTA_Y] = (float)event.scrollingDeltaY;
}

@end

#endif // RJD_PLATFORM_*
#endif // RJD_IMPL

////////////////////////////////////////////////////////////////////////////////
// rjd_gfx.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <stdint.h>

#define RJD_GFX_H 1

// interface dependencies:
// * rjd_result

// impl dependencies:
// * rjd_mem
// * rjd_math

////////////////////////////////////////////////////////////////////////////////
// platform configuration

// Supported RJG_GFX_BACKEND_* values:
// RJD_GFX_BACKEND_METAL (osx only)
// RJD_GFX_BACKEND_D3D11 (windows only)
// RJD_GFX_BACKEND_NONE (any platform, stub interface only)

#ifndef RJD_GFX_BACKEND_NONE
	#define RJD_GFX_BACKEND_NONE 0
#endif
#ifndef RJD_GFX_BACKEND_METAL
	#define RJD_GFX_BACKEND_METAL 0
#endif
#ifndef RJD_GFX_BACKEND_D3D11
	#define RJD_GFX_BACKEND_D3D11 0
#endif

#if (RJD_GFX_BACKEND_NONE + RJD_GFX_BACKEND_METAL + RJD_GFX_BACKEND_D3D11) > 1
	#error "Only one of the RJD_GFX_BACKEND_* macros may be defined."
#endif

#if !RJD_GFX_BACKEND_NONE && !RJD_GFX_BACKEND_METAL && !RJD_GFX_BACKEND_D3D11
	#error	"You must #define one of the following to 1 before including this file: "
			"RJD_GFX_BACKEND_NONE, RJD_GFX_BACKEND_METAL, RJD_GFX_BACKEND_D3D11"
#endif

#if RJD_GFX_BACKEND_METAL
	#if RJD_PLATFORM_OSX
	    // Workaround .c files not being able to read objective-c forward declarations
	    #if RJD_LANG_OBJC
	        @class MTKView;
	        RJD_STATIC_ASSERT(sizeof(void*) == sizeof(MTKView*));
	    #else
	        typedef void MTKView;
	    #endif
	#else
		#error "Metal is only supported on OSX"
	#endif
#endif

#if RJD_GFX_PLATFORM_D3D11
	#if RJD_PLATFORM_WINDOWS
		typedef void* HWND;
	#else
		#error "DirectX is only supported on Windows"
	#endif
#endif

////////////////////////////////////////////////////////////////////////////////
// render configuration

struct rjd_mem_allocator;

struct rjd_gfx_viewport // TODO figure out if this should have a start x,y pair
{
	uint32_t width;
	uint32_t height;
};

enum rjd_gfx_stencilmode
{
	RJD_GFX_STENCILMODE_DISABLED,
	RJD_GFX_STENCILMODE_TEST,
	RJD_GFX_STENCILMODE_WRITE,
	RJD_GFX_STENCILMODE_COUNT,
};

//struct rjd_gfx_render_config
//{
//	struct rjd_gfx_viewport window_size; // TODO upgrade this into a render view (render target w/ size & offset)?
//	enum rjd_gfx_stencilmode stencil_mode;
//	int use_buffer_color: 1;
//	int use_buffer_depth: 1;
//};
//
//struct rjd_gfx_render_geo2d
//{
//	struct rjd_math_float16* transforms;
//	union rjd_gfx_quad_uv* uvs;
//	rjd_math_float4* tints;
//	uint32_t count;
//};

////////////////////////////////////////////////////////////////////////////////
// resources

enum rjd_gfx_format
{
	RJD_GFX_FORMAT_COLOR_U8_RGBA,
	RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM,
	RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM_SRGB,
    RJD_GFX_FORMAT_DEPTHSTENCIL_F32_D32,
	RJD_GFX_FORMAT_DEPTHSTENCIL_U32_D24_S8,
	RJD_GFX_FORMAT_COUNT,
};

// all values correspond to the entry in the enum rjd_gfx_format
struct rjd_gfx_format_value
{
	enum rjd_gfx_format type;
	union
	{
		uint8_t color_u8_rgba[4];
		union { 
			uint32_t value; 
			struct { 
				uint32_t depth:24; 
				uint32_t stencil:8;
			} parts; 
		} depthstencil_u32_d24_s8;
        float depthstencil_f32_d32;
	};
};

enum rjd_gfx_texture_access
{
	RJD_GFX_TEXTURE_ACCESS_CPU_WRITE_GPU_READWRITE,
	RJD_GFX_TEXTURE_ACCESS_CPU_NONE_GPU_READWRITE,
	RJD_GFX_TEXTURE_ACCESS_COUNT,
};

enum rjd_gfx_texture_usage
{
	RJD_GFX_TEXTURE_USAGE_DEFAULT,
	RJD_GFX_TEXTURE_USAGE_RENDERTARGET,
    RJD_GFX_TEXTURE_USAGE_COUNT,
};

struct rjd_gfx_texture_desc
{
	const char* debug_label;
	void* data;
	uint32_t data_length;
	uint32_t pixels_width;
	uint32_t pixels_height;
	uint32_t msaa_samples;
	enum rjd_gfx_format format;
	enum rjd_gfx_texture_access access;
	enum rjd_gfx_texture_usage usage;
};

struct rjd_gfx_texture
{
	struct rjd_slot handle;
};

// TODO determine if this is a good idea or not
//struct rjd_gfx_shader_input_slot
//{
//	const char* name;
//	uint32_t index;
//	enum rjd_gfx_shader_input_buffer_type_flags type_flags;
//};

enum rjd_gfx_shader_type
{
	RJD_GFX_SHADER_TYPE_VERTEX,
	RJD_GFX_SHADER_TYPE_PIXEL,
};

// TODO provide a precompiled path as well, preferably with a shader_precompiled_desc?
struct rjd_gfx_shader_desc
{
	const char* source_name;
	const char* function_name;
	const void* data;
	uint32_t count_data;
	enum rjd_gfx_shader_type type;

	//struct rjd_gfx_shader_input_slot* slots;
	//uint32_t count_slots;
};

struct rjd_gfx_shader
{
	struct rjd_slot handle;
};

enum rjd_gfx_vertex_format_type
{
	RJD_GFX_VERTEX_FORMAT_TYPE_FLOAT1,
	RJD_GFX_VERTEX_FORMAT_TYPE_FLOAT2,
	RJD_GFX_VERTEX_FORMAT_TYPE_FLOAT3,
	RJD_GFX_VERTEX_FORMAT_TYPE_FLOAT4,
	RJD_GFX_VERTEX_FORMAT_TYPE_COUNT,
};

enum rjd_gfx_vertex_format_step
{
	RJD_GFX_VERTEX_FORMAT_STEP_VERTEX,
	RJD_GFX_VERTEX_FORMAT_STEP_INSTANCE,
	RJD_GFX_VERTEX_FORMAT_STEP_CONSTANT,
};

enum rjd_gfx_vertex_semantic
{
	RJD_GFX_VERTEX_SEMANTIC_POSITION,
	RJD_GFX_VERTEX_SEMANTIC_COLOR,
	RJD_GFX_VERTEX_SEMANTIC_NORMAL,
	RJD_GFX_VERTEX_SEMANTIC_TEXCOORD,
	RJD_GFX_VERTEX_SEMANTIC_BINORMAL,
	RJD_GFX_VERTEX_SEMANTIC_TANGENT,
	RJD_GFX_VERTEX_SEMANTIC_BLENDINDEX,
	RJD_GFX_VERTEX_SEMANTIC_BLENDWEIGHT,
	RJD_GFX_VERTEX_SEMANTIC_COUNT,
};

struct rjd_gfx_vertex_format_attribute
{
	enum rjd_gfx_vertex_format_type type;
	enum rjd_gfx_vertex_format_step step;
	enum rjd_gfx_vertex_semantic semantic; // only used for d3d11
	uint32_t attribute_index;
	uint32_t shader_slot_metal;
	uint32_t shader_slot_d3d11;
	uint32_t stride;
    uint32_t step_rate;
	uint32_t offset;
};

enum rjd_gfx_winding_order
{
	RJD_GFX_WINDING_ORDER_CLOCKWISE,
	RJD_GFX_WINDING_ORDER_COUNTERCLOCKWISE,
};

enum rjd_gfx_cull
{
	RJD_GFX_CULL_NONE,
	RJD_GFX_CULL_BACK,
	RJD_GFX_CULL_FRONT,
};

enum rjd_gfx_depth_compare
{
	RJD_GFX_DEPTH_COMPARE_ALWAYS_SUCCEED,
	RJD_GFX_DEPTH_COMPARE_ALWAYS_FAIL,
	RJD_GFX_DEPTH_COMPARE_LESS,
	RJD_GFX_DEPTH_COMPARE_LESSEQUAL,
	RJD_GFX_DEPTH_COMPARE_GREATER,
	RJD_GFX_DEPTH_COMPARE_GREATEREQUAL,
	RJD_GFX_DEPTH_COMPARE_EQUAL,
	RJD_GFX_DEPTH_COMPARE_NOTEQUAL,
};

struct rjd_gfx_pipeline_state_desc
{
	const char* debug_name;
	struct rjd_gfx_shader shader_vertex;
	struct rjd_gfx_shader shader_pixel;
	struct rjd_gfx_texture render_target; // specify RJD_GFX_TEXTURE_BACKBUFFER to use the backbuffer
	struct rjd_gfx_texture depthstencil_target; // specify RJD_GFX_TEXTURE_BACKBUFFER to use the backbuffer
	struct rjd_gfx_vertex_format_attribute* vertex_attributes;
	uint32_t count_vertex_attributes;
	enum rjd_gfx_depth_compare depth_compare;
	bool depth_write_enabled;
	enum rjd_gfx_cull cull_mode;
	enum rjd_gfx_winding_order winding_order;
	// TODO stencil config
};

struct rjd_gfx_pipeline_state
{
	struct rjd_slot handle;
};

enum rjd_gfx_primitive_type
{
	RJD_GFX_PRIMITIVE_TYPE_TRIANGLES,
};

enum rjd_gfx_index_type
{
	RJD_GFX_INDEX_TYPE_UINT32,
	RJD_GFX_INDEX_TYPE_UINT16,
};

enum rjd_gfx_mesh_buffer_usage_flags
{
	RJD_GFX_MESH_BUFFER_USAGE_VERTEX = 1 << 0,
	RJD_GFX_MESH_BUFFER_USAGE_VERTEX_CONSTANT = 1 << 1,
	RJD_GFX_MESH_BUFFER_USAGE_PIXEL_CONSTANT = 1 << 2,
};

union rjd_gfx_mesh_buffer_common_desc
{
	struct {
		uint32_t capacity;
	} constant;

	struct {
		const void* data;
		uint32_t length;
		uint32_t stride;
	} vertex;
};

struct rjd_gfx_mesh_buffer_desc
{
	union rjd_gfx_mesh_buffer_common_desc common;
	enum rjd_gfx_mesh_buffer_usage_flags usage_flags;
	uint32_t shader_slot_metal; // metal shader slots are shared between all buffer types
	uint32_t shader_slot_d3d11; // d3d11 vertex/constant buffers have their own lists of slots
};

struct rjd_gfx_mesh_vertexed_desc // TODO rename to rjd_gfx_mesh_desc and put index/instance data in here as well
{
	enum rjd_gfx_primitive_type primitive;
	struct rjd_gfx_mesh_buffer_desc* buffers;
	uint32_t count_buffers;
	uint32_t count_vertices;
};

struct rjd_gfx_mesh
{
	struct rjd_slot handle;
};

////////////////////////////////////////////////////////////////////////////////
// render command

struct rjd_gfx_pass_begin_desc
{
	const char* debug_label;
	struct rjd_gfx_texture render_target; // specify RJD_GFX_TEXTURE_BACKBUFFER to use the backbuffer
	struct rjd_gfx_texture depthstencil_target; // specify RJD_GFX_TEXTURE_BACKBUFFER to use the backbuffer
	struct rjd_gfx_format_value clear_color;
	struct rjd_gfx_format_value clear_depthstencil;
};

struct rjd_gfx_pass_draw_buffer_offset_desc
{
	uint32_t mesh_index;
	uint32_t buffer_index;
	uint32_t offset_bytes;
	uint32_t range_bytes;
};

struct rjd_gfx_pass_draw_desc
{
	const char* debug_label;
	const struct rjd_gfx_viewport* viewport;
	const struct rjd_gfx_pipeline_state* pipeline_state;
	const struct rjd_gfx_mesh* meshes;
	const struct rjd_gfx_pass_draw_buffer_offset_desc* buffer_offset_descs;
	const struct rjd_gfx_texture* textures;
	const uint32_t* texture_indices; // parallel array with textures
	uint32_t count_meshes;
	uint32_t count_constant_descs;
	uint32_t count_textures;
};

struct rjd_gfx_command_buffer
{
	struct rjd_slot handle;
};

////////////////////////////////////////////////////////////////////////////////
// gfx context

enum rjd_gfx_num_backbuffers
{
	RJD_GFX_NUM_BACKBUFFERS_TRIPLE,
	RJD_GFX_NUM_BACKBUFFERS_DOUBLE,
};

enum RJD_GFX_VSYNC_MODE
{
	RJD_GFX_VSYNC_MODE_ON,
	RJD_GFX_VSYNC_MODE_OFF,
};

struct rjd_gfx_context_desc
{
	struct rjd_mem_allocator* allocator;
	enum rjd_gfx_format backbuffer_color_format;
	enum rjd_gfx_format backbuffer_depth_format;
	enum rjd_gfx_num_backbuffers num_backbuffers;

	#if RJD_PLATFORM_WINDOWS
		struct {
			void* hwnd; // HWND
		} win32;
	#elif RJD_PLATFORM_OSX
		struct {
			MTKView* view;
		} osx;
	#endif
};

struct rjd_gfx_context
{
	char pimpl[176];
};

enum rjd_gfx_backend_impl
{
	RJD_GFX_BACKEND_IMPL_NONE,
	RJD_GFX_BACKEND_IMPL_METAL,
	RJD_GFX_BACKEND_IMPL_D3D11,
};

////////////////////////////////////////////////////////////////////////////////
// interface

// backend
static inline enum rjd_gfx_backend_impl rjd_gfx_backend(void);
static inline int32_t rjd_gfx_backend_ismetal(void);
static inline int32_t rjd_gfx_backend_isd3d11(void);

// context
// NOTE: all functions that deal with a context are not threadsafe for simplicity. If you are making a multithreaded
// renderer, you must have a strategy for synchronizing resource creation and drawing with the context.
struct rjd_result rjd_gfx_context_create(struct rjd_gfx_context* out, struct rjd_gfx_context_desc desc);
void rjd_gfx_context_destroy(struct rjd_gfx_context* context);

uint32_t rjd_gfx_backbuffer_current_index(const struct rjd_gfx_context* context);
struct rjd_result rjd_gfx_backbuffer_msaa_is_count_supported(const struct rjd_gfx_context* context, uint32_t sample_count);
struct rjd_result rjd_gfx_backbuffer_set_msaa_count(struct rjd_gfx_context* context, uint32_t sample_count);

struct rjd_result rjd_gfx_vsync_set(struct rjd_gfx_context* context, enum RJD_GFX_VSYNC_MODE mode);
struct rjd_result rjd_gfx_wait_for_frame_begin(struct rjd_gfx_context* context);
struct rjd_result rjd_gfx_present(struct rjd_gfx_context* context);

// commands
struct rjd_result rjd_gfx_command_buffer_create(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* out);
struct rjd_result rjd_gfx_command_pass_begin(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* cmd_buffer, const struct rjd_gfx_pass_begin_desc* command);
struct rjd_result rjd_gfx_command_pass_draw(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* cmd_buffer, const struct rjd_gfx_pass_draw_desc* command);
struct rjd_result rjd_gfx_command_buffer_commit(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* cmd_buffer);

// resources
struct rjd_result rjd_gfx_texture_create(struct rjd_gfx_context* context, struct rjd_gfx_texture* out, struct rjd_gfx_texture_desc desc);
void rjd_gfx_texture_destroy(struct rjd_gfx_context* context, struct rjd_gfx_texture* texture);
struct rjd_result rjd_gfx_shader_create(struct rjd_gfx_context* context, struct rjd_gfx_shader* out, struct rjd_gfx_shader_desc desc);
void rjd_gfx_shader_destroy(struct rjd_gfx_context* context, struct rjd_gfx_shader* shader);
struct rjd_result rjd_gfx_pipeline_state_create(struct rjd_gfx_context* context, struct rjd_gfx_pipeline_state* out, struct rjd_gfx_pipeline_state_desc desc);
void rjd_gfx_pipeline_state_destroy(struct rjd_gfx_context* context, struct rjd_gfx_pipeline_state* pipeline_state);
struct rjd_result rjd_gfx_mesh_create_vertexed(struct rjd_gfx_context* context, struct rjd_gfx_mesh* out, struct rjd_gfx_mesh_vertexed_desc desc);
struct rjd_result rjd_gfx_mesh_modify(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* cmd_buffer, struct rjd_gfx_mesh* mesh, uint32_t buffer_index, uint32_t offset, const void* data, uint32_t length);
void rjd_gfx_mesh_destroy(struct rjd_gfx_context* context, struct rjd_gfx_mesh* mesh);

// constant buffer helpers
static inline uint32_t rjd_gfx_constant_buffer_alignment(void);
static inline uint32_t rjd_gfx_calc_constant_buffer_stride(uint32_t constant_size);

// format
uint32_t rjd_gfx_format_bytesize(enum rjd_gfx_format format);
bool rjd_gfx_format_iscolor(enum rjd_gfx_format format);
bool rjd_gfx_format_isdepthstencil(enum rjd_gfx_format format);
bool rjd_gfx_format_isdepth(enum rjd_gfx_format format);
bool rjd_gfx_format_isstencil(enum rjd_gfx_format format);
double rjd_gfx_format_value_to_depth(struct rjd_gfx_format_value value);
uint8_t rjd_gfx_format_value_to_stencil(struct rjd_gfx_format_value value);

static inline struct rjd_gfx_format_value rjd_gfx_format_make_color_u8_rgba(uint8_t red, uint8_t green, uint8_t blue, uint8_t alpha);
static inline struct rjd_gfx_format_value rjd_gfx_format_make_depthstencil_f32_d32(float depth);

// constants
extern const struct rjd_gfx_texture RJD_GFX_TEXTURE_BACKBUFFER;

////////////////////////////////////////////////////////////////////////////////
// inline implementations

static inline enum rjd_gfx_backend_impl rjd_gfx_backend(void)
{
	#if RJD_GFX_BACKEND_NONE
		return RJD_GFX_BACKEND_IMPL_NONE;
	#elif RJD_GFX_BACKEND_METAL
		return RJD_GFX_BACKEND_IMPL_METAL;
	#elif RJD_GFX_BACKEND_D3D11
		return RJD_GFX_BACKEND_IMPL_D3D11;
	#endif
}

static inline int32_t rjd_gfx_backend_ismetal(void)
{
	return rjd_gfx_backend() == RJD_GFX_BACKEND_IMPL_METAL;
}

static inline int32_t rjd_gfx_backend_isd3d11(void)
{
	return rjd_gfx_backend() == RJD_GFX_BACKEND_IMPL_D3D11;
}

static inline uint32_t rjd_gfx_constant_buffer_alignment(void)
{
	#if RJD_GFX_BACKEND_METAL || RJD_GFX_BACKEND_D3D11 || RJD_GFX_BACKEND_NONE
		return 256;
	#else
		#error Unknown platform.
	#endif
}

static inline uint32_t rjd_gfx_calc_constant_buffer_stride(uint32_t constant_size)
{
	uint32_t alignment = rjd_gfx_constant_buffer_alignment();
	uint32_t aligned_stride = (constant_size % alignment) + constant_size;
	return aligned_stride;
}

static inline struct rjd_gfx_format_value rjd_gfx_format_make_color_u8_rgba(uint8_t red, uint8_t green, uint8_t blue, uint8_t alpha)
{
	struct rjd_gfx_format_value value;
	value.type = RJD_GFX_FORMAT_COLOR_U8_RGBA;
	value.color_u8_rgba[0] = red;
	value.color_u8_rgba[1] = green;
	value.color_u8_rgba[2] = blue;
	value.color_u8_rgba[3] = alpha;
    return value;
}

static inline struct rjd_gfx_format_value rjd_gfx_format_make_depthstencil_f32_d32(float depth)
{
	struct rjd_gfx_format_value value = {
		.type = RJD_GFX_FORMAT_DEPTHSTENCIL_F32_D32,
		.depthstencil_f32_d32 = depth,
	};
	return value;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

#if RJD_IMPL

static const struct rjd_logchannel logchannel_default = {
	.enabled = true,
	.name = "rjd_gfx default",
};

static const struct rjd_logchannel logchannel_error = {
	.enabled = true,
	.name = "rjd_gfx error",
};

#define RJD_GFX_LOG(...) RJD_LOG_CHANNEL(&logchannel_default, RJD_LOG_VERBOSITY_LOW, __VA_ARGS__)
#define RJD_GFX_LOG_ERROR(...) RJD_LOG_CHANNEL(&logchannel_error, RJD_LOG_VERBOSITY_LOW, __VA_ARGS__)

const struct rjd_gfx_texture RJD_GFX_TEXTURE_BACKBUFFER = {0};

////////////////////////////////////////////////////////////////////////////////
// platform-independent format

uint32_t rjd_gfx_format_bytesize(enum rjd_gfx_format format)
{
	switch (format)
	{
		case RJD_GFX_FORMAT_COLOR_U8_RGBA: return sizeof(char[4]);
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM: return sizeof(char[4]);
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM_SRGB: return sizeof(char[4]);
        case RJD_GFX_FORMAT_DEPTHSTENCIL_F32_D32: return sizeof(float);
		case RJD_GFX_FORMAT_DEPTHSTENCIL_U32_D24_S8: return sizeof(uint32_t);
		case RJD_GFX_FORMAT_COUNT: break;
	}

	RJD_ASSERTFAIL("Invalid value %d", format);
	return 0;
}

bool rjd_gfx_format_iscolor(enum rjd_gfx_format format)
{
	switch (format)
	{
		case RJD_GFX_FORMAT_COLOR_U8_RGBA: return true;
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM: return true;
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM_SRGB: return true;
        case RJD_GFX_FORMAT_DEPTHSTENCIL_F32_D32: return false;
		case RJD_GFX_FORMAT_DEPTHSTENCIL_U32_D24_S8: return false;
		case RJD_GFX_FORMAT_COUNT: break;
	}

	RJD_ASSERTFAIL("Invalid value %d", format);
	return false;
}

bool rjd_gfx_format_isdepthstencil(enum rjd_gfx_format format)
{
	bool is_depth = rjd_gfx_format_isdepth(format);
	bool is_stencil = rjd_gfx_format_isstencil(format);
	return is_depth || is_stencil;
}

bool rjd_gfx_format_isdepth(enum rjd_gfx_format format)
{
	switch (format)
	{
		case RJD_GFX_FORMAT_COLOR_U8_RGBA: return false;
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM: return false;
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM_SRGB: return false;
        case RJD_GFX_FORMAT_DEPTHSTENCIL_F32_D32: return true;
		case RJD_GFX_FORMAT_DEPTHSTENCIL_U32_D24_S8: return true;
		case RJD_GFX_FORMAT_COUNT: break;
	}

	RJD_ASSERTFAIL("Invalid value %d", format);
	return false;

}

bool rjd_gfx_format_isstencil(enum rjd_gfx_format format)
{
	switch (format)
	{
		case RJD_GFX_FORMAT_COLOR_U8_RGBA: return false;
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM: return false;
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM_SRGB: return false;
        case RJD_GFX_FORMAT_DEPTHSTENCIL_F32_D32: return false;
		case RJD_GFX_FORMAT_DEPTHSTENCIL_U32_D24_S8: return true;
		case RJD_GFX_FORMAT_COUNT: break;
	}

	RJD_ASSERTFAIL("Invalid value %d", format);
	return false;
}

double rjd_gfx_format_value_to_depth(struct rjd_gfx_format_value value)
{
	switch (value.type)
	{
		case RJD_GFX_FORMAT_COLOR_U8_RGBA:
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM:
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM_SRGB:
			RJD_ASSERTFAIL("color values shouldn't be passed to this function");
			break;

		case RJD_GFX_FORMAT_DEPTHSTENCIL_F32_D32: return value.depthstencil_f32_d32;
		case RJD_GFX_FORMAT_DEPTHSTENCIL_U32_D24_S8: return value.depthstencil_u32_d24_s8.parts.depth;
		case RJD_GFX_FORMAT_COUNT: break;
	}

	RJD_ASSERTFAIL("Unhandled format %d.", value.type);
	return 0;
}

uint8_t rjd_gfx_format_value_to_stencil(struct rjd_gfx_format_value value)
{
	switch (value.type)
	{
		case RJD_GFX_FORMAT_COLOR_U8_RGBA:
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM:
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM_SRGB:
			RJD_ASSERTFAIL("color values shouldn't be passed to this function");
			break;

        case RJD_GFX_FORMAT_DEPTHSTENCIL_F32_D32: return 0;
		case RJD_GFX_FORMAT_DEPTHSTENCIL_U32_D24_S8: return (uint8_t)value.depthstencil_u32_d24_s8.parts.stencil; // stencil is 8 bits so the cast is fine
        case RJD_GFX_FORMAT_COUNT: break;
    }

	RJD_ASSERTFAIL("Unhandled format %d.", value.type);
	return 0;
}

////////////////////////////////////////////////////////////////////////////////
// gfx metal and d3d11 implementation is in API-specific headers

#if RJD_GFX_BACKEND_NONE

struct rjd_result rjd_gfx_context_create(struct rjd_gfx_context* out, struct rjd_gfx_context_desc desc) 
{ 
	RJD_UNUSED_PARAM(out);
	RJD_UNUSED_PARAM(desc);
	return RJD_RESULT("Unimplemented"); 
}
void rjd_gfx_context_destroy(struct rjd_gfx_context* context)
{
	RJD_UNUSED_PARAM(context);
}
uint32_t rjd_gfx_backbuffer_current_index(const struct rjd_gfx_context* context) 
{
	RJD_UNUSED_PARAM(context);
	return 0; 
}
struct rjd_result rjd_gfx_backbuffer_msaa_is_count_supported(const struct rjd_gfx_context* context, uint32_t sample_count) 
{
	RJD_UNUSED_PARAM(context);
	RJD_UNUSED_PARAM(sample_count);
	return RJD_RESULT("Unimplemented"); 
}
struct rjd_result rjd_gfx_backbuffer_set_msaa_count(struct rjd_gfx_context* context, uint32_t sample_count)
{
	RJD_UNUSED_PARAM(context);
	RJD_UNUSED_PARAM(sample_count);
	return RJD_RESULT("Unimplemented"); 
}
struct rjd_result rjd_gfx_vsync_set(struct rjd_gfx_context* context, enum RJD_GFX_VSYNC_MODE mode) 
{
	RJD_UNUSED_PARAM(context);
	RJD_UNUSED_PARAM(mode);
	return RJD_RESULT("Unimplemented"); 
}
struct rjd_result rjd_gfx_wait_for_frame_begin(struct rjd_gfx_context* context) 
{
	RJD_UNUSED_PARAM(context);
	return RJD_RESULT("Unimplemented"); 
}
struct rjd_result rjd_gfx_present(struct rjd_gfx_context* context) 
{
	RJD_UNUSED_PARAM(context);
	return RJD_RESULT("Unimplemented"); 
}
struct rjd_result rjd_gfx_command_buffer_create(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* out)
{
	RJD_UNUSED_PARAM(context);
	RJD_UNUSED_PARAM(out);
	return RJD_RESULT("Unimplemented");
}
struct rjd_result rjd_gfx_command_pass_begin(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* cmd_buffer, const struct rjd_gfx_pass_begin_desc* command)
{
	RJD_UNUSED_PARAM(context);
	RJD_UNUSED_PARAM(cmd_buffer);
	RJD_UNUSED_PARAM(command);
	return RJD_RESULT("Unimplemented");
}
struct rjd_result rjd_gfx_command_pass_draw(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* cmd_buffer, const struct rjd_gfx_pass_draw_desc* command)
{
	RJD_UNUSED_PARAM(context);
	RJD_UNUSED_PARAM(cmd_buffer);
	RJD_UNUSED_PARAM(command);
	return RJD_RESULT("Unimplemented");
}
struct rjd_result rjd_gfx_command_buffer_commit(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* cmd_buffer)
{
	RJD_UNUSED_PARAM(context);
	RJD_UNUSED_PARAM(cmd_buffer);
	return RJD_RESULT("Unimplemented");
}
struct rjd_result rjd_gfx_texture_create(struct rjd_gfx_context* context, struct rjd_gfx_texture* out, struct rjd_gfx_texture_desc desc)
{
	RJD_UNUSED_PARAM(context);
	RJD_UNUSED_PARAM(out);
	RJD_UNUSED_PARAM(desc);
	return RJD_RESULT("Unimplemented"); 
}
void rjd_gfx_texture_destroy(struct rjd_gfx_context* context, struct rjd_gfx_texture* texture)
{
	RJD_UNUSED_PARAM(context);
	RJD_UNUSED_PARAM(texture);
}
struct rjd_result rjd_gfx_shader_create(struct rjd_gfx_context* context, struct rjd_gfx_shader* out, struct rjd_gfx_shader_desc desc)
{
	RJD_UNUSED_PARAM(context);
	RJD_UNUSED_PARAM(out);
	RJD_UNUSED_PARAM(desc);
	return RJD_RESULT("Unimplemented");
}
void rjd_gfx_shader_destroy(struct rjd_gfx_context* context, struct rjd_gfx_shader* shader)
{
	RJD_UNUSED_PARAM(context);
	RJD_UNUSED_PARAM(shader);
}
struct rjd_result rjd_gfx_pipeline_state_create(struct rjd_gfx_context* context, struct rjd_gfx_pipeline_state* out, struct rjd_gfx_pipeline_state_desc desc)
{
	RJD_UNUSED_PARAM(context);
	RJD_UNUSED_PARAM(out);
	RJD_UNUSED_PARAM(desc);
	return RJD_RESULT("Unimplemented"); 
}
void rjd_gfx_pipeline_state_destroy(struct rjd_gfx_context* context, struct rjd_gfx_pipeline_state* pipeline_state)
{
	RJD_UNUSED_PARAM(context);
	RJD_UNUSED_PARAM(pipeline_state);
}
struct rjd_result rjd_gfx_mesh_create_vertexed(struct rjd_gfx_context* context, struct rjd_gfx_mesh* out, struct rjd_gfx_mesh_vertexed_desc desc)
{
	RJD_UNUSED_PARAM(context);
	RJD_UNUSED_PARAM(out);
	RJD_UNUSED_PARAM(desc);
	return RJD_RESULT("Unimplemented"); 
}
struct rjd_result rjd_gfx_mesh_modify(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* cmd_buffer, struct rjd_gfx_mesh* mesh, uint32_t buffer_index, uint32_t offset, const void* data, uint32_t length)
{
	RJD_UNUSED_PARAM(context);
	RJD_UNUSED_PARAM(cmd_buffer);
	RJD_UNUSED_PARAM(mesh);
	RJD_UNUSED_PARAM(buffer_index);
	RJD_UNUSED_PARAM(offset);
	RJD_UNUSED_PARAM(data);
	RJD_UNUSED_PARAM(length);
	return RJD_RESULT("Unimplemented"); 
}
void rjd_gfx_mesh_destroy(struct rjd_gfx_context* context, struct rjd_gfx_mesh* mesh)
{
	RJD_UNUSED_PARAM(context);
	RJD_UNUSED_PARAM(mesh);
}

#endif // RJD_GFX_BACKEND_NONE
#endif // RJD_IMPL

////////////////////////////////////////////////////////////////////////////////
// rjd_gfx_metal.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_GFX_METAL_H 1

#if RJD_IMPL && RJD_GFX_BACKEND_METAL

#if !RJD_PLATFORM_OSX
	#error "Metal backend is only supported on OSX."
#endif

#if !RJD_GFX_H
	#error "This header depends on rjd_gfx.h"
#endif

////////////////////////////////////////////////////////////////////////////////
// includes/libs
#import <Metal/Metal.h>
#import <MetalKit/MetalKit.h>

////////////////////////////////////////////////////////////////////////////////
// data

struct rjd_gfx_texture_metal
{
	id <MTLTexture> texture;
};

struct rjd_gfx_shader_metal
{
	id<MTLLibrary> library;
	id<MTLFunction> function;
};

struct rjd_gfx_pipeline_state_metal
{
	id<MTLRenderPipelineState> state_render;
	id<MTLDepthStencilState> state_depthstencil;
	enum rjd_gfx_cull cull_mode;
	enum rjd_gfx_winding_order winding_order;
};

struct rjd_gfx_mesh_shader_buffer_metal
{
	id<MTLBuffer> buffer;
	enum rjd_gfx_mesh_buffer_usage_flags usage_flags;
	uint32_t shader_slot;
};

struct rjd_gfx_mesh_index_buffer_metal
{
	id<MTLBuffer> buffer;
	enum rjd_gfx_index_type type;
	uint32_t count_indices;
};

struct rjd_gfx_mesh_metal
{
	struct rjd_gfx_mesh_shader_buffer_metal* shader_buffers;
	struct rjd_gfx_mesh_index_buffer_metal* index_buffers;
	uint32_t count_vertices; // 0 if using index_buffers
	uint32_t instance_count; // 0 if it's not instanced
	enum rjd_gfx_primitive_type primitive;
};

struct rjd_gfx_command_buffer_metal
{
	id <MTLCommandBuffer> buffer;
	id<MTLRenderCommandEncoder> encoder;
};

struct rjd_gfx_context_metal
{
	struct rjd_gfx_texture_metal* slotmap_textures;
	struct rjd_gfx_shader_metal* slotmap_shaders;
	struct rjd_gfx_pipeline_state_metal* slotmap_pipeline_states;
	struct rjd_gfx_mesh_metal* slotmap_meshes;
	struct rjd_gfx_command_buffer_metal* slotmap_command_buffers;

	MTKView* view;
	id <MTLDevice> device;
	id <MTLCommandQueue> command_queue;
	MTKMeshBufferAllocator* loader_mesh;

	struct rjd_mem_allocator* allocator;

	dispatch_semaphore_t wait_for_present_counter;
	uint32_t backbuffer_index;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_gfx_context_metal) <= sizeof(struct rjd_gfx_context));

////////////////////////////////////////////////////////////////////////////////
// private helpers

static MTLPixelFormat rjd_gfx_format_color_to_metal(enum rjd_gfx_format format);
static MTLClearColor rjd_gfx_format_value_to_clearcolor(struct rjd_gfx_format_value value);
static bool rjd_gfx_format_isbackbuffercompatible(enum rjd_gfx_format format);

static bool rjd_gfx_mtlformat_is_depth(MTLPixelFormat format);
static bool rjd_gfx_mtlformat_is_stencil(MTLPixelFormat format);

static MTLVertexFormat rjd_gfx_vertex_format_type_to_metal(enum rjd_gfx_vertex_format_type type);
static MTLVertexStepFunction rjd_gfx_vertex_format_step_to_metal(enum rjd_gfx_vertex_format_step step);
static MTLIndexType rjd_gfx_index_type_to_metal(enum rjd_gfx_index_type type);
static MTLPrimitiveType rjd_gfx_primitive_type_to_metal(enum rjd_gfx_primitive_type type);
static MTLCompareFunction rjd_gfx_depth_compare_to_metal(enum rjd_gfx_depth_compare func);
static MTLWinding rjd_gfx_winding_to_metal(enum rjd_gfx_winding_order winding_order);
static MTLCullMode rjd_gfx_cull_to_metal(enum rjd_gfx_cull cull_mode);

static bool rjd_gfx_texture_isbackbuffer(struct rjd_gfx_texture texture);

static inline void rjd_gfx_texture_destroy_metal(struct rjd_gfx_context_metal* context, struct rjd_slot slot);
static inline void rjd_gfx_shader_destroy_metal(struct rjd_gfx_context_metal* context, struct rjd_slot slot);
static inline void rjd_gfx_pipeline_state_destroy_metal(struct rjd_gfx_context_metal* context, struct rjd_slot slot);
static inline void rjd_gfx_mesh_destroy_metal(struct rjd_gfx_context_metal* context, struct rjd_slot slot);
static inline void rjd_gfx_command_buffer_destroy_metal(struct rjd_gfx_context_metal* context, struct rjd_slot slot);

////////////////////////////////
// render control

struct rjd_result rjd_gfx_context_create(struct rjd_gfx_context* out, struct rjd_gfx_context_desc desc)
{
	RJD_ASSERT(out);

	MTKView* view = desc.osx.view;
    if(!view.device) {
        return RJD_RESULT("You must pass a view with an already-initialized Metal device");
    }

	if (!rjd_gfx_format_isbackbuffercompatible(desc.backbuffer_color_format)) {
		return RJD_RESULT("Unsupported backbuffer color format. Supported values are:\n"
						  "\tRJD_GFX_FORMAT_COLOR_U8_BGRA_NORM\n"
                          "\tRJD_GFX_FORMAT_COLOR_U8_BGRA_NORM_SRGB\n");
	}

	if (!rjd_gfx_format_isdepthstencil(desc.backbuffer_depth_format)) {
		return RJD_RESULT("backbuffer_depth_format must be a depth format. See rjd_gfx_format_isdepthstencil().");
	}

	if (desc.num_backbuffers != RJD_GFX_NUM_BACKBUFFERS_TRIPLE) {
		return RJD_RESULT("The Metal backend currently only supports triple buffering. Use RJD_GFX_NUM_BACKBUFFERS_TRIPLE.");
	}

	{
		const MTLPixelFormat mtl_color_format = rjd_gfx_format_color_to_metal(desc.backbuffer_color_format);
		const MTLPixelFormat mtl_depth_format = rjd_gfx_format_color_to_metal(desc.backbuffer_depth_format);

        view.colorPixelFormat = mtl_color_format;
        view.depthStencilPixelFormat = mtl_depth_format;
		view.sampleCount = 1; // users can set this higher later with rjd_gfx_backbuffer_set_msaa_count()
	}

	struct rjd_gfx_context_metal* context_metal = (struct rjd_gfx_context_metal*)out;
    memset(out, 0, sizeof(*out));

	context_metal->slotmap_textures			= rjd_slotmap_alloc(struct rjd_gfx_texture_metal, 64, desc.allocator);
	context_metal->slotmap_shaders			= rjd_slotmap_alloc(struct rjd_gfx_shader_metal, 64, desc.allocator);
	context_metal->slotmap_pipeline_states	= rjd_slotmap_alloc(struct rjd_gfx_pipeline_state_metal, 64, desc.allocator);
	context_metal->slotmap_meshes			= rjd_slotmap_alloc(struct rjd_gfx_mesh_metal, 64, desc.allocator);
	context_metal->slotmap_command_buffers	= rjd_slotmap_alloc(struct rjd_gfx_command_buffer_metal, 16, desc.allocator);

	context_metal->view = view;
	context_metal->device = view.device;
	context_metal->command_queue = [context_metal->device newCommandQueue];
	context_metal->loader_mesh = [[MTKMeshBufferAllocator alloc] initWithDevice:context_metal->device];
    context_metal->allocator = desc.allocator;
	context_metal->wait_for_present_counter = dispatch_semaphore_create(3);
	context_metal->backbuffer_index = 0;

	return RJD_RESULT_OK();
}

struct rjd_result rjd_gfx_wait_for_frame_begin(struct rjd_gfx_context* context)
{
	struct rjd_gfx_context_metal* context_metal = (struct rjd_gfx_context_metal*)context;
	dispatch_semaphore_wait(context_metal->wait_for_present_counter, DISPATCH_TIME_FOREVER);

	return RJD_RESULT_OK();
}

struct rjd_result rjd_gfx_present(struct rjd_gfx_context* context)
{
	// NOTE: this is a no-op for metal since presenting is handled via presentDrawable()
	// which is invoked after the command buffer has finished executing all commands

    RJD_UNUSED_PARAM(context);
	return RJD_RESULT_OK();
}

uint32_t rjd_gfx_backbuffer_current_index(const struct rjd_gfx_context* context)
{
	struct rjd_gfx_context_metal* context_metal = (struct rjd_gfx_context_metal*)context;
	return context_metal->backbuffer_index;
}

struct rjd_result rjd_gfx_backbuffer_msaa_is_count_supported(const struct rjd_gfx_context* context, uint32_t sample_count)
{
	RJD_ASSERT(context);

	const struct rjd_gfx_context_metal* context_metal = (struct rjd_gfx_context_metal*)context;
    BOOL supported = [context_metal->device supportsTextureSampleCount:(NSUInteger)sample_count];
	return supported ? RJD_RESULT_OK() : RJD_RESULT("The MSAA count is not supported.");
}

struct rjd_result rjd_gfx_backbuffer_set_msaa_count(struct rjd_gfx_context* context, uint32_t sample_count)
{
	RJD_ASSERT(context);

	struct rjd_result result = rjd_gfx_backbuffer_msaa_is_count_supported(context, sample_count);
	if (!rjd_result_isok(result)) {
		return result;
	}

	struct rjd_gfx_context_metal* context_metal = (struct rjd_gfx_context_metal*)context;
	context_metal->view.sampleCount = sample_count;
	return RJD_RESULT_OK();
}

void rjd_gfx_context_destroy(struct rjd_gfx_context* context)
{
	RJD_ASSERT(context);

	struct rjd_gfx_context_metal* context_metal = (struct rjd_gfx_context_metal*)context;
	
	struct rjd_gfx_texture_metal* textures = context_metal->slotmap_textures;
	struct rjd_gfx_shader_metal* shaders = context_metal->slotmap_shaders;
	struct rjd_gfx_pipeline_state_metal* states = context_metal->slotmap_pipeline_states;
	struct rjd_gfx_mesh_metal* meshes = context_metal->slotmap_meshes;
	struct rjd_gfx_command_buffer_metal* commands = context_metal->slotmap_command_buffers;

	for (struct rjd_slot s = rjd_slotmap_next(textures, NULL); !rjd_slot_isvalid(s); s = rjd_slotmap_next(textures, &s)) {
		rjd_gfx_texture_destroy_metal(context_metal, s);
	}

	for (struct rjd_slot s = rjd_slotmap_next(shaders, NULL); !rjd_slot_isvalid(s); s = rjd_slotmap_next(shaders, &s)) {
		rjd_gfx_shader_destroy_metal(context_metal, s);
	}

	for (struct rjd_slot s = rjd_slotmap_next(states, NULL); !rjd_slot_isvalid(s); s = rjd_slotmap_next(states, &s)) {
		rjd_gfx_pipeline_state_destroy_metal(context_metal, s);
	}

	for (struct rjd_slot s = rjd_slotmap_next(meshes, NULL); !rjd_slot_isvalid(s); s = rjd_slotmap_next(meshes, &s)) {
		rjd_gfx_mesh_destroy_metal(context_metal, s);
	}

	for (struct rjd_slot s = rjd_slotmap_next(commands, NULL); !rjd_slot_isvalid(s); s = rjd_slotmap_next(commands, &s)) {
		rjd_gfx_command_buffer_destroy_metal(context_metal, s);
	}

	rjd_slotmap_free(textures);
	rjd_slotmap_free(shaders);
	rjd_slotmap_free(states);
	rjd_slotmap_free(meshes);
	rjd_slotmap_free(commands);

	context_metal->slotmap_textures			= NULL;
	context_metal->slotmap_shaders			= NULL;
	context_metal->slotmap_pipeline_states	= NULL;
	context_metal->slotmap_meshes			= NULL;
	context_metal->slotmap_command_buffers	= NULL;
}

struct rjd_result rjd_gfx_vsync_set(struct rjd_gfx_context* context, enum RJD_GFX_VSYNC_MODE mode)
{
	RJD_UNUSED_PARAM(context);
	RJD_UNUSED_PARAM(mode);
	return RJD_RESULT("unimplemented");
}

struct rjd_result rjd_gfx_command_buffer_create(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* out)
{
	RJD_ASSERT(context);
	RJD_ASSERT(out);

	struct rjd_gfx_context_metal* context_metal = (struct rjd_gfx_context_metal*)context;
	struct rjd_gfx_command_buffer_metal buffer = {
		.buffer = [context_metal->command_queue commandBuffer],
	};

	rjd_slotmap_insert(context_metal->slotmap_command_buffers, buffer, &out->handle);

	return RJD_RESULT_OK();
}

struct rjd_result rjd_gfx_command_pass_begin(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* cmd_buffer, const struct rjd_gfx_pass_begin_desc* command)
{
	RJD_ASSERT(rjd_slot_isvalid(cmd_buffer->handle));
	RJD_ASSERT(command);
	RJD_ASSERT(context);

	struct rjd_gfx_context_metal* context_metal = (struct rjd_gfx_context_metal*)context;
    struct rjd_gfx_command_buffer_metal* cmd_buffer_metal = rjd_slotmap_get(context_metal->slotmap_command_buffers, cmd_buffer->handle);

	if (cmd_buffer_metal->encoder != nil) {
    	[cmd_buffer_metal->encoder endEncoding];
		cmd_buffer_metal->encoder = nil;
	}

	MTLRenderPassDescriptor* render_pass = NULL;
	if (rjd_gfx_texture_isbackbuffer(command->render_target))
	{
		if (context_metal->view.currentDrawable) {
	        render_pass = context_metal->view.currentRenderPassDescriptor;
		} else {
			return RJD_RESULT("All backbuffers are in use. The app is likely GPU-bound.");
		}
	}
	else
	{
		struct rjd_gfx_texture_metal* texture_metal = rjd_slotmap_get(context_metal->slotmap_textures, command->render_target.handle);
		id<MTLTexture> texture = texture_metal->texture;
		if (texture.usage != MTLTextureUsageRenderTarget) {
			return RJD_RESULT("Specified texture is not a render target");
		}

		render_pass = [MTLRenderPassDescriptor renderPassDescriptor];
		render_pass.colorAttachments[0].texture = texture;
	}

    if (rjd_gfx_format_iscolor(command->clear_color.type)) {
        const MTLClearColor color = rjd_gfx_format_value_to_clearcolor(command->clear_color);
        render_pass.colorAttachments[0].clearColor = color;
    }

	if (rjd_gfx_texture_isbackbuffer(command->depthstencil_target) == false) {
		struct rjd_gfx_texture_metal* texture_metal = rjd_slotmap_get(context_metal->slotmap_textures, command->depthstencil_target.handle);
		id<MTLTexture> texture = texture_metal->texture;
		render_pass.depthAttachment.texture = texture;
	}

	if (rjd_gfx_format_isdepthstencil(command->clear_depthstencil.type)) {
        if (render_pass.depthAttachment) {
            const double depth = rjd_gfx_format_value_to_depth(command->clear_depthstencil);
            render_pass.depthAttachment.clearDepth = depth;
        }

        if (render_pass.stencilAttachment) {
            const uint32_t stencil = rjd_gfx_format_value_to_stencil(command->clear_depthstencil);
            render_pass.stencilAttachment.clearStencil = stencil;
        }
    }

	id<MTLRenderCommandEncoder> encoder = [cmd_buffer_metal->buffer renderCommandEncoderWithDescriptor:render_pass];
	const char* label = command->debug_label ? command->debug_label : "rjd_gfx_command_pass_begin";
	encoder.label = [NSString stringWithUTF8String:label];

	cmd_buffer_metal->encoder = encoder;
    
    return RJD_RESULT_OK();
}

struct rjd_result rjd_gfx_command_pass_draw(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* cmd_buffer, const struct rjd_gfx_pass_draw_desc* command)
{
	RJD_ASSERT(context);
	RJD_ASSERT(cmd_buffer);
	RJD_ASSERT(command);
    RJD_ASSERT(command->viewport);
    RJD_ASSERT(command->pipeline_state);
    RJD_ASSERT(command->meshes);
	RJD_ASSERT(rjd_slot_isvalid(cmd_buffer->handle));
	RJD_ASSERT(rjd_slot_isvalid(command->pipeline_state->handle));

	struct rjd_gfx_context_metal* context_metal = (struct rjd_gfx_context_metal*)context;
    struct rjd_gfx_command_buffer_metal* cmd_buffer_metal = rjd_slotmap_get(context_metal->slotmap_command_buffers, cmd_buffer->handle);
	const struct rjd_gfx_pipeline_state_metal* pipeline_metal = rjd_slotmap_get(context_metal->slotmap_pipeline_states, command->pipeline_state->handle);

	RJD_ASSERTMSG(cmd_buffer_metal->encoder != nil, "You must call rjd_gfx_command_pass_begin before issuing draw commands.");
	id<MTLRenderCommandEncoder> encoder = cmd_buffer_metal->encoder;

    [encoder pushDebugGroup:[NSString stringWithUTF8String:command->debug_label]];

	const MTLWinding winding_order_metal = rjd_gfx_winding_to_metal(pipeline_metal->winding_order);
	const MTLCullMode cull_mode_metal = rjd_gfx_cull_to_metal(pipeline_metal->cull_mode);

    [encoder setRenderPipelineState:pipeline_metal->state_render];
    [encoder setDepthStencilState:pipeline_metal->state_depthstencil];
    [encoder setFrontFacingWinding:winding_order_metal];
    [encoder setCullMode:cull_mode_metal];

	for (uint32_t i = 0; i < command->count_textures; ++i) {
		const struct rjd_gfx_texture* texture = command->textures + i;
        RJD_ASSERT(rjd_slot_isvalid(texture->handle));
		struct rjd_gfx_texture_metal* texture_metal = rjd_slotmap_get(context_metal->slotmap_textures, texture->handle);

		const uint32_t* index = command->texture_indices + i;
		[encoder setFragmentTexture:texture_metal->texture atIndex:*index];
	}

	// TODO add functionality to draw portions of an uploaded buffer. For simplicity, currently you must draw the entire buffer.
	for (uint32_t mesh_index = 0; mesh_index < command->count_meshes; ++mesh_index) {
        const struct rjd_gfx_mesh* mesh = command->meshes + mesh_index;
        RJD_ASSERT(rjd_slot_isvalid(mesh->handle));
		const struct rjd_gfx_mesh_metal* mesh_metal = rjd_slotmap_get(context_metal->slotmap_meshes, mesh->handle);

		// shader buffers
		for (uint32_t buffer_index = 0; buffer_index < rjd_array_count(mesh_metal->shader_buffers); ++buffer_index) {
			struct rjd_gfx_mesh_shader_buffer_metal* buffer = mesh_metal->shader_buffers + buffer_index;

			const struct rjd_gfx_pass_draw_buffer_offset_desc* buffer_offset_desc = NULL;
			for (size_t desc_index = 0; desc_index < command->count_constant_descs; ++desc_index) {
				const struct rjd_gfx_pass_draw_buffer_offset_desc* desc = command->buffer_offset_descs + desc_index;
				if (desc->mesh_index == mesh_index && desc->buffer_index == buffer_index) {
					buffer_offset_desc = desc;
				}
			}
			uint32_t offset = buffer_offset_desc ? buffer_offset_desc->offset_bytes : 0;

			if (buffer->usage_flags & RJD_GFX_MESH_BUFFER_USAGE_VERTEX) {
				[encoder setVertexBuffer:buffer->buffer offset:offset atIndex:buffer->shader_slot];
			}

			if (buffer->usage_flags & RJD_GFX_MESH_BUFFER_USAGE_VERTEX_CONSTANT ||
				buffer->usage_flags & RJD_GFX_MESH_BUFFER_USAGE_PIXEL_CONSTANT) {

				if (buffer->usage_flags & RJD_GFX_MESH_BUFFER_USAGE_VERTEX_CONSTANT) {
					[encoder setVertexBuffer:buffer->buffer offset:offset atIndex:buffer->shader_slot];
				}

				if (buffer->usage_flags & RJD_GFX_MESH_BUFFER_USAGE_PIXEL_CONSTANT) {
					[encoder setFragmentBuffer:buffer->buffer offset:offset atIndex:buffer->shader_slot];
				}
			}
		}

		const MTLPrimitiveType primitive = rjd_gfx_primitive_type_to_metal(mesh_metal->primitive);

		if (mesh_metal->count_vertices > 0) {
			if (mesh_metal->instance_count) {
				[encoder drawPrimitives:primitive vertexStart:0 vertexCount:mesh_metal->count_vertices instanceCount:mesh_metal->instance_count];
			} else {
				[encoder drawPrimitives:primitive vertexStart:0 vertexCount:mesh_metal->count_vertices];
			}
		}

		if (mesh_metal->index_buffers) {
			for (uint32_t i = 0; i < rjd_array_count(mesh_metal->index_buffers); ++i) {
				struct rjd_gfx_mesh_index_buffer_metal* indices = mesh_metal->index_buffers + i;
				const MTLIndexType type = rjd_gfx_index_type_to_metal(indices->type);

				if (mesh_metal->instance_count) {
					[encoder drawIndexedPrimitives:primitive 
							 indexCount:indices->count_indices 
							 indexType:type
                             indexBuffer:indices->buffer
							 indexBufferOffset:0 
							 instanceCount:mesh_metal->instance_count];
				} else {
					[encoder drawIndexedPrimitives:primitive 
							 indexCount:indices->count_indices 
							 indexType:type 
							 indexBuffer:indices->buffer
							 indexBufferOffset:0];
				}
			}
		}
	}

    [encoder popDebugGroup];

	return RJD_RESULT_OK();
}

struct rjd_result rjd_gfx_command_buffer_commit(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* cmd_buffer)
{
	RJD_ASSERT(cmd_buffer);
	RJD_ASSERT(context);
	RJD_ASSERT(rjd_slot_isvalid(cmd_buffer->handle));

	struct rjd_gfx_context_metal* context_metal = (struct rjd_gfx_context_metal*)context;
	struct rjd_gfx_command_buffer_metal* cmd_buffer_metal = rjd_slotmap_get(context_metal->slotmap_command_buffers, cmd_buffer->handle);

	RJD_ASSERTMSG(cmd_buffer_metal->encoder != nil, "You must call rjd_gfx_command_pass_begin before issuing draw commands.");
    [cmd_buffer_metal->encoder endEncoding];

	[cmd_buffer_metal->buffer presentDrawable:context_metal->view.currentDrawable];
	
    __block dispatch_semaphore_t wait_counter = context_metal->wait_for_present_counter;
    [cmd_buffer_metal->buffer addCompletedHandler:^(id<MTLCommandBuffer> buffer)
    {
		RJD_UNUSED_PARAM(buffer);
    	dispatch_semaphore_signal(wait_counter);
    }];

	[cmd_buffer_metal->buffer commit];
	rjd_gfx_command_buffer_destroy_metal(context_metal, cmd_buffer->handle);
    rjd_slot_invalidate(&cmd_buffer->handle);

	context_metal->backbuffer_index = (context_metal->backbuffer_index + 1) % 3; // MTKView has a pool of 3 drawables

	return RJD_RESULT_OK();
}

////////////////////////////////
// resources

struct rjd_result rjd_gfx_texture_create(struct rjd_gfx_context* context, struct rjd_gfx_texture* out, struct rjd_gfx_texture_desc desc)
{
	RJD_ASSERT(out);
	RJD_ASSERT(context);

	RJD_RESULT_CHECK(desc.usage == RJD_GFX_TEXTURE_USAGE_RENDERTARGET || desc.data != NULL, "Non-rendertarget texture data must not be NULL");
	RJD_RESULT_CHECK(desc.usage == RJD_GFX_TEXTURE_USAGE_RENDERTARGET || desc.data_length != 0, "Non-rendertarget texture data length must not be 0");
	RJD_RESULT_CHECK(desc.pixels_width != 0, "Texture width must not be 0");
	RJD_RESULT_CHECK(desc.pixels_height != 0, "Texture height must not be 0");

	struct rjd_gfx_context_metal* context_metal = (struct rjd_gfx_context_metal*)context;

    id<MTLTexture> texture = nil;
	{
		MTLTextureDescriptor* descriptor = [[MTLTextureDescriptor alloc] init];
		descriptor.textureType = MTLTextureType2D;
		descriptor.pixelFormat = rjd_gfx_format_color_to_metal(desc.format);
		descriptor.width = desc.pixels_width;
		descriptor.height = desc.pixels_height;
		descriptor.depth = 1; // Always 1 for 2D textures
		descriptor.mipmapLevelCount = 1; // TODO support mipmaps
		descriptor.sampleCount = 1; // Always 1 unless this is a MTLTextureType2DMultisample
		descriptor.arrayLength = 1;

        MTLResourceOptions buffer_options;
		switch (desc.access)
		{
			case RJD_GFX_TEXTURE_ACCESS_CPU_NONE_GPU_READWRITE:
				descriptor.cpuCacheMode = MTLCPUCacheModeDefaultCache;
				descriptor.storageMode = MTLStorageModePrivate;
				descriptor.allowGPUOptimizedContents = YES;
                buffer_options = MTLResourceStorageModePrivate;
				break;
			case RJD_GFX_TEXTURE_ACCESS_CPU_WRITE_GPU_READWRITE:
				descriptor.cpuCacheMode = MTLCPUCacheModeWriteCombined;
				descriptor.allowGPUOptimizedContents = NO;
                buffer_options = MTLResourceStorageModeManaged | MTLResourceCPUCacheModeWriteCombined;
				break;
            case RJD_GFX_TEXTURE_ACCESS_COUNT:
                RJD_ASSERTFAIL("RJD_GFX_TEXTURE_ACCESS_COUNT is not a valid access.")
                break;
		}

		switch (desc.usage)
		{
			case RJD_GFX_TEXTURE_USAGE_DEFAULT: 
				descriptor.usage = MTLTextureUsageShaderRead;
				break;
			case RJD_GFX_TEXTURE_USAGE_RENDERTARGET: 
				descriptor.usage = MTLTextureUsageRenderTarget;
				break;
			case RJD_GFX_TEXTURE_USAGE_COUNT:
				RJD_ASSERTFAIL("Unhandled case %d", desc.usage);
				break;
		}

		// TODO support no bytes for render targets
        id<MTLBuffer> buffer = [context_metal->device newBufferWithBytes:desc.data length:desc.data_length options:buffer_options];
        
        const NSUInteger bytes_per_row = rjd_gfx_format_bytesize(desc.format) * desc.pixels_width;
        texture = [buffer newTextureWithDescriptor:descriptor offset:0 bytesPerRow:bytes_per_row];
        MTLRegion region = {
            .origin = {0,0,0},
            .size = { desc.pixels_width, desc.pixels_height, 1 },
        };
        [texture replaceRegion:region mipmapLevel:0 withBytes:desc.data bytesPerRow:bytes_per_row];

        const char* label = desc.debug_label ? desc.debug_label : "anonymous_texture";
        texture.label = [NSString stringWithUTF8String:label];
	}

	struct rjd_gfx_texture_metal texture_metal = {
		.texture = texture,
	};

	rjd_slotmap_insert(context_metal->slotmap_textures, texture_metal, &out->handle);

	return RJD_RESULT_OK();
}

void rjd_gfx_texture_destroy(struct rjd_gfx_context* context, struct rjd_gfx_texture* texture)
{
	RJD_ASSERT(texture);
	RJD_ASSERT(context);
	RJD_ASSERT(rjd_slot_isvalid(texture->handle));

	struct rjd_gfx_context_metal* context_metal = (struct rjd_gfx_context_metal*)context;

	rjd_gfx_texture_destroy_metal(context_metal, texture->handle);
}

struct rjd_result rjd_gfx_shader_create(struct rjd_gfx_context* context, struct rjd_gfx_shader* out, struct rjd_gfx_shader_desc desc)
{
	RJD_ASSERT(out);
	RJD_ASSERT(context);
	RJD_ASSERTMSG(((char*)desc.data)[desc.count_data] == '\0', "Expected a null-terminated string for the data.");
    
    struct rjd_gfx_context_metal* context_metal = (struct rjd_gfx_context_metal*)context;

	NSString* source = [NSString stringWithUTF8String:desc.data];
	MTLCompileOptions* options = [[MTLCompileOptions alloc] init];
	NSError* error = NULL;
	id<MTLLibrary> library = [context_metal->device newLibraryWithSource:source options:options error:&error];

	if (error) {
		RJD_GFX_LOG_ERROR("Error compiling shader: %s", error.localizedDescription.UTF8String);
		return RJD_RESULT("Error compiling shaders");
	}

	NSString* function_name = [NSString stringWithUTF8String:desc.function_name];
	id<MTLFunction> function = [library newFunctionWithName:function_name];

	if (function == nil) {
		return RJD_RESULT("The shader source did not have the specified function name.");
	}

	struct rjd_gfx_shader_metal shader_metal = {
		.library = library,
		.function = function,
	};
    
	rjd_slotmap_insert(context_metal->slotmap_shaders, shader_metal, &out->handle);

	return RJD_RESULT_OK();
}

void rjd_gfx_shader_destroy(struct rjd_gfx_context* context, struct rjd_gfx_shader* shader)
{
	RJD_ASSERT(shader);
	RJD_ASSERT(context);
	RJD_ASSERT(rjd_slot_isvalid(shader->handle));

	struct rjd_gfx_context_metal* context_metal = (struct rjd_gfx_context_metal*)context;
	rjd_gfx_shader_destroy_metal(context_metal, shader->handle);
}

struct rjd_result rjd_gfx_pipeline_state_create(struct rjd_gfx_context* context, struct rjd_gfx_pipeline_state* out, struct rjd_gfx_pipeline_state_desc desc)
{
	RJD_ASSERT(out);
	RJD_ASSERT(context);
    
    struct rjd_gfx_context_metal* context_metal = (struct rjd_gfx_context_metal*)context;

    id <MTLRenderPipelineState> pipeline_state = nil;
	{
    	MTLRenderPipelineDescriptor *desc_metal = [[MTLRenderPipelineDescriptor alloc] init];
		if (desc.debug_name != NULL) {
    		desc_metal.label = [NSString stringWithUTF8String:desc.debug_name];
		}

		if (rjd_slot_isvalid(desc.render_target.handle)) {
			struct rjd_gfx_texture_metal* texture_metal = rjd_slotmap_get(context_metal->slotmap_textures, desc.render_target.handle);
			id<MTLTexture> target = texture_metal->texture;
    		desc_metal.sampleCount = target.sampleCount;
    		desc_metal.colorAttachments[0].pixelFormat = target.pixelFormat;
		} else {
			MTKView* view = context_metal->view;
    		desc_metal.sampleCount = view.sampleCount;
    		desc_metal.colorAttachments[0].pixelFormat = view.colorPixelFormat;
		}

        {
            MTLPixelFormat source_format = MTLPixelFormatInvalid;
            if (rjd_gfx_texture_isbackbuffer(desc.depthstencil_target)) {
                MTKView* view = context_metal->view;
                source_format = view.depthStencilPixelFormat;
            } else if (rjd_slot_isvalid(desc.depthstencil_target.handle)) {
                struct rjd_gfx_texture_metal* texture_metal = rjd_slotmap_get(context_metal->slotmap_textures, desc.render_target.handle);
                id<MTLTexture> target = texture_metal->texture;
                source_format = target.pixelFormat;
            }
            
            MTLPixelFormat depth_format = MTLPixelFormatInvalid;
            MTLPixelFormat stencil_format = MTLPixelFormatInvalid;
            if (source_format != MTLPixelFormatInvalid) {
                if (rjd_gfx_mtlformat_is_depth(source_format)) {
                    depth_format = source_format;
                }
                if (rjd_gfx_mtlformat_is_stencil(source_format)) {
                    stencil_format = source_format;
                }
            }

            desc_metal.depthAttachmentPixelFormat = depth_format;
            desc_metal.stencilAttachmentPixelFormat = stencil_format;
        }

		if (rjd_slot_isvalid(desc.shader_vertex.handle)) {
			struct rjd_gfx_shader_metal* shader = rjd_slotmap_get(context_metal->slotmap_shaders, desc.shader_vertex.handle);
    		desc_metal.vertexFunction = shader->function;
		}

		if (rjd_slot_isvalid(desc.shader_pixel.handle)) {
			struct rjd_gfx_shader_metal* shader = rjd_slotmap_get(context_metal->slotmap_shaders, desc.shader_pixel.handle);
    		desc_metal.fragmentFunction = shader->function;
		}

		// vertex format
        {
            MTLVertexDescriptor* vertex_descriptor = [[MTLVertexDescriptor alloc] init];

			// shader struct input definitions
            for (size_t i = 0; i < desc.count_vertex_attributes; ++i) {
				const struct rjd_gfx_vertex_format_attribute* attribute = desc.vertex_attributes + i;

				uint32_t attribute_index = attribute->attribute_index;
				uint32_t shader_slot = attribute->shader_slot_metal;
				MTLVertexFormat format = rjd_gfx_vertex_format_type_to_metal(attribute->type);
				MTLVertexStepFunction step_function = rjd_gfx_vertex_format_step_to_metal(attribute->step);

				vertex_descriptor.attributes[attribute_index].format = format;
				vertex_descriptor.attributes[attribute_index].offset = attribute->offset;
				vertex_descriptor.attributes[attribute_index].bufferIndex = attribute->shader_slot_metal;

				vertex_descriptor.layouts[shader_slot].stride = attribute->stride;
				vertex_descriptor.layouts[shader_slot].stepRate = attribute->step_rate;
				vertex_descriptor.layouts[shader_slot].stepFunction = step_function;
            }

            desc_metal.vertexDescriptor = vertex_descriptor;
        }

    	NSError *error = NULL;
    	pipeline_state = [context_metal->device newRenderPipelineStateWithDescriptor:desc_metal error:&error];
    	if (pipeline_state == nil) {
    	    RJD_GFX_LOG_ERROR("Failed to create pipeline state: %s", error.localizedDescription.UTF8String);
			return RJD_RESULT("Failed to create pipeline state");
		}
	}

	id<MTLDepthStencilState> depth_stencil_state = nil;
    {
        MTLDepthStencilDescriptor *depth_state_desc = [[MTLDepthStencilDescriptor alloc] init];

        depth_state_desc.depthWriteEnabled = desc.depth_write_enabled;
        depth_state_desc.depthCompareFunction = rjd_gfx_depth_compare_to_metal(desc.depth_compare);
        depth_stencil_state = [context_metal->device newDepthStencilStateWithDescriptor:depth_state_desc];

        if (depth_stencil_state == nil) {
               RJD_GFX_LOG_ERROR("Failed to create depth stencil state");
            return RJD_RESULT("Failed to create depth stencil state");
        }
    }

	struct rjd_gfx_pipeline_state_metal state = {
		.state_render = pipeline_state,
		.state_depthstencil = depth_stencil_state,
		.cull_mode = desc.cull_mode,
		.winding_order = desc.winding_order,
	};

	rjd_slotmap_insert(context_metal->slotmap_pipeline_states, state, &out->handle);

	return RJD_RESULT_OK();
}

void rjd_gfx_pipeline_state_destroy(struct rjd_gfx_context* context, struct rjd_gfx_pipeline_state* pipeline_state)
{
	RJD_ASSERT(pipeline_state);
	RJD_ASSERT(context);
	RJD_ASSERT(rjd_slot_isvalid(pipeline_state->handle));

	struct rjd_gfx_context_metal* context_metal = (struct rjd_gfx_context_metal*)context;
	rjd_gfx_pipeline_state_destroy_metal(context_metal, pipeline_state->handle);
}

struct rjd_result rjd_gfx_mesh_create_vertexed(struct rjd_gfx_context* context, struct rjd_gfx_mesh* out, struct rjd_gfx_mesh_vertexed_desc desc)
{
	RJD_ASSERT(out);
	RJD_ASSERT(context);

	if (desc.count_buffers == 0) {
		return RJD_RESULT("Must have more than 0 vertex buffers to create a mesh");
	}

	struct rjd_result result = RJD_RESULT_OK();

	struct rjd_gfx_context_metal* context_metal = (struct rjd_gfx_context_metal*)context;
	
	struct rjd_gfx_mesh_shader_buffer_metal* shader_buffers = rjd_array_alloc(struct rjd_gfx_mesh_shader_buffer_metal, desc.count_buffers, context_metal->allocator);
    rjd_array_resize(shader_buffers, desc.count_buffers);

	for (uint32_t i = 0; i < desc.count_buffers; ++i) {
		id<MTLBuffer> buffer = nil;
		struct rjd_gfx_mesh_buffer_desc* desc_buffer = desc.buffers + i;

        if (desc_buffer->usage_flags & RJD_GFX_MESH_BUFFER_USAGE_VERTEX_CONSTANT ||
			desc_buffer->usage_flags & RJD_GFX_MESH_BUFFER_USAGE_PIXEL_CONSTANT) {
			NSUInteger length = desc_buffer->common.constant.capacity;
			buffer = [context_metal->device newBufferWithLength:length options:MTLResourceStorageModeShared];
		} else if (desc_buffer->usage_flags & RJD_GFX_MESH_BUFFER_USAGE_VERTEX) {
			const void* bytes = desc_buffer->common.vertex.data;
			NSUInteger length = desc_buffer->common.vertex.length;
			buffer = [context_metal->device newBufferWithBytes:bytes length:length options:MTLResourceStorageModeManaged];
            NSRange range = NSMakeRange(0, length);
            [buffer didModifyRange:range];
		} else {
			result = RJD_RESULT("You must specify the usage_flags for each buffer");
			break;
		}

	    if (rjd_result_isok(result) && buffer == nil) {
            for (uint32_t k = 0; k < i; ++k) {
                shader_buffers[k].buffer = nil;
            }
	        result = RJD_RESULT("Not enough memory available to create buffers");
            break;
	    }
        
        struct rjd_gfx_mesh_shader_buffer_metal mesh_buffer = {
            .buffer = buffer,
            .usage_flags = desc.buffers[i].usage_flags,
            .shader_slot = desc.buffers[i].shader_slot_metal,
        };
        
        shader_buffers[i] = mesh_buffer;
	}

    if (rjd_result_isok(result)) {
        struct rjd_gfx_mesh_metal mesh_metal = {
            .shader_buffers = shader_buffers,
            .count_vertices = desc.count_vertices,
            .primitive = desc.primitive,
        };

        rjd_slotmap_insert(context_metal->slotmap_meshes, mesh_metal, &out->handle);
    }

	return result;
}

struct rjd_result rjd_gfx_mesh_modify(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* cmd_buffer, struct rjd_gfx_mesh* mesh, uint32_t buffer_index, uint32_t offset, const void* data, uint32_t length)
{
	RJD_ASSERT(context);
	RJD_ASSERT(mesh);
	RJD_ASSERT(rjd_slot_isvalid(mesh->handle));

	RJD_UNUSED_PARAM(cmd_buffer);

	struct rjd_gfx_context_metal* context_metal = (struct rjd_gfx_context_metal*)context;
	struct rjd_gfx_mesh_metal* mesh_metal = rjd_slotmap_get(context_metal->slotmap_meshes, mesh->handle);

	struct rjd_gfx_mesh_shader_buffer_metal* buffer = NULL;
	for (uint32_t i = 0; i < rjd_array_count(mesh_metal->shader_buffers); ++i) {
		if (i == buffer_index) {
			buffer = mesh_metal->shader_buffers + i;
		}
	}

	if (buffer == NULL) {
		return RJD_RESULT("Mesh buffer with specified buffer not found in mesh.");
	}

	if (buffer->buffer.length < offset + length) {
		return RJD_RESULT("Not enough storage available. You must increase the allocated size when the mesh is created.");
	}

	if (buffer->buffer.contents == NULL) {
		return RJD_RESULT("This is an immutable buffer. Modifying its contents is not allowed.");
	}

	memcpy((uint8_t*)buffer->buffer.contents + offset, data, length);
	if (buffer->usage_flags & RJD_GFX_MESH_BUFFER_USAGE_VERTEX) {
		NSRange range = NSMakeRange(offset, length);
		[buffer->buffer didModifyRange:range];
	}

	return RJD_RESULT_OK();
}

void rjd_gfx_mesh_destroy(struct rjd_gfx_context* context, struct rjd_gfx_mesh* mesh)
{
	RJD_ASSERT(mesh);
	RJD_ASSERT(context);
	RJD_ASSERT(rjd_slot_isvalid(mesh->handle));

	struct rjd_gfx_context_metal* context_metal = (struct rjd_gfx_context_metal*)context;
	rjd_gfx_mesh_destroy_metal(context_metal, mesh->handle);
}

////////////////////////////////////////////////////////////////////////////////
// private interface

static MTLPixelFormat rjd_gfx_format_color_to_metal(enum rjd_gfx_format format)
{
	switch (format)
	{
		case RJD_GFX_FORMAT_COLOR_U8_RGBA: return MTLPixelFormatRGBA8Uint;
		case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM: return MTLPixelFormatBGRA8Unorm;
		case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM_SRGB: return MTLPixelFormatBGRA8Unorm_sRGB;
		case RJD_GFX_FORMAT_DEPTHSTENCIL_F32_D32: return MTLPixelFormatDepth32Float;
		case RJD_GFX_FORMAT_DEPTHSTENCIL_U32_D24_S8: return MTLPixelFormatDepth24Unorm_Stencil8;
		case RJD_GFX_FORMAT_COUNT: break;
	}

	RJD_ASSERTFAIL("Unhandled format %d.", format);
	return MTLPixelFormatInvalid;
}

static MTLClearColor rjd_gfx_format_value_to_clearcolor(struct rjd_gfx_format_value value)
{
	double red = 0;
	double green = 0;
	double blue = 0;
	double alpha = 1;

	switch (value.type)
	{
		case RJD_GFX_FORMAT_COLOR_U8_RGBA:
			red		= value.color_u8_rgba[0] / (double)UCHAR_MAX;
			green	= value.color_u8_rgba[1] / (double)UCHAR_MAX;
			blue	= value.color_u8_rgba[2] / (double)UCHAR_MAX;
			alpha	= value.color_u8_rgba[3] / (double)UCHAR_MAX;
			break;
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM:
        case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM_SRGB:
			blue	= value.color_u8_rgba[2] / (double)UCHAR_MAX;
			green	= value.color_u8_rgba[1] / (double)UCHAR_MAX;
			red		= value.color_u8_rgba[0] / (double)UCHAR_MAX;
			alpha	= value.color_u8_rgba[3] / (double)UCHAR_MAX;
            break;
		case RJD_GFX_FORMAT_DEPTHSTENCIL_F32_D32:
		case RJD_GFX_FORMAT_DEPTHSTENCIL_U32_D24_S8:
			RJD_ASSERTFAIL("depth stencil values shouldn't be passed to this function");
			break;
		default: 
			RJD_ASSERTFAIL("Unhandled format %d.", value.type);
			break;
	}
	return MTLClearColorMake(red, green, blue, alpha);
}

static bool rjd_gfx_format_isbackbuffercompatible(enum rjd_gfx_format format)
{
	switch (format)
	{
		case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM: return true;
		case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM_SRGB: return true;
		default: return false;
	}
}

static MTLVertexFormat rjd_gfx_vertex_format_type_to_metal(enum rjd_gfx_vertex_format_type type)
{
	switch (type)
	{
		case RJD_GFX_VERTEX_FORMAT_TYPE_FLOAT1: return MTLVertexFormatFloat;
		case RJD_GFX_VERTEX_FORMAT_TYPE_FLOAT2: return MTLVertexFormatFloat2;
		case RJD_GFX_VERTEX_FORMAT_TYPE_FLOAT3: return MTLVertexFormatFloat3;
		case RJD_GFX_VERTEX_FORMAT_TYPE_FLOAT4: return MTLVertexFormatFloat4;
        case RJD_GFX_VERTEX_FORMAT_TYPE_COUNT: break;
	}

	RJD_ASSERTFAIL("unhandled type: %d", type);
	return MTLVertexFormatInvalid;
}

static MTLVertexStepFunction rjd_gfx_vertex_format_step_to_metal(enum rjd_gfx_vertex_format_step step)
{
	switch (step)
	{
		case RJD_GFX_VERTEX_FORMAT_STEP_VERTEX: return MTLVertexStepFunctionPerVertex;
		case RJD_GFX_VERTEX_FORMAT_STEP_INSTANCE: return MTLVertexStepFunctionPerInstance;
		case RJD_GFX_VERTEX_FORMAT_STEP_CONSTANT: return MTLVertexStepFunctionConstant;
	}

	RJD_ASSERTFAIL("unhandled type: %d", step);
	return MTLVertexStepFunctionPerVertex;
}

static MTLIndexType rjd_gfx_index_type_to_metal(enum rjd_gfx_index_type type)
{
	switch (type)
	{
		case RJD_GFX_INDEX_TYPE_UINT16: return MTLIndexTypeUInt16;
		case RJD_GFX_INDEX_TYPE_UINT32: return MTLIndexTypeUInt32;
	}
	RJD_ASSERTFAIL("Unknown index type %d", type);
	return MTLIndexTypeUInt16;
}

static MTLPrimitiveType rjd_gfx_primitive_type_to_metal(enum rjd_gfx_primitive_type type)
{
    switch (type)
    {
        case RJD_GFX_PRIMITIVE_TYPE_TRIANGLES: return MTLPrimitiveTypeTriangle;
    }
    RJD_ASSERTFAIL("Unknown primitive type %d", type);
    return MTLPrimitiveTypeTriangle;
}

static MTLCompareFunction rjd_gfx_depth_compare_to_metal(enum rjd_gfx_depth_compare func)
{
	switch (func)
	{
		case RJD_GFX_DEPTH_COMPARE_ALWAYS_SUCCEED: return MTLCompareFunctionAlways;
		case RJD_GFX_DEPTH_COMPARE_ALWAYS_FAIL: return MTLCompareFunctionNever;
		case RJD_GFX_DEPTH_COMPARE_LESS: return MTLCompareFunctionLess;
		case RJD_GFX_DEPTH_COMPARE_LESSEQUAL: return MTLCompareFunctionLessEqual;
		case RJD_GFX_DEPTH_COMPARE_GREATER: return MTLCompareFunctionGreater;
		case RJD_GFX_DEPTH_COMPARE_GREATEREQUAL: return MTLCompareFunctionGreaterEqual;
		case RJD_GFX_DEPTH_COMPARE_EQUAL: return MTLCompareFunctionEqual;
		case RJD_GFX_DEPTH_COMPARE_NOTEQUAL: return MTLCompareFunctionNotEqual;
	}
	RJD_ASSERTFAIL("Unknown compare func %d", func);
	return MTLCompareFunctionAlways;
}

static MTLWinding rjd_gfx_winding_to_metal(enum rjd_gfx_winding_order winding_order)
{
	switch (winding_order)
	{
		case RJD_GFX_WINDING_ORDER_CLOCKWISE: return MTLWindingClockwise;
		case RJD_GFX_WINDING_ORDER_COUNTERCLOCKWISE: return MTLWindingCounterClockwise;
	}
	RJD_ASSERTFAIL("Unknown winding order %d", winding_order);
	return MTLWindingClockwise;
}

static MTLCullMode rjd_gfx_cull_to_metal(enum rjd_gfx_cull cull_mode)
{
	switch (cull_mode)
	{
		case RJD_GFX_CULL_NONE: return MTLCullModeNone;
		case RJD_GFX_CULL_BACK: return MTLCullModeBack;
		case RJD_GFX_CULL_FRONT: return MTLCullModeFront;
	}
	RJD_ASSERTFAIL("Unknown cull mode %d", cull_mode);
	return MTLCullModeNone;
}

static bool rjd_gfx_mtlformat_is_depth(MTLPixelFormat format)
{
    switch (format)
    {
        case MTLPixelFormatDepth32Float:
        case MTLPixelFormatDepth24Unorm_Stencil8:
        case MTLPixelFormatDepth16Unorm:
        case MTLPixelFormatDepth32Float_Stencil8:
            return true;
        default:
            break;
    }
    
    return false;
}

static bool rjd_gfx_mtlformat_is_stencil(MTLPixelFormat format)
{
    switch (format)
    {
        case MTLPixelFormatDepth24Unorm_Stencil8:
        case MTLPixelFormatDepth32Float_Stencil8:
            return true;
        default:
            break;
    }
    
    return false;
}


static bool rjd_gfx_texture_isbackbuffer(struct rjd_gfx_texture texture)
{
	return	texture.handle.salt == RJD_GFX_TEXTURE_BACKBUFFER.handle.salt &&
			texture.handle.index == RJD_GFX_TEXTURE_BACKBUFFER.handle.index;
}

static inline void rjd_gfx_texture_destroy_metal(struct rjd_gfx_context_metal* context, struct rjd_slot slot)
{
    if (rjd_slotmap_contains(context->slotmap_textures, slot)) {
        struct rjd_gfx_texture_metal* texture_metal = rjd_slotmap_get(context->slotmap_textures, slot);
        texture_metal->texture = nil;
//        texture_metal->buffer = nil;
        rjd_slotmap_erase(context->slotmap_textures, slot);
    }
}

static inline void rjd_gfx_shader_destroy_metal(struct rjd_gfx_context_metal* context, struct rjd_slot slot)
{
	struct rjd_gfx_shader_metal* shader_metal = rjd_slotmap_get(context->slotmap_shaders, slot);

	shader_metal->function = nil;
	shader_metal->library = nil;

	rjd_slotmap_erase(context->slotmap_shaders, slot);
}

static inline void rjd_gfx_pipeline_state_destroy_metal(struct rjd_gfx_context_metal* context, struct rjd_slot slot)
{
    struct rjd_gfx_pipeline_state_metal* pipeline_state = rjd_slotmap_get(context->slotmap_pipeline_states, slot);
    pipeline_state->state_render = nil;
    pipeline_state->state_depthstencil = nil;
	rjd_slotmap_erase(context->slotmap_pipeline_states, slot);
}

static inline void rjd_gfx_mesh_destroy_metal(struct rjd_gfx_context_metal* context, struct rjd_slot slot)
{
	struct rjd_gfx_mesh_metal* mesh_metal = rjd_slotmap_get(context->slotmap_meshes, slot);
    
	for (uint32_t i = 0; i < rjd_array_count(mesh_metal->shader_buffers); ++i) {
		mesh_metal->shader_buffers[i].buffer = nil;
	}
    
    for (uint32_t i = 0; rjd_array_count(mesh_metal->index_buffers); ++i) {
        mesh_metal->index_buffers[i].buffer = nil;
    }
    
	rjd_array_free(mesh_metal->shader_buffers);
    rjd_array_free(mesh_metal->index_buffers);
	rjd_slotmap_erase(context->slotmap_meshes, slot);
}

static inline void rjd_gfx_command_buffer_destroy_metal(struct rjd_gfx_context_metal* context, struct rjd_slot slot)
{
	struct rjd_gfx_command_buffer_metal* buffer_metal = rjd_slotmap_get(context->slotmap_command_buffers, slot);
	buffer_metal->buffer = nil;
	rjd_slotmap_erase(context->slotmap_command_buffers, slot);
}

#endif // RJD_IMPL && RJD_PLATFORM_OSX


////////////////////////////////////////////////////////////////////////////////
// rjd_gfx_d3d11.h
////////////////////////////////////////////////////////////////////////////////

#pragma once

#define RJD_GFX_D3D11_H 1

#if RJD_IMPL && RJD_GFX_BACKEND_D3D11

#if !RJD_PLATFORM_WINDOWS
	#error "D3D11 backend is only supported on Windows."
#endif

#if !RJD_GFX_H
	#error "This header depends on rjd_gfx.h"
#endif

// This forward declaration is needed to suppress an order of declarations bug in the d3d headers.
// d3d11shader.h(454): warning C4115: 'ID3D11ModuleInstance': named type definition in parentheses
struct ID3D11ModuleInstance;

#define CINTERFACE
#define COBJMACROS
#include <d3d11_1.h>
#include <dxgi1_6.h>
#include <dxgidebug.h>
#include <d3dcompiler.h>

#undef CINTERFACE
#undef COBJMACROS

////////////////////////////////////////////////////////////////////////////////
// Local helpers

struct rjd_gfx_texture_d3d11
{
	ID3D11Texture2D* texture;
	ID3D11ShaderResourceView* resource_view;
	ID3D11SamplerState* sampler;
	struct rjd_strref* debug_name;
};

struct rjd_gfx_shader_d3d11
{
	ID3DBlob* bytecode;
	ID3D11VertexShader* vertex;
	ID3D11PixelShader* pixel;
	struct rjd_strref* debug_name;
	struct rjd_strref* debug_source;
};

struct rjd_gfx_pipeline_state_d3d11
{
	ID3D11InputLayout* vertex_layout;
	ID3D11RasterizerState* rasterizer_state;
	ID3D11DepthStencilState* depthstencil_state;
	struct rjd_gfx_shader shader_vertex;
	struct rjd_gfx_shader shader_pixel;
	struct rjd_gfx_texture render_target;
	struct rjd_gfx_texture depthstencil_target;
	enum rjd_gfx_depth_compare depth_compare;
	struct rjd_strref* debug_name;
};

struct rjd_gfx_mesh_buffer_d3d11
{
	ID3D11Buffer* buffer;
	UINT stride;
	UINT offset;
	UINT slot;
	enum rjd_gfx_mesh_buffer_usage_flags usage_flags;
};

struct rjd_gfx_mesh_d3d11
{
	struct rjd_gfx_mesh_buffer_d3d11* buffers;
	uint32_t count_buffers;
	uint32_t count_vertices;
	enum rjd_gfx_primitive_type primitive;
};

struct rjd_gfx_command_buffer_d3d11
{
	ID3D11DeviceContext1* deferred_context;
	ID3D11RenderTargetView* render_target_view;
	ID3D11DepthStencilView* depthstencil_view;
};

struct rjd_gfx_context_d3d11
{
	IDXGIFactory4* factory;
	IDXGIAdapter1* adapter;
	ID3D11Device1* device;
	ID3D11DeviceContext* context;
	IDXGISwapChain1* swapchain;

	struct rjd_gfx_texture_d3d11* slotmap_textures;
	struct rjd_gfx_shader_d3d11* slotmap_shaders;
	struct rjd_gfx_pipeline_state_d3d11* slotmap_pipeline_states;
	struct rjd_gfx_mesh_d3d11* slotmap_meshes;
	struct rjd_gfx_command_buffer_d3d11* slotmap_command_buffers;

	ID3D11DeviceContext1** free_deferred_contexts;
	ID3D11Texture2D** depthbuffers;
	ID3D11Texture2D** msaa_depthbuffers;
	struct rjd_gfx_texture* msaa_backbuffers;

	struct rjd_mem_allocator* allocator;
	struct rjd_strpool debug_names;
	HWND hwnd;
	bool is_occluded;
	uint8_t num_backbuffers;
	uint8_t backbuffer_index;
	enum rjd_gfx_format backbuffer_color_format;
	enum rjd_gfx_format backbuffer_depth_format;
};
RJD_STATIC_ASSERT(sizeof(struct rjd_gfx_context_d3d11) <= sizeof(struct rjd_gfx_context));

struct rjd_gfx_rgba
{
	float v[4];
};

static struct rjd_result rjd_gfx_translate_hresult(HRESULT hr);

static DXGI_FORMAT rjd_gfx_format_to_dxgi(enum rjd_gfx_format format);
static DXGI_FORMAT rjd_gfx_format_to_dxgi_strip_srgb(enum rjd_gfx_format format);
static struct rjd_gfx_rgba rjd_gfx_format_value_to_rgba(struct rjd_gfx_format_value value);
static D3D_PRIMITIVE_TOPOLOGY rjd_gfx_primitive_to_d3d11(enum rjd_gfx_primitive_type primitive);
static D3D11_CULL_MODE rjd_gfx_cull_to_d3d(enum rjd_gfx_cull cull_mode);
static D3D11_COMPARISON_FUNC rjd_gfx_depth_compare_to_d3d11(enum rjd_gfx_depth_compare compare);
static D3D11_USAGE rjd_gfx_texture_access_to_gpu_access(enum rjd_gfx_texture_access access);
static D3D11_CPU_ACCESS_FLAG rjd_gfx_texture_access_to_cpu_access(enum rjd_gfx_texture_access access);
static const char* rjd_gfx_semantic_to_name(enum rjd_gfx_vertex_semantic semantic);

static bool rjd_gfx_texture_isbackbuffer(struct rjd_gfx_texture texture);

static struct rjd_result rjd_gfx_backbuffer_get_msaa_quality_d3d11(const struct rjd_gfx_context_d3d11* context, uint32_t sample_count, DXGI_SAMPLE_DESC* out);

static inline void rjd_gfx_texture_destroy_d3d11(struct rjd_gfx_context_d3d11* context, struct rjd_slot slot);
static inline void rjd_gfx_shader_destroy_d3d11(struct rjd_gfx_context_d3d11* context, struct rjd_slot slot);
static inline void rjd_gfx_pipeline_state_destroy_d3d11(struct rjd_gfx_context_d3d11* context, struct rjd_slot slot);
static inline void rjd_gfx_mesh_destroy_d3d11(struct rjd_gfx_context_d3d11* context, struct rjd_slot slot);
static inline void rjd_gfx_command_buffer_destroy_d3d11(struct rjd_gfx_context_d3d11* context, struct rjd_slot slot);

////////////////////////////////////////////////////////////////////////////////
// Local data

#if RJD_COMPILER_GCC
	// The GCC headers have all the correct declarations for these GUIDs, but libdxguid.a are missing the definitions
	const GUID IID_IDXGIFactory4 = { 0x1bc6ea02, 0xef36, 0x464f, { 0xbf,0x0c,0x21,0xca,0x39,0xe5,0x16,0x8a } };
	const GUID IID_ID3D11Device1 = { 0xa04bfb29, 0x08ef, 0x43d6, { 0xa4,0x9c,0xa9,0xbd,0xbd,0xcb,0xe6,0x86 } };
#endif

////////////////////////////////////////////////////////////////////////////////
// interface implementation

struct rjd_result rjd_gfx_context_create(struct rjd_gfx_context* out, struct rjd_gfx_context_desc desc)
{
	RJD_ASSERT(out);

	IDXGIFactory4* factory = NULL;
	{
		UINT flags = 0;
		flags |= DXGI_CREATE_FACTORY_DEBUG; // TODO make this optional

		HRESULT hr = CreateDXGIFactory2(flags, &IID_IDXGIFactory4, (void**)&factory);
		if (!SUCCEEDED(hr)) {
			return rjd_gfx_translate_hresult(hr);
		}
	}

	IDXGIAdapter1* adapter_extended = NULL;
	struct rjd_result result_adapter = RJD_RESULT("No hardware adapter found. Does this machine have a GPU?");
	for (UINT i = 0; DXGI_ERROR_NOT_FOUND != IDXGIFactory1_EnumAdapters1(factory, i, &adapter_extended); ++i) {
		DXGI_ADAPTER_DESC1 desc_adapter;
		IDXGIAdapter1_GetDesc1(adapter_extended, &desc_adapter);
		if (desc_adapter.Flags & DXGI_ADAPTER_FLAG_SOFTWARE) {
			adapter_extended = NULL;
			continue;
		}

		// desc_adapter.DedicatedVideoMemory
		// desc_adapter.Description // wchar_t* name
		result_adapter = RJD_RESULT_OK();
		break;
	}
	if (!rjd_result_isok(result_adapter)) {
		return result_adapter;
	}

	//IDXGIAdapter* adapter = NULL;
	//if (adapter_extended) {
	//	IDXGIAdapter1_QueryInterface(adapter_extended, &IID_IDXGIAdapter, &adapter);
	//}

	ID3D11Device1* device = NULL;
	ID3D11DeviceContext* context = NULL;
	{
		const UINT flags =
			D3D11_CREATE_DEVICE_BGRA_SUPPORT | // enable compatibility with Direct2D.
			D3D11_CREATE_DEVICE_DEBUG | // TODO make this optional
			0;

		const D3D_FEATURE_LEVEL feature_levels[] = {
			D3D_FEATURE_LEVEL_11_1,
		};

		ID3D11Device* device_11_0 = NULL;
		const HRESULT hr_device = D3D11CreateDevice(
			//(IDXGIAdapter*)adapter, // TODO verify this cast is legit
			NULL, // TODO replace this with the specified adapter
			D3D_DRIVER_TYPE_HARDWARE,
			NULL, // not using a software rasterizer
			flags,
			feature_levels,
			rjd_countof(feature_levels),
			D3D11_SDK_VERSION,
			&device_11_0,
			NULL,
			&context);

		if (FAILED(hr_device)) {
			if (hr_device == DXGI_ERROR_SDK_COMPONENT_MISSING) {
				if (flags & D3D11_CREATE_DEVICE_DEBUG) {
					return RJD_RESULT("Correct debug layer version not available on this machine. "
						"Make sure the DirectX SDK is up to date.");
				}
				else {
					return RJD_RESULT("A SDK component was not available.");
				}
			}
			else {
				return rjd_gfx_translate_hresult(hr_device);
			}
		}

		ID3D11Device1_QueryInterface(device_11_0, &IID_ID3D11Device1, (void**)&device);
		ID3D11Device1_Release(device_11_0);
		if (device == NULL) {
			return RJD_RESULT("Unable to create 11.1 device. 11.0 is not supported.");
		}
	}

	// DXGI doesn't support SRGB formats in the swapchain, but if the user wants one, we can still fake it
	// by using SRGB views.
	DXGI_FORMAT backbuffer_format = rjd_gfx_format_to_dxgi(desc.backbuffer_color_format);
	{
		if (backbuffer_format != DXGI_FORMAT_B8G8R8A8_UNORM &&
			backbuffer_format != DXGI_FORMAT_R8G8B8A8_UNORM &&
			backbuffer_format != DXGI_FORMAT_R16G16B16A16_FLOAT &&
			backbuffer_format != DXGI_FORMAT_R10G10B10A2_UNORM) {
			backbuffer_format = rjd_gfx_format_to_dxgi_strip_srgb(desc.backbuffer_color_format);
		}
		if (backbuffer_format != DXGI_FORMAT_B8G8R8A8_UNORM &&
			backbuffer_format != DXGI_FORMAT_R8G8B8A8_UNORM &&
			backbuffer_format != DXGI_FORMAT_R16G16B16A16_FLOAT &&
			backbuffer_format != DXGI_FORMAT_R10G10B10A2_UNORM) {
			return RJD_RESULT("The backbuffer format must be one of these: "
								"DXGI_FORMAT_B8G8R8A8_UNORM, DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_FORMAT_R16G16B16A16_FLOAT, DXGI_FORMAT_R10G10B10A2_UNORM");
		}
	}

	if (desc.num_backbuffers > 3) {
		return RJD_RESULT("You specified more than 3 framebuffers Only 1-3 are supported.");
	}
	const UINT num_backbuffers = (desc.num_backbuffers == 0) ? 3 : desc.num_backbuffers;

	IDXGISwapChain1* swapchain = NULL;
	{
		DXGI_RATIONAL refresh_rate = {
			.Numerator = 0,
			.Denominator = 1,
		};

		// note that the flip model isn't compatible with msaa so we'll have to render to an offscreen msaa
		// target to get the same effect
		DXGI_SAMPLE_DESC desc_msaa = {
			.Count = 1,
			.Quality = 0,
		};

		uint32_t flags = 0;
		flags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH; // needed to switch between fullscreen/windowed
		flags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING; // needed to turn off vsync

		DXGI_SWAP_CHAIN_DESC1 desc_swapchain = {
			.Width = 0, // auto-detect
			.Height = 0, // auto-detect
			.Format = backbuffer_format,
			.Stereo = false,
			.SampleDesc = desc_msaa,
			.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT,
			.BufferCount = num_backbuffers,
			.Scaling = DXGI_SCALING_STRETCH, // Don't stretch the backbuffer to fit the window size. We should handle that. // TODO figure out why DXGI_SCALING_NONE fails
			.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD, // flip model has better perf and discard since we don't care to keep it around
			.AlphaMode = DXGI_ALPHA_MODE_UNSPECIFIED,
			.Flags = flags,
		};

		DXGI_SWAP_CHAIN_FULLSCREEN_DESC desc_fullscreen = {
			.RefreshRate = refresh_rate,
			.Windowed = TRUE, // TODO
		};

		HRESULT hr_swap = IDXGIFactory2_CreateSwapChainForHwnd(
			factory,
			(IUnknown*)device,
			desc.win32.hwnd,
			&desc_swapchain,
			&desc_fullscreen,
			NULL, // don't restrict to a particular output of the adapter
			&swapchain);
		if (FAILED(hr_swap)) {
			switch (hr_swap) {
				case E_OUTOFMEMORY: return RJD_RESULT("Failed to create swapchain: out of memory");
				case DXGI_ERROR_INVALID_CALL: RJD_ASSERTFAIL("We should detect this before it gets here."); break;
				default: return RJD_RESULT("Failed to create swapchain.");
			}
		}
	}

	// Create backing depth buffers
	ID3D11Texture2D** depthbuffers = rjd_mem_alloc_array(ID3D11Texture2D*, num_backbuffers, desc.allocator);
	{
		DXGI_FORMAT depth_format_dxgi = rjd_gfx_format_to_dxgi(desc.backbuffer_depth_format);

		DXGI_SWAP_CHAIN_DESC1 swapchain_desc = {0};
		HRESULT hr_swap = IDXGISwapChain1_GetDesc1(swapchain, &swapchain_desc);
		if (FAILED(hr_swap)) {
			return RJD_RESULT("Failed to get swapchain desc to get auto-detected backbuffer size.");
		}

		D3D11_TEXTURE2D_DESC desc_depthbuffer = {
			.Width = swapchain_desc.Width,
			.Height = swapchain_desc.Height,
			.MipLevels = 1,
			.ArraySize = 1,
			.Format = depth_format_dxgi,
			.SampleDesc.Count = 1,
			.SampleDesc.Quality = 0,
			.Usage = D3D11_USAGE_DEFAULT,
			.BindFlags = D3D11_BIND_DEPTH_STENCIL,
			.CPUAccessFlags = 0,
			.MiscFlags = 0,
		};

		for (size_t i = 0; i < num_backbuffers; ++i) {
			HRESULT hr = ID3D11Device_CreateTexture2D(device, &desc_depthbuffer, NULL, depthbuffers + i);
			if (FAILED(hr)) {
				return rjd_gfx_translate_hresult(hr);
			}
		}
	}

	memset(out, 0, sizeof(*out));
	struct rjd_gfx_context_d3d11* context_d3d11 = (struct rjd_gfx_context_d3d11*)out;

	context_d3d11->slotmap_textures			= rjd_slotmap_alloc(struct rjd_gfx_texture_d3d11, 64, desc.allocator);
	context_d3d11->slotmap_shaders			= rjd_slotmap_alloc(struct rjd_gfx_shader_d3d11, 64, desc.allocator);
	context_d3d11->slotmap_pipeline_states	= rjd_slotmap_alloc(struct rjd_gfx_pipeline_state_d3d11, 64, desc.allocator);
	context_d3d11->slotmap_meshes			= rjd_slotmap_alloc(struct rjd_gfx_mesh_d3d11, 64, desc.allocator);
	context_d3d11->slotmap_command_buffers	= rjd_slotmap_alloc(struct rjd_gfx_command_buffer_d3d11, 16, desc.allocator);

	context_d3d11->free_deferred_contexts = rjd_array_alloc(ID3D11DeviceContext1*, 1, desc.allocator);
	context_d3d11->depthbuffers = depthbuffers;
	context_d3d11->msaa_backbuffers = NULL;

	context_d3d11->factory = factory;
	context_d3d11->adapter = adapter_extended;
	context_d3d11->device = device;
	context_d3d11->context = context;
	context_d3d11->swapchain = swapchain;

	context_d3d11->allocator = desc.allocator;
	context_d3d11->debug_names = rjd_strpool_init(desc.allocator, 128);
	context_d3d11->hwnd = desc.win32.hwnd;
	context_d3d11->is_occluded = false;
	context_d3d11->num_backbuffers = (uint8_t)num_backbuffers;
	context_d3d11->backbuffer_index = 0;
	context_d3d11->backbuffer_color_format = desc.backbuffer_color_format;
	context_d3d11->backbuffer_depth_format = desc.backbuffer_depth_format;

	return RJD_RESULT_OK();
}

void rjd_gfx_context_destroy(struct rjd_gfx_context* context)
{
	RJD_ASSERT(context);
	struct rjd_gfx_context_d3d11* context_d3d11 = (struct rjd_gfx_context_d3d11*)context;

	struct rjd_gfx_texture_d3d11* textures = context_d3d11->slotmap_textures;
	struct rjd_gfx_shader_d3d11* shaders = context_d3d11->slotmap_shaders;
	struct rjd_gfx_pipeline_state_d3d11* states = context_d3d11->slotmap_pipeline_states;
	struct rjd_gfx_mesh_d3d11* meshes = context_d3d11->slotmap_meshes;
	struct rjd_gfx_command_buffer_d3d11* commands = context_d3d11->slotmap_command_buffers;

	for (struct rjd_slot s = rjd_slotmap_next(textures, NULL); rjd_slot_isvalid(s); s = rjd_slotmap_next(textures, &s)) {
		rjd_gfx_texture_destroy_d3d11(context_d3d11, s);
	}

	for (struct rjd_slot s = rjd_slotmap_next(shaders, NULL); rjd_slot_isvalid(s); s = rjd_slotmap_next(shaders, &s)) {
		rjd_gfx_shader_destroy_d3d11(context_d3d11, s);
	}

	for (struct rjd_slot s = rjd_slotmap_next(states, NULL); rjd_slot_isvalid(s); s = rjd_slotmap_next(states, &s)) {
		rjd_gfx_pipeline_state_destroy_d3d11(context_d3d11, s);
	}

	for (struct rjd_slot s = rjd_slotmap_next(meshes, NULL); rjd_slot_isvalid(s); s = rjd_slotmap_next(meshes, &s)) {
		rjd_gfx_mesh_destroy_d3d11(context_d3d11, s);
	}

	for (struct rjd_slot s = rjd_slotmap_next(commands, NULL); rjd_slot_isvalid(s); s = rjd_slotmap_next(commands, &s)) {
		rjd_gfx_command_buffer_destroy_d3d11(context_d3d11, s);
	}

	rjd_slotmap_free(textures);
	rjd_slotmap_free(shaders);
	rjd_slotmap_free(states);
	rjd_slotmap_free(meshes);
	rjd_slotmap_free(commands);

	rjd_strpool_free(&context_d3d11->debug_names);

	for (size_t i = 0; i < rjd_array_count(context_d3d11->free_deferred_contexts); ++i) {
		ID3D11DeviceContext1_Release(context_d3d11->free_deferred_contexts[i]);
	}
	rjd_array_free(context_d3d11->free_deferred_contexts);

	for (size_t i = 0; i < context_d3d11->num_backbuffers; ++i) {
		ID3D11Texture2D_Release(context_d3d11->depthbuffers[i]);
		if (context_d3d11->msaa_depthbuffers) {
			ID3D11Texture2D_Release(context_d3d11->msaa_depthbuffers[i]);
		}
	}
	rjd_mem_free(context_d3d11->depthbuffers);
	rjd_mem_free(context_d3d11->msaa_depthbuffers);

	// freeing these textures got taken care of in the above resource cleanup
	rjd_mem_free(context_d3d11->msaa_backbuffers);

	IDXGISwapChain1_Release(context_d3d11->swapchain);
	ID3D11DeviceContext_Release(context_d3d11->context);
	ID3D11Device_Release(context_d3d11->device);
	IDXGIAdapter1_Release(context_d3d11->adapter);
	IDXGIFactory4_Release(context_d3d11->factory);

#if RJD_COMPILER_MSVC // GCC doesn't know about IDXGIDebug1
	{
		IDXGIDebug1* debug = NULL;
		HRESULT hr = DXGIGetDebugInterface1(0, &IID_IDXGIDebug, &debug);
		if (SUCCEEDED(hr)) {
			IDXGIDebug_ReportLiveObjects(debug, DXGI_DEBUG_ALL, DXGI_DEBUG_RLO_SUMMARY);
		}
	}
#endif
}

uint32_t rjd_gfx_backbuffer_current_index(const struct rjd_gfx_context* context)
{
	RJD_ASSERT(context);

	struct rjd_gfx_context_d3d11* context_d3d11 = (struct rjd_gfx_context_d3d11*)context;
	return context_d3d11->backbuffer_index;
}

struct rjd_result rjd_gfx_backbuffer_msaa_is_count_supported(const struct rjd_gfx_context* context, uint32_t sample_count)
{
	RJD_ASSERT(context);

	struct rjd_gfx_context_d3d11* context_d3d11 = (struct rjd_gfx_context_d3d11*)context;

	DXGI_SAMPLE_DESC unused = {0};
	return rjd_gfx_backbuffer_get_msaa_quality_d3d11(context_d3d11, sample_count, &unused);
}

struct rjd_result rjd_gfx_backbuffer_set_msaa_count(struct rjd_gfx_context* context, uint32_t sample_count)
{
	RJD_ASSERT(context);

	struct rjd_gfx_context_d3d11* context_d3d11 = (struct rjd_gfx_context_d3d11*)context;

	DXGI_SAMPLE_DESC sample_desc = {0};
	{
		struct rjd_result result = rjd_gfx_backbuffer_get_msaa_quality_d3d11(context_d3d11, sample_count, &sample_desc);
		if (!rjd_result_isok(result)) {
			return result;
		}
	}

	DXGI_SWAP_CHAIN_DESC1 swapchain_desc = {0};
	HRESULT hr_swap = IDXGISwapChain1_GetDesc1(context_d3d11->swapchain, &swapchain_desc);
	if (FAILED(hr_swap)) {
		return RJD_RESULT("Failed to get swapchain desc to check MSAA compatibility.");
	}

	if (sample_desc.Count != swapchain_desc.SampleDesc.Count) {
		const uint32_t num_msaa_backbuffers = (sample_count > 1) ? context_d3d11->num_backbuffers : 0;

		if (context_d3d11->msaa_backbuffers) {
			for (uint32_t i = 0; i < context_d3d11->num_backbuffers; ++i) {
				rjd_gfx_texture_destroy(context, context_d3d11->msaa_backbuffers + i);
				ID3D11Texture2D_Release(context_d3d11->msaa_depthbuffers[i]);
			}

			rjd_mem_free(context_d3d11->msaa_backbuffers);
			rjd_mem_free(context_d3d11->msaa_depthbuffers);
			context_d3d11->msaa_backbuffers = NULL;
			context_d3d11->msaa_depthbuffers = NULL;
		}

		if (num_msaa_backbuffers > 0) {
			// color buffers
			context_d3d11->msaa_backbuffers = rjd_mem_alloc_array(struct rjd_gfx_texture, num_msaa_backbuffers, context_d3d11->allocator);
			for (size_t i = 0; i < num_msaa_backbuffers; ++i) {
				struct rjd_gfx_texture_desc desc = {
					.debug_label = "msaa_backbuffer_color",
					.data = NULL, 
					.data_length = 0,
					.pixels_width = swapchain_desc.Width,
					.pixels_height = swapchain_desc.Height,
					.msaa_samples = sample_count,
					.format = context_d3d11->backbuffer_color_format,
					.access = RJD_GFX_TEXTURE_ACCESS_CPU_NONE_GPU_READWRITE,
					.usage = RJD_GFX_TEXTURE_USAGE_RENDERTARGET,
				};

				struct rjd_result result = rjd_gfx_texture_create(context, context_d3d11->msaa_backbuffers + i, desc);
				if (!rjd_result_isok(result)) {
					return result;
				}
			}

			// msaa depthbuffers
			context_d3d11->msaa_depthbuffers = rjd_mem_alloc_array(ID3D11Texture2D*, num_msaa_backbuffers, context_d3d11->allocator);
			for (size_t i = 0; i < num_msaa_backbuffers; ++i) {
				DXGI_FORMAT depth_format_dxgi = rjd_gfx_format_to_dxgi(context_d3d11->backbuffer_depth_format);

				D3D11_TEXTURE2D_DESC desc_depthbuffer = {
					.Width = swapchain_desc.Width,
					.Height = swapchain_desc.Height,
					.MipLevels = 1,
					.ArraySize = 1,
					.Format = depth_format_dxgi,
					.SampleDesc = sample_desc,
					.Usage = D3D11_USAGE_DEFAULT,
					.BindFlags = D3D11_BIND_DEPTH_STENCIL,
					.CPUAccessFlags = 0,
					.MiscFlags = 0,
				};

				HRESULT hr = ID3D11Device_CreateTexture2D(context_d3d11->device, &desc_depthbuffer, NULL, context_d3d11->msaa_depthbuffers + i);
				if (FAILED(hr)) {
					return rjd_gfx_translate_hresult(hr);
				}
			}
		}
	}

	return RJD_RESULT_OK();
}

struct rjd_result rjd_gfx_vsync_set(struct rjd_gfx_context* context, enum RJD_GFX_VSYNC_MODE mode)
{
	RJD_UNUSED_PARAM(context);
	RJD_UNUSED_PARAM(mode);
	return RJD_RESULT("unimplemented");
}

struct rjd_result rjd_gfx_wait_for_frame_begin(struct rjd_gfx_context* context)
{
	struct rjd_gfx_context_d3d11* context_d3d11 = (struct rjd_gfx_context_d3d11*)context;

	RECT rect_window = {0};
	if (GetWindowRect(context_d3d11->hwnd, &rect_window) == FALSE) {
		return RJD_RESULT("Failed to get window rect. Check GetLastError() for more information");
	}

	IDXGIOutput* output = NULL;
	IDXGIOutput* selected_output = NULL;
	uint32_t selected_intersect_area = 0;
	for (UINT i = 0; DXGI_ERROR_NOT_FOUND != IDXGIAdapter1_EnumOutputs(context_d3d11->adapter, i, &output); ++i) {
		DXGI_OUTPUT_DESC desc_output = {0};
		HRESULT hr = IDXGIOutput_GetDesc(output, &desc_output);
		if (SUCCEEDED(hr)) {
			RECT rect_intersect = {0};
			if (IntersectRect(&rect_intersect, &rect_window, &desc_output.DesktopCoordinates)) {
				uint32_t output_intersect_area = (rect_intersect.right - rect_intersect.left) * (rect_intersect.bottom - rect_intersect.top);

				if (selected_output == NULL || output_intersect_area > selected_intersect_area) {
					selected_output = output;
					selected_intersect_area = output_intersect_area;
				}
			}
		}

		if (selected_output != output) {
			IDXGIOutput_Release(output);
		}
	}

	if (selected_output == NULL) {
		return RJD_RESULT("No outputs found. Were all monitors unplugged?");
	}

	HRESULT hr = IDXGIOutput_WaitForVBlank(selected_output);

	IDXGIOutput_Release(selected_output);

	struct rjd_result result = rjd_gfx_translate_hresult(hr);
	return result;
}

struct rjd_result rjd_gfx_present(struct rjd_gfx_context* context)
{
	struct rjd_gfx_context_d3d11* context_d3d11 = (struct rjd_gfx_context_d3d11*)context;

	const bool USE_VSYNC = true; // TODO make this configurable

	UINT sync_interval = 0;
	UINT flags = 0;
	if (USE_VSYNC) {
		sync_interval = 1;
		flags = DXGI_PRESENT_DO_NOT_WAIT;
	} else {
		sync_interval = 0;
		flags = DXGI_PRESENT_DO_NOT_WAIT | DXGI_PRESENT_ALLOW_TEARING;
	}

	if (context_d3d11->is_occluded) {
		flags |= DXGI_PRESENT_TEST;
	}

	HRESULT hr = IDXGISwapChain_Present(context_d3d11->swapchain, sync_interval, flags);
	context_d3d11->is_occluded = (hr == DXGI_STATUS_OCCLUDED);
	if (context_d3d11->is_occluded) {
		hr = S_OK;
	}

	context_d3d11->backbuffer_index = (context_d3d11->backbuffer_index + 1) % context_d3d11->num_backbuffers;

	return rjd_gfx_translate_hresult(hr);
}

// commands
struct rjd_result rjd_gfx_command_buffer_create(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* out)
{
	struct rjd_gfx_context_d3d11* context_d3d11 = (struct rjd_gfx_context_d3d11*)context;

	struct rjd_gfx_command_buffer_d3d11 cmd_buffer_d3d11 = {0};

	if (rjd_array_count(context_d3d11->free_deferred_contexts) > 0) {
		cmd_buffer_d3d11.deferred_context = rjd_array_pop(context_d3d11->free_deferred_contexts);
	} else {
		HRESULT hr = ID3D11Device1_CreateDeferredContext1(context_d3d11->device, 0, &cmd_buffer_d3d11.deferred_context);
		if (FAILED(hr)) {
			return rjd_gfx_translate_hresult(hr);
		}
	}

	rjd_slotmap_insert(context_d3d11->slotmap_command_buffers, cmd_buffer_d3d11, &out->handle);
	return RJD_RESULT_OK();
}

struct rjd_result rjd_gfx_command_pass_begin(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* cmd_buffer, const struct rjd_gfx_pass_begin_desc* command)
{
	struct rjd_gfx_context_d3d11* context_d3d11 = (struct rjd_gfx_context_d3d11*)context;
	struct rjd_gfx_command_buffer_d3d11* cmd_buffer_d3d11 = rjd_slotmap_get(context_d3d11->slotmap_command_buffers, cmd_buffer->handle);

	if (cmd_buffer_d3d11->render_target_view) {
		return RJD_RESULT("A render pass has already been started with this command buffer.");
	}

	// Color buffer
	if (rjd_gfx_texture_isbackbuffer(command->render_target)) {
		ID3D11Texture2D* texture_backbuffer = NULL;
		D3D11_RTV_DIMENSION view_dimension = D3D11_RTV_DIMENSION_TEXTURE2D;

		if (context_d3d11->msaa_backbuffers) {
			struct rjd_gfx_texture* render_target = context_d3d11->msaa_backbuffers + context_d3d11->backbuffer_index;
			struct rjd_gfx_texture_d3d11* render_target_d3d11 = rjd_slotmap_get(context_d3d11->slotmap_textures, render_target->handle);
			texture_backbuffer = render_target_d3d11->texture;

			view_dimension = D3D11_RTV_DIMENSION_TEXTURE2DMS;
		} else {
			HRESULT hr = IDXGISwapChain_GetBuffer(context_d3d11->swapchain, 0, &IID_ID3D11Texture2D, (void**)&texture_backbuffer);
			if (FAILED(hr)) {
				return rjd_gfx_translate_hresult(hr);
			}
		}

		// NOTE: Even if the backbuffer is non-sRGB, we can still create a sRGB view for automatic colorspace conversion if that's what the user wanted the
		// backbuffer to be.
		D3D11_RENDER_TARGET_VIEW_DESC desc = {
			.Format = rjd_gfx_format_to_dxgi(context_d3d11->backbuffer_color_format),
			.ViewDimension = view_dimension,
		};

		HRESULT hr = ID3D11Device_CreateRenderTargetView(context_d3d11->device, (ID3D11Resource*)texture_backbuffer, &desc, &cmd_buffer_d3d11->render_target_view);
		if (FAILED(hr)) {
			return rjd_gfx_translate_hresult(hr);
		}

		// Fetching the buffer from the swapchain revs the refcount, so release it here. Getting the buffer from the MSAA render target doesn't, so no need to release.
		if (view_dimension == D3D11_RTV_DIMENSION_TEXTURE2D) {
			ID3D11Texture2D_Release(texture_backbuffer);
		}
	} else {
		RJD_ASSERTFAIL("non-backbuffer render targets are unimplemented"); // TODO
	}

	struct rjd_gfx_rgba rgba_backbuffer = rjd_gfx_format_value_to_rgba(command->clear_color);
	ID3D11DeviceContext_ClearRenderTargetView(cmd_buffer_d3d11->deferred_context, cmd_buffer_d3d11->render_target_view, rgba_backbuffer.v);

	// Depthstencil buffer
	if (rjd_gfx_texture_isbackbuffer(command->depthstencil_target)) {
		ID3D11Texture2D* texture_depthstencil = NULL;

		if (context_d3d11->msaa_depthbuffers) {
			texture_depthstencil = context_d3d11->msaa_depthbuffers[context_d3d11->backbuffer_index];
		} else {
			texture_depthstencil = context_d3d11->depthbuffers[context_d3d11->backbuffer_index];
		}

		HRESULT hr = ID3D11Device_CreateDepthStencilView(context_d3d11->device, (ID3D11Resource*)texture_depthstencil, NULL, &cmd_buffer_d3d11->depthstencil_view);
		if (FAILED(hr)) {
			return rjd_gfx_translate_hresult(hr);
		}
	} else {
		RJD_ASSERTFAIL("non-backbuffer depthbuffer targets are unimplemented"); // TODO
	}

	UINT flags = 0;
	float depth_color = 0.0f;
	uint8_t stencil_color = 0;

	if (rjd_gfx_format_isdepth(command->clear_depthstencil.type)) {
		flags |= D3D11_CLEAR_DEPTH;
		depth_color = (float)rjd_gfx_format_value_to_depth(command->clear_depthstencil);
	}

	if (rjd_gfx_format_isstencil(command->clear_depthstencil.type)) {
		flags |= D3D11_CLEAR_STENCIL;
		stencil_color = rjd_gfx_format_value_to_stencil(command->clear_depthstencil);
	}

	ID3D11DeviceContext_ClearDepthStencilView(cmd_buffer_d3d11->deferred_context, cmd_buffer_d3d11->depthstencil_view, flags, depth_color, stencil_color);

	return RJD_RESULT_OK();
}

struct rjd_result rjd_gfx_command_pass_draw(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* cmd_buffer, const struct rjd_gfx_pass_draw_desc* command)
{
	struct rjd_gfx_context_d3d11* context_d3d11 = (struct rjd_gfx_context_d3d11*)context;
	struct rjd_gfx_command_buffer_d3d11* cmd_buffer_d3d11 = rjd_slotmap_get(context_d3d11->slotmap_command_buffers, cmd_buffer->handle);
	const D3D11_VIEWPORT viewport =
	{
		.TopLeftX = 0,
		.TopLeftY = 0,
		.Width = (float)command->viewport->width,
		.Height = (float)command->viewport->height,
		.MinDepth = 0, 
		.MaxDepth = 1.0f,
	};
	ID3D11DeviceContext1_RSSetViewports(cmd_buffer_d3d11->deferred_context, 1, &viewport);

	// pipeline state
	struct rjd_gfx_pipeline_state_d3d11* pipeline_state_d3d11 = rjd_slotmap_get(context_d3d11->slotmap_pipeline_states, command->pipeline_state->handle);
	ID3D11DeviceContext1_IASetInputLayout(cmd_buffer_d3d11->deferred_context, pipeline_state_d3d11->vertex_layout);
	ID3D11DeviceContext1_RSSetState(cmd_buffer_d3d11->deferred_context, pipeline_state_d3d11->rasterizer_state);

	ID3D11DeviceContext1_OMSetDepthStencilState(cmd_buffer_d3d11->deferred_context, pipeline_state_d3d11->depthstencil_state, 0);
	ID3D11DeviceContext1_OMSetRenderTargets(cmd_buffer_d3d11->deferred_context, 1, &cmd_buffer_d3d11->render_target_view, cmd_buffer_d3d11->depthstencil_view);

	struct rjd_gfx_shader_d3d11* shader_vertex_d3d11 = rjd_slotmap_get(context_d3d11->slotmap_shaders, pipeline_state_d3d11->shader_vertex.handle);
	struct rjd_gfx_shader_d3d11* shader_pixel_d3d11 = rjd_slotmap_get(context_d3d11->slotmap_shaders, pipeline_state_d3d11->shader_pixel.handle);

	if (shader_vertex_d3d11->vertex) {
		ID3D11DeviceContext1_VSSetShader(cmd_buffer_d3d11->deferred_context, shader_vertex_d3d11->vertex, NULL, 0);
	} else {
		return RJD_RESULT("The selected shader did not have a vertex shader.");
	}

	if (shader_pixel_d3d11->pixel) {
		ID3D11DeviceContext1_PSSetShader(cmd_buffer_d3d11->deferred_context, shader_pixel_d3d11->pixel, NULL, 0);
	} else {
		return RJD_RESULT("The selected shader did not have a pixel shader.");
	}

	// textures & sampler states
	for (size_t i = 0; i < command->count_textures; ++i) {
		RJD_ASSERT(command->textures);
		RJD_ASSERT(command->texture_indices);

		struct rjd_gfx_texture_d3d11* texture_d3d11 = rjd_slotmap_get(context_d3d11->slotmap_textures, command->textures[i].handle);
		UINT slot = command->texture_indices[i];

		if (D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT <= slot) {
			return RJD_RESULT("Not allowed to bind to slots higher than D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT - 1");
		}

		ID3D11DeviceContext1_PSSetShaderResources(cmd_buffer_d3d11->deferred_context, slot, 1, &texture_d3d11->resource_view);
		ID3D11DeviceContext1_PSSetSamplers(cmd_buffer_d3d11->deferred_context, slot, 1, &texture_d3d11->sampler);
	}

	// draw meshes
	for (uint32_t mesh_index = 0; mesh_index < command->count_meshes; ++mesh_index) {
		RJD_ASSERT(command->meshes);

		const struct rjd_gfx_mesh_d3d11* mesh_d3d11 = rjd_slotmap_get(context_d3d11->slotmap_meshes, command->meshes[mesh_index].handle);

		const D3D_PRIMITIVE_TOPOLOGY primitive = rjd_gfx_primitive_to_d3d11(mesh_d3d11->primitive);
		ID3D11DeviceContext1_IASetPrimitiveTopology(cmd_buffer_d3d11->deferred_context, primitive);

		for (uint32_t buffer_index = 0; buffer_index < mesh_d3d11->count_buffers; ++buffer_index) {
			const struct rjd_gfx_mesh_buffer_d3d11* buffer_d3d11 = mesh_d3d11->buffers + buffer_index;

			if (buffer_d3d11->usage_flags & RJD_GFX_MESH_BUFFER_USAGE_VERTEX) {
				ID3D11DeviceContext1_IASetVertexBuffers(
					cmd_buffer_d3d11->deferred_context, 
					buffer_d3d11->slot, 
					1, 
					&buffer_d3d11->buffer,
					&buffer_d3d11->stride,
					&buffer_d3d11->offset);
			}

			if (buffer_d3d11->usage_flags & RJD_GFX_MESH_BUFFER_USAGE_VERTEX_CONSTANT ||
				buffer_d3d11->usage_flags & RJD_GFX_MESH_BUFFER_USAGE_PIXEL_CONSTANT) {

				const struct rjd_gfx_pass_draw_buffer_offset_desc* buffer_offset_desc = NULL;
				for (size_t index_constant_desc = 0; index_constant_desc < command->count_constant_descs; ++index_constant_desc) {
					if (command->buffer_offset_descs[index_constant_desc].mesh_index == mesh_index &&
						command->buffer_offset_descs[index_constant_desc].buffer_index == buffer_index) {
						buffer_offset_desc = command->buffer_offset_descs + index_constant_desc;
					}
				}
				RJD_ASSERTMSG(buffer_offset_desc, "Unable to find a rjd_gfx_pass_draw_buffer_offset_desc for mesh %u at buffer index %u.", mesh_index, buffer_index);

				const UINT first_constant = buffer_offset_desc->offset_bytes / 16;
				const UINT num_constants = buffer_offset_desc->range_bytes / 16;

				if (buffer_d3d11->usage_flags & RJD_GFX_MESH_BUFFER_USAGE_VERTEX_CONSTANT) {
					ID3D11DeviceContext1_VSSetConstantBuffers1(
						cmd_buffer_d3d11->deferred_context, 
						buffer_d3d11->slot, 
						1, 
						&buffer_d3d11->buffer,
						&first_constant,
						&num_constants);
				}
				if (buffer_d3d11->usage_flags & RJD_GFX_MESH_BUFFER_USAGE_PIXEL_CONSTANT) {
					ID3D11DeviceContext1_PSSetConstantBuffers1(
							cmd_buffer_d3d11->deferred_context, 
							buffer_d3d11->slot, 
							1, 
							&buffer_d3d11->buffer,
							&first_constant,
							&num_constants);
				}
			}
		}

		ID3D11DeviceContext1_Draw(cmd_buffer_d3d11->deferred_context, mesh_d3d11->count_vertices, 0);
	}

	return RJD_RESULT_OK();
}

struct rjd_result rjd_gfx_command_buffer_commit(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* cmd_buffer)
{
	RJD_ASSERT(cmd_buffer);
	RJD_ASSERT(context);
	RJD_ASSERT(rjd_slot_isvalid(cmd_buffer->handle));

	struct rjd_gfx_context_d3d11* context_d3d11 = (struct rjd_gfx_context_d3d11*)context;
	struct rjd_gfx_command_buffer_d3d11* cmd_buffer_d3d11 = rjd_slotmap_get(context_d3d11->slotmap_command_buffers, cmd_buffer->handle);

	// copy the MSAA render target to the DXGI backbuffer
	if (context_d3d11->msaa_backbuffers) {
		struct rjd_gfx_texture* source_texture = context_d3d11->msaa_backbuffers + context_d3d11->backbuffer_index;
		struct rjd_gfx_texture_d3d11* source_texture_d3d11 = rjd_slotmap_get(context_d3d11->slotmap_textures, source_texture->handle);

		ID3D11Resource* swapchain_buffer = NULL;
		{
			HRESULT hr = IDXGISwapChain_GetBuffer(context_d3d11->swapchain, 0, &IID_ID3D11Texture2D, (void**)&swapchain_buffer);
			if (FAILED(hr)) {
				return rjd_gfx_translate_hresult(hr);
			}
		}

		ID3D11DeviceContext1_ResolveSubresource(cmd_buffer_d3d11->deferred_context,
			swapchain_buffer, 0, 
			(ID3D11Resource*)source_texture_d3d11->texture, 0, 
			rjd_gfx_format_to_dxgi(context_d3d11->backbuffer_color_format));

		ID3D11Resource_Release(swapchain_buffer);
	}

	ID3D11CommandList* commandlist = NULL;
	HRESULT hr = ID3D11DeviceContext1_FinishCommandList(cmd_buffer_d3d11->deferred_context, FALSE, &commandlist);
	if (FAILED(hr)) {
		return rjd_gfx_translate_hresult(hr);
	}

	ID3D11DeviceContext_ExecuteCommandList(context_d3d11->context, commandlist, FALSE);
	ID3D11CommandList_Release(commandlist);
	ID3D11RenderTargetView_Release(cmd_buffer_d3d11->render_target_view);
	ID3D11DepthStencilView_Release(cmd_buffer_d3d11->depthstencil_view);

	rjd_array_push(context_d3d11->free_deferred_contexts, cmd_buffer_d3d11->deferred_context);

	cmd_buffer_d3d11->deferred_context = NULL;
	cmd_buffer_d3d11->render_target_view = NULL;
	cmd_buffer_d3d11->depthstencil_view = NULL;

	rjd_slotmap_erase(context_d3d11->slotmap_command_buffers, cmd_buffer->handle);
	rjd_slot_invalidate(&cmd_buffer->handle);

	return RJD_RESULT_OK();
}

struct rjd_result rjd_gfx_texture_create(struct rjd_gfx_context* context, struct rjd_gfx_texture* out, struct rjd_gfx_texture_desc desc)
{
	struct rjd_gfx_context_d3d11* context_d3d11 = (struct rjd_gfx_context_d3d11*)context;

	DXGI_SAMPLE_DESC sample_desc = {0};
	struct rjd_result result = rjd_gfx_backbuffer_get_msaa_quality_d3d11(context_d3d11, desc.msaa_samples, &sample_desc);
	if (!rjd_result_isok(result)) {
		return result;
	}

	UINT bind_flags = 0;
	bind_flags |= D3D11_BIND_SHADER_RESOURCE;
	bind_flags |= (desc.usage == RJD_GFX_TEXTURE_USAGE_RENDERTARGET) ? D3D11_BIND_RENDER_TARGET : 0;

	const D3D11_TEXTURE2D_DESC desc_d3d11 = {
		.Width = desc.pixels_width,
		.Height = desc.pixels_height,
		.MipLevels = 1, // TODO mipmap support
		.ArraySize = 1,
		.Format = rjd_gfx_format_to_dxgi(desc.format),
		.SampleDesc = sample_desc,
		.Usage = rjd_gfx_texture_access_to_gpu_access(desc.access),
		.BindFlags = bind_flags,
		.CPUAccessFlags = rjd_gfx_texture_access_to_cpu_access(desc.access),
		.MiscFlags = 0,
	};

	const D3D11_SUBRESOURCE_DATA subresource = {
		.pSysMem = desc.data,
		.SysMemPitch = desc.pixels_width * rjd_gfx_format_bytesize(desc.format),
		.SysMemSlicePitch = 0, // only for 3D textures
	};

	ID3D11Texture2D* texture = NULL;
	{
		const D3D11_SUBRESOURCE_DATA* initial_data = desc.data ? &subresource : NULL;

		HRESULT hr = ID3D11Device_CreateTexture2D(context_d3d11->device, &desc_d3d11, initial_data, &texture);
		if (FAILED(hr)) {
			return rjd_gfx_translate_hresult(hr);
		}
	}

	ID3D11ShaderResourceView* resource_view = NULL;
	{
		D3D11_SHADER_RESOURCE_VIEW_DESC desc_resource_view = 
		{
			.Format = desc_d3d11.Format,
		};

		if (sample_desc.Count > 1) {
			desc_resource_view.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2DMS;
		} else {
			desc_resource_view.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
			desc_resource_view.Texture2D.MostDetailedMip = 0;
			desc_resource_view.Texture2D.MipLevels = desc_d3d11.MipLevels;
		}

		HRESULT hr = ID3D11Device_CreateShaderResourceView(context_d3d11->device, (ID3D11Resource*)texture, &desc_resource_view, &resource_view);
		if (FAILED(hr)) {
			return rjd_gfx_translate_hresult(hr);
		}
	}

	ID3D11SamplerState* sampler = NULL;
	{
		// TODO make this configurable
		D3D11_SAMPLER_DESC desc_sampler = {
			.Filter = D3D11_FILTER_MIN_MAG_MIP_POINT,
			.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP,
			.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP,
			.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP,
			.MipLODBias = 0.0f,
			.MaxAnisotropy = 0,
			.ComparisonFunc = D3D11_COMPARISON_ALWAYS,
			.MinLOD = 0,
			.MaxLOD = D3D11_FLOAT32_MAX,
		};

		HRESULT hr = ID3D11Device_CreateSamplerState(context_d3d11->device, &desc_sampler, &sampler);
		if (FAILED(hr)) {
			return rjd_gfx_translate_hresult(hr);
		}
	}

	struct rjd_gfx_texture_d3d11 texture_d3d11 = {
		.texture = texture,
		.resource_view = resource_view,
		.sampler = sampler,
		.debug_name = rjd_strpool_add(&context_d3d11->debug_names, desc.debug_label),
	};

	rjd_slotmap_insert(context_d3d11->slotmap_textures, texture_d3d11, &out->handle);

	return RJD_RESULT_OK();
}

void rjd_gfx_texture_destroy(struct rjd_gfx_context* context, struct rjd_gfx_texture* texture)
{
	struct rjd_gfx_context_d3d11* context_d3d11 = (struct rjd_gfx_context_d3d11*)context;
	rjd_gfx_texture_destroy_d3d11(context_d3d11, texture->handle);
}

struct rjd_result rjd_gfx_shader_create(struct rjd_gfx_context* context, struct rjd_gfx_shader* out, struct rjd_gfx_shader_desc desc)
{
	RJD_ASSERT(context);
	RJD_ASSERT(desc.data);
	RJD_ASSERT(desc.count_data > 0);
	RJD_ASSERT(desc.function_name);

	struct rjd_gfx_context_d3d11* context_d3d11 = (struct rjd_gfx_context_d3d11*)context;

	const char* target = NULL;
	switch (desc.type)
	{
		case RJD_GFX_SHADER_TYPE_VERTEX:	target = "vs_5_0"; break;
		case RJD_GFX_SHADER_TYPE_PIXEL:		target = "ps_5_0"; break;
	}

	UINT flags = 0;
	flags |= D3DCOMPILE_WARNINGS_ARE_ERRORS;
	flags |= D3DCOMPILE_DEBUG; // TODO make this optional

	ID3DBlob* bytecode = NULL;
	ID3DBlob* errors = NULL;

	HRESULT hr = D3DCompile(
		desc.data,
		desc.count_data,
		desc.source_name,
		NULL,
		NULL,
		desc.function_name,
		target,
		flags,
		0,
		&bytecode,
		&errors);
	if (FAILED(hr)) {
		void* errors_data = ID3D10Blob_GetBufferPointer(errors);
		size_t errors_size = ID3D10Blob_GetBufferSize(errors);

		char* error_string = rjd_mem_alloc_array(char, errors_size + 1, context_d3d11->allocator);
		memcpy(error_string, errors_data, errors_size);
		error_string[errors_size] = 0;
		RJD_LOG("Shader compile errors: %s\n", error_string);
		return RJD_RESULT("Shaders failed to compile.");
	}

	ID3D11VertexShader* vertex = NULL;
	ID3D11PixelShader* pixel = NULL;

	const void* bytecode_data = ID3D10Blob_GetBufferPointer(bytecode);
	const size_t bytecode_size = ID3D10Blob_GetBufferSize(bytecode);

	if (desc.type == RJD_GFX_SHADER_TYPE_VERTEX) {
		hr = ID3D11Device_CreateVertexShader(context_d3d11->device, bytecode_data, bytecode_size, NULL, &vertex);
		if (FAILED(hr)) {
			return rjd_gfx_translate_hresult(hr);
		}
	}

	if (desc.type == RJD_GFX_SHADER_TYPE_PIXEL) {
		hr = ID3D11Device_CreatePixelShader(context_d3d11->device, bytecode_data, bytecode_size, NULL, &pixel);
		if (FAILED(hr)) {
			return rjd_gfx_translate_hresult(hr);
		}
	}

	struct rjd_gfx_shader_d3d11 shader_d3d11 = {
		.bytecode = bytecode,
		.vertex = vertex,
		.pixel = pixel,
		.debug_name = rjd_strpool_add(&context_d3d11->debug_names, desc.function_name),
		.debug_source = rjd_strpool_add(&context_d3d11->debug_names, desc.source_name),
	};

	rjd_slotmap_insert(context_d3d11->slotmap_shaders, shader_d3d11, &out->handle);

	return RJD_RESULT_OK();
}

void rjd_gfx_shader_destroy(struct rjd_gfx_context* context, struct rjd_gfx_shader* shader)
{
	struct rjd_gfx_context_d3d11* context_d3d11 = (struct rjd_gfx_context_d3d11*)context;
	rjd_gfx_shader_destroy_d3d11(context_d3d11, shader->handle);
}

struct rjd_result rjd_gfx_pipeline_state_create(struct rjd_gfx_context* context, struct rjd_gfx_pipeline_state* out, struct rjd_gfx_pipeline_state_desc desc)
{
	struct rjd_gfx_context_d3d11* context_d3d11 = (struct rjd_gfx_context_d3d11*)context;

	ID3D11InputLayout* vertex_layout = NULL;

	{
		uint32_t semantic_index[RJD_GFX_VERTEX_SEMANTIC_COUNT] = {0};

		D3D11_INPUT_ELEMENT_DESC* element_descs = rjd_mem_alloc_array(D3D11_INPUT_ELEMENT_DESC, desc.count_vertex_attributes, context_d3d11->allocator);
		for (size_t i = 0; i < desc.count_vertex_attributes; ++i) {
			DXGI_FORMAT format = 0;
			switch (desc.vertex_attributes[i].type) {
				case RJD_GFX_VERTEX_FORMAT_TYPE_FLOAT1: format = DXGI_FORMAT_R32_FLOAT; break;
				case RJD_GFX_VERTEX_FORMAT_TYPE_FLOAT2: format = DXGI_FORMAT_R32G32_FLOAT; break;
				case RJD_GFX_VERTEX_FORMAT_TYPE_FLOAT3: format = DXGI_FORMAT_R32G32B32_FLOAT; break;
				case RJD_GFX_VERTEX_FORMAT_TYPE_FLOAT4: format = DXGI_FORMAT_R32G32B32A32_FLOAT; break;
				case RJD_GFX_VERTEX_FORMAT_TYPE_COUNT: RJD_ASSERT("Invalid vertex format type RJD_GFX_VERTEX_FORMAT_TYPE_COUNT"); break;
			}
		
			const enum rjd_gfx_vertex_semantic semantic = desc.vertex_attributes[i].semantic;

			if (semantic == RJD_GFX_VERTEX_SEMANTIC_POSITION) {
				RJD_ASSERTMSG(semantic_index[semantic] == 0, "You can only have 1 POSITION semantic in an input layout.");
			}

			element_descs[i].SemanticName = rjd_gfx_semantic_to_name(semantic);
			element_descs[i].SemanticIndex = semantic_index[semantic];
			element_descs[i].Format = format;
			element_descs[i].InputSlot = desc.vertex_attributes[i].shader_slot_d3d11;
			element_descs[i].AlignedByteOffset = desc.vertex_attributes[i].offset;
			element_descs[i].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA; // TODO support D3D11_INPUT_PER_INSTANCE_DATA
			element_descs[i].InstanceDataStepRate = 0;

			++semantic_index[semantic];
		}

		const struct rjd_gfx_shader_d3d11* shader_d3d11 = rjd_slotmap_get(context_d3d11->slotmap_shaders, desc.shader_vertex.handle);
		const void* bytecode = ID3D10Blob_GetBufferPointer(shader_d3d11->bytecode);
		const size_t bytecode_size = ID3D10Blob_GetBufferSize(shader_d3d11->bytecode);

		HRESULT result = ID3D11Device_CreateInputLayout(context_d3d11->device, element_descs, desc.count_vertex_attributes, bytecode, bytecode_size, &vertex_layout);
		if (FAILED(result)) {
			return rjd_gfx_translate_hresult(result);
		}

		rjd_mem_free(element_descs);
	}

	ID3D11RasterizerState* rasterizer_state = NULL;
	{
		D3D11_RASTERIZER_DESC desc_rasterizer = 
		{
			.FillMode = D3D11_FILL_SOLID,
			.CullMode = rjd_gfx_cull_to_d3d(desc.cull_mode),
			.FrontCounterClockwise = desc.winding_order == RJD_GFX_WINDING_ORDER_COUNTERCLOCKWISE,
			.DepthBias = 0,
			.DepthBiasClamp = 1.0f,
			.SlopeScaledDepthBias = 1.0f,
			.DepthClipEnable = TRUE,
			.ScissorEnable = FALSE, // TODO support stencils
			.MultisampleEnable = TRUE,
			.AntialiasedLineEnable = FALSE,
		};

		HRESULT result = ID3D11Device_CreateRasterizerState(context_d3d11->device, &desc_rasterizer, &rasterizer_state);
		if (FAILED(result)) {
			return rjd_gfx_translate_hresult(result);
		}
	}

	ID3D11DepthStencilState* depthstencil_state = NULL;
	{
		D3D11_DEPTH_STENCIL_DESC desc_depthstencil = {
			.DepthEnable = TRUE,
			.DepthWriteMask = desc.depth_write_enabled ? D3D11_DEPTH_WRITE_MASK_ALL : D3D11_DEPTH_WRITE_MASK_ZERO,
			.DepthFunc = rjd_gfx_depth_compare_to_d3d11(desc.depth_compare),

			.StencilEnable = FALSE,
			// .StencilReadMask = 0xFF,
			// .StencilWriteMask = 0xFF,

			// .FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP,
			// .FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR,
			// .FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP,
			// .FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS,

			// .BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP,
			// .BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR,
			// .BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP,
			// .BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS,
		};

		HRESULT hr = ID3D11Device_CreateDepthStencilState(context_d3d11->device, &desc_depthstencil, &depthstencil_state);
		if (FAILED(hr)) {
			return rjd_gfx_translate_hresult(hr);
		}
	}

	struct rjd_gfx_pipeline_state_d3d11 state_d3d11 = 
	{
		.debug_name = rjd_strpool_add(&context_d3d11->debug_names, desc.debug_name),
		.vertex_layout = vertex_layout,
		.rasterizer_state = rasterizer_state,
		.shader_vertex = desc.shader_vertex,
		.shader_pixel = desc.shader_pixel,
		.render_target = desc.render_target,
		.depthstencil_target = desc.depthstencil_target,
		.depthstencil_state = depthstencil_state,
	};
	
	rjd_slotmap_insert(context_d3d11->slotmap_pipeline_states, state_d3d11, &out->handle);

	return RJD_RESULT_OK();
}

void rjd_gfx_pipeline_state_destroy(struct rjd_gfx_context* context, struct rjd_gfx_pipeline_state* pipeline_state)
{
	struct rjd_gfx_context_d3d11* context_d3d11 = (struct rjd_gfx_context_d3d11*)context;
	rjd_gfx_pipeline_state_destroy_d3d11(context_d3d11, pipeline_state->handle);
}

struct rjd_result rjd_gfx_mesh_create_vertexed(struct rjd_gfx_context* context, struct rjd_gfx_mesh* out, struct rjd_gfx_mesh_vertexed_desc desc)
{
	struct rjd_gfx_context_d3d11* context_d3d11 = (struct rjd_gfx_context_d3d11*)context;

	struct rjd_gfx_mesh_buffer_d3d11* buffers = rjd_mem_alloc_array(struct rjd_gfx_mesh_buffer_d3d11, desc.count_buffers, context_d3d11->allocator);

	for (size_t i = 0; i < desc.count_buffers; ++i) {
		const struct rjd_gfx_mesh_buffer_desc* desc_buffer = desc.buffers + i;

		UINT buffer_size = 0;
		UINT flags_bind = 0;
		uint32_t stride = 0;
		const void* data = NULL;

		if (desc_buffer->usage_flags & RJD_GFX_MESH_BUFFER_USAGE_VERTEX) {
			if (desc_buffer->usage_flags & RJD_GFX_MESH_BUFFER_USAGE_VERTEX_CONSTANT ||
				desc_buffer->usage_flags & RJD_GFX_MESH_BUFFER_USAGE_PIXEL_CONSTANT) {
				return RJD_RESULT("Vertex buffers cannot also be constant buffers.");
			}

				buffer_size = desc_buffer->common.vertex.length;
				stride = desc_buffer->common.vertex.stride;
				data = desc_buffer->common.vertex.data;
				flags_bind = D3D11_BIND_VERTEX_BUFFER;

				if (desc_buffer->shader_slot_d3d11 >= D3D11_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT - 1) {
					return RJD_RESULT("Vertex buffer index must be < D3D11_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT");
				}
				if (stride == 0) {
					return RJD_RESULT("Vertex buffers must have a stride larger than 0.");
				}
		}

		if (desc_buffer->usage_flags & RJD_GFX_MESH_BUFFER_USAGE_VERTEX_CONSTANT || 
			desc_buffer->usage_flags & RJD_GFX_MESH_BUFFER_USAGE_PIXEL_CONSTANT) {
				buffer_size = desc_buffer->common.constant.capacity;
				flags_bind = D3D11_BIND_CONSTANT_BUFFER;

				if (buffer_size % 16 != 0) {
					return RJD_RESULT("Uniform buffer size must be a multiple of 16.");
				}
				if (D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT * 4 * sizeof(float) < buffer_size) {
					return RJD_RESULT("Uniform buffer exceeded max allowable size");
				}
				if (desc_buffer->shader_slot_d3d11 >= D3D11_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT - 1) {
					return RJD_RESULT("Constant buffer index must be < D3D11_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT");
				}	

				// Despite the documentation claiming otherwise, D3D11 requires valid data for constant 
				// buffers. We'll just give it an array of zeroes to work with for now.
				void* temp_data = rjd_mem_alloc_stack_array_noclear(uint8_t, buffer_size); // TODO verify this doesn't get destroyed once we leave switch scope?
				memset(temp_data, 0, buffer_size);
				for (size_t j = 0; j < buffer_size; j += sizeof(float)) {
					float* f = (void*)((char*)temp_data + j);
					*f = 255.0f;
				}

				data = temp_data;
		}

		D3D11_BUFFER_DESC desc_buffer_d3d11 = {
			.ByteWidth = buffer_size,
			.Usage = D3D11_USAGE_DYNAMIC, // TODO expose options for immutable buffers
			.BindFlags = flags_bind,
			.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE,
			.MiscFlags = 0,
			.StructureByteStride = 0,
		};

		D3D11_SUBRESOURCE_DATA subresource = {
			.pSysMem = data,
			.SysMemPitch = 0,
			.SysMemSlicePitch = 0,
		};

		ID3D11Buffer* buffer_d3d11 = NULL;
		HRESULT hr = ID3D11Device_CreateBuffer(context_d3d11->device, &desc_buffer_d3d11, &subresource, &buffer_d3d11);
		if (FAILED(hr)) {
			return rjd_gfx_translate_hresult(hr);
		}

		struct rjd_gfx_mesh_buffer_d3d11 buffer = {
			.buffer = buffer_d3d11,
			.stride = stride,
			.offset = 0,
			.slot = desc_buffer->shader_slot_d3d11,
			.usage_flags = desc_buffer->usage_flags,
		};

		buffers[i] = buffer;
	}

	struct rjd_gfx_mesh_d3d11 mesh_d3d11 = {
		.buffers = buffers,
		.count_buffers = desc.count_buffers,
		.count_vertices = desc.count_vertices,
		.primitive = desc.primitive,
	};

	rjd_slotmap_insert(context_d3d11->slotmap_meshes, mesh_d3d11, &out->handle);

	return RJD_RESULT_OK();
}

struct rjd_result rjd_gfx_mesh_modify(struct rjd_gfx_context* context, struct rjd_gfx_command_buffer* cmd_buffer, struct rjd_gfx_mesh* mesh, uint32_t buffer_index, uint32_t offset, const void* data, uint32_t length)
{
	RJD_ASSERT(context);
	RJD_ASSERT(cmd_buffer);
	RJD_ASSERT(mesh);
	RJD_ASSERT(data || length == 0);

	struct rjd_gfx_context_d3d11* context_d3d11 = (struct rjd_gfx_context_d3d11*)context;
	struct rjd_gfx_command_buffer_d3d11* command_buffer_d3d11 = rjd_slotmap_get(context_d3d11->slotmap_command_buffers, cmd_buffer->handle);
	struct rjd_gfx_mesh_d3d11* mesh_d3d11 = rjd_slotmap_get(context_d3d11->slotmap_meshes, mesh->handle);

	RJD_ASSERTMSG(buffer_index < mesh_d3d11->count_buffers, "Invalid index into mesh buffer array");

	struct rjd_gfx_mesh_buffer_d3d11* buffer = mesh_d3d11->buffers + buffer_index;

	ID3D11Resource* resource = (ID3D11Resource*)buffer->buffer;
	const UINT subresource = 0;
	D3D11_MAPPED_SUBRESOURCE gpu_resource = {0};

	HRESULT hr = ID3D11DeviceContext_Map(command_buffer_d3d11->deferred_context, resource, subresource, D3D11_MAP_WRITE_DISCARD, 0, &gpu_resource);
	if (FAILED(hr)) {
		return rjd_gfx_translate_hresult(hr);
	}

	memcpy((char*)gpu_resource.pData + offset, data, length);

	ID3D11DeviceContext_Unmap(command_buffer_d3d11->deferred_context, resource, subresource);
	return RJD_RESULT_OK();
}

void rjd_gfx_mesh_destroy(struct rjd_gfx_context* context, struct rjd_gfx_mesh* mesh)
{
	RJD_ASSERT(context);
	RJD_ASSERT(mesh);

	struct rjd_gfx_context_d3d11* context_d3d11 = (struct rjd_gfx_context_d3d11*)context;
	rjd_gfx_mesh_destroy_d3d11(context_d3d11, mesh->handle);
}

////////////////////////////////////////////////////////////////////////////////
// local implementation

static struct rjd_result rjd_gfx_translate_hresult(HRESULT hr)
{
	if (SUCCEEDED(hr)) {
		return RJD_RESULT_OK();
	}

	switch (hr) 
	{
	case E_INVALIDARG:
		return RJD_RESULT("E_INVALIDARG");

	default:
		return RJD_RESULT("Failed. TODO more info.");
	}
}

static DXGI_FORMAT rjd_gfx_format_to_dxgi(enum rjd_gfx_format format)
{
	switch (format)
	{
		case RJD_GFX_FORMAT_COLOR_U8_RGBA: return DXGI_FORMAT_R8G8B8A8_UINT;
		case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM: return DXGI_FORMAT_B8G8R8A8_UNORM;
		case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM_SRGB: return DXGI_FORMAT_B8G8R8A8_UNORM_SRGB;
		case RJD_GFX_FORMAT_DEPTHSTENCIL_F32_D32: return DXGI_FORMAT_D32_FLOAT;
		case RJD_GFX_FORMAT_DEPTHSTENCIL_U32_D24_S8: return DXGI_FORMAT_D24_UNORM_S8_UINT;
		case RJD_GFX_FORMAT_COUNT: break;
	}

	RJD_ASSERTFAIL("Unhandled case.");
	return DXGI_FORMAT_UNKNOWN;
}

static DXGI_FORMAT rjd_gfx_format_to_dxgi_strip_srgb(enum rjd_gfx_format format)
{
	enum rjd_gfx_format format_no_srgb = format;

	switch (format_no_srgb)
	{
		case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM_SRGB: format_no_srgb = RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM; break;
		default: break;
	}

	return rjd_gfx_format_to_dxgi(format_no_srgb);
}

static struct rjd_gfx_rgba rjd_gfx_format_value_to_rgba(struct rjd_gfx_format_value value)
{
	struct rjd_gfx_rgba out = {0};
	switch (value.type)
	{
		case RJD_GFX_FORMAT_COLOR_U8_RGBA:
			out.v[0] = value.color_u8_rgba[0] / 255.0f;
			out.v[1] = value.color_u8_rgba[1] / 255.0f;
			out.v[2] = value.color_u8_rgba[2] / 255.0f;
			out.v[3] = value.color_u8_rgba[3] / 255.0f;
			break;
		case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM:
		case RJD_GFX_FORMAT_COLOR_U8_BGRA_NORM_SRGB:
			RJD_ASSERT("TODO");
			break;
		case RJD_GFX_FORMAT_DEPTHSTENCIL_F32_D32:
		case RJD_GFX_FORMAT_DEPTHSTENCIL_U32_D24_S8:
			RJD_ASSERT("This is intended to be used by colors, not depthstencil values.");
			break;
		case RJD_GFX_FORMAT_COUNT:
			RJD_ASSERTFAIL("Bad type.");
			break;
	}

	return out;
}

D3D_PRIMITIVE_TOPOLOGY rjd_gfx_primitive_to_d3d11(enum rjd_gfx_primitive_type primitive)
{
	switch (primitive)
	{
		case RJD_GFX_PRIMITIVE_TYPE_TRIANGLES: return D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
	}

	RJD_ASSERTFAIL("Unhandled primitive type %d", primitive);
	return 0;
}

static D3D11_CULL_MODE rjd_gfx_cull_to_d3d(enum rjd_gfx_cull cull_mode)
{
	switch (cull_mode)
	{
		case RJD_GFX_CULL_NONE: return D3D11_CULL_NONE;
		case RJD_GFX_CULL_BACK: return D3D11_CULL_BACK;
		case RJD_GFX_CULL_FRONT: return D3D11_CULL_FRONT;
	}

	RJD_ASSERTFAIL("Unhandled case %d", cull_mode);
	return D3D11_CULL_NONE;
}

static D3D11_COMPARISON_FUNC rjd_gfx_depth_compare_to_d3d11(enum rjd_gfx_depth_compare compare)
{
	switch (compare)
	{
		case RJD_GFX_DEPTH_COMPARE_ALWAYS_SUCCEED: return D3D11_COMPARISON_ALWAYS;
		case RJD_GFX_DEPTH_COMPARE_ALWAYS_FAIL: return D3D11_COMPARISON_NEVER;
		case RJD_GFX_DEPTH_COMPARE_LESS: return D3D11_COMPARISON_LESS;
		case RJD_GFX_DEPTH_COMPARE_LESSEQUAL: return D3D11_COMPARISON_LESS_EQUAL;
		case RJD_GFX_DEPTH_COMPARE_GREATER: return D3D11_COMPARISON_GREATER;
		case RJD_GFX_DEPTH_COMPARE_GREATEREQUAL: return D3D11_COMPARISON_GREATER_EQUAL;
		case RJD_GFX_DEPTH_COMPARE_EQUAL: return D3D11_COMPARISON_EQUAL;
		case RJD_GFX_DEPTH_COMPARE_NOTEQUAL: return D3D11_COMPARISON_NOT_EQUAL;
	}

	RJD_ASSERTFAIL("Unhandled case %d", compare);
	return D3D11_COMPARISON_ALWAYS;
}

static D3D11_USAGE rjd_gfx_texture_access_to_gpu_access(enum rjd_gfx_texture_access access)
{
	switch (access)
	{
		case RJD_GFX_TEXTURE_ACCESS_CPU_WRITE_GPU_READWRITE: return D3D11_USAGE_DEFAULT;
		case RJD_GFX_TEXTURE_ACCESS_CPU_NONE_GPU_READWRITE: return D3D11_USAGE_DEFAULT;
		case RJD_GFX_TEXTURE_ACCESS_COUNT: break;
	}

	RJD_ASSERTFAIL("Unhandled case %d", access);
	return D3D11_USAGE_DEFAULT;
}

static D3D11_CPU_ACCESS_FLAG rjd_gfx_texture_access_to_cpu_access(enum rjd_gfx_texture_access access)
{
	switch (access)
	{
		case RJD_GFX_TEXTURE_ACCESS_CPU_WRITE_GPU_READWRITE: return D3D11_CPU_ACCESS_WRITE;
		case RJD_GFX_TEXTURE_ACCESS_CPU_NONE_GPU_READWRITE: return 0;
		case RJD_GFX_TEXTURE_ACCESS_COUNT: break;
	}

	RJD_ASSERTFAIL("Unhandled case %d", access);
	return 0;
}

static const char* rjd_gfx_semantic_to_name(enum rjd_gfx_vertex_semantic semantic)
{
	switch (semantic)
	{
	case RJD_GFX_VERTEX_SEMANTIC_POSITION: return "SV_Position";
	case RJD_GFX_VERTEX_SEMANTIC_COLOR:	return "COLOR";
	case RJD_GFX_VERTEX_SEMANTIC_NORMAL: return "NORMAL";
	case RJD_GFX_VERTEX_SEMANTIC_TEXCOORD: return "TEXCOORD";
	case RJD_GFX_VERTEX_SEMANTIC_BINORMAL: return "BINORMAL";
	case RJD_GFX_VERTEX_SEMANTIC_TANGENT: return "TANGENT";
	case RJD_GFX_VERTEX_SEMANTIC_BLENDINDEX: return "BLENDINDICES";
	case RJD_GFX_VERTEX_SEMANTIC_BLENDWEIGHT: return "BLENDWEIGHT";
	case RJD_GFX_VERTEX_SEMANTIC_COUNT: RJD_ASSERTFAIL("RJD_GFX_VERTEX_SEMANTIC_COUNT is an invalid semantic type"); return NULL;
	}

	RJD_ASSERTFAIL("Unhandled case %d", semantic);
	return NULL;
}

static bool rjd_gfx_texture_isbackbuffer(struct rjd_gfx_texture texture)
{
	return	texture.handle.salt == RJD_GFX_TEXTURE_BACKBUFFER.handle.salt &&
			texture.handle.index == RJD_GFX_TEXTURE_BACKBUFFER.handle.index;
}

static struct rjd_result rjd_gfx_backbuffer_get_msaa_quality_d3d11(const struct rjd_gfx_context_d3d11* context, uint32_t sample_count, DXGI_SAMPLE_DESC* out)
{
	RJD_ASSERTMSG(sample_count != 0, "You must supply a sample_count greater than 0 that is a power of 2.");
	// RJD_ASSERTMSG(rjd_math_next_pow2(sample_cont) == sample_count, "sample_count (%u) must be a power of 2.", sample_count); // TODO

	UINT quality = 0;

	if (sample_count > 1) {
		DXGI_FORMAT format = rjd_gfx_format_to_dxgi(context->backbuffer_color_format);

		HRESULT hr = ID3D11Device_CheckMultisampleQualityLevels(context->device, format, sample_count, &quality);
		if (FAILED(hr)) {
			if (hr == 0) {
				return RJD_RESULT("The MSAA level was unsupported. Try a lower level. It's also possible your backbuffer format doesn't support this level of MSAA.");
			} else {
				return RJD_RESULT("Failed to get multisample quality levels.");
			}
		}

		if (quality == 0) {
			return RJD_RESULT("The MSAA level was unsupported.");
		}

		// CheckMultisampleQualityLevels() returns the "count" of quality levels supported, so the final desc Quality is minus one
		quality = quality - 1;
	}

	out->Count = sample_count;
	out->Quality = quality;

	return RJD_RESULT_OK();
}

static inline void rjd_gfx_texture_destroy_d3d11(struct rjd_gfx_context_d3d11* context, struct rjd_slot slot)
{
	struct rjd_gfx_texture_d3d11* texture = rjd_slotmap_get(context->slotmap_textures, slot);

	ID3D11Texture2D_Release(texture->texture);
	ID3D11ShaderResourceView_Release(texture->resource_view);
	ID3D11SamplerState_Release(texture->sampler);
	rjd_strref_release(texture->debug_name);

	rjd_slotmap_erase(context->slotmap_textures, slot);
}

static inline void rjd_gfx_shader_destroy_d3d11(struct rjd_gfx_context_d3d11* context, struct rjd_slot slot)
{
	struct rjd_gfx_shader_d3d11* shader = rjd_slotmap_get(context->slotmap_shaders, slot);

	ID3D10Blob_Release(shader->bytecode);
	if (shader->vertex) {
		ID3D11VertexShader_Release(shader->vertex);
	}
	if (shader->pixel) {
		ID3D11PixelShader_Release(shader->pixel);
	}
	rjd_strref_release(shader->debug_name);
	rjd_strref_release(shader->debug_source);

	rjd_slotmap_erase(context->slotmap_shaders, slot);
}

static inline void rjd_gfx_pipeline_state_destroy_d3d11(struct rjd_gfx_context_d3d11* context, struct rjd_slot slot)
{
	struct rjd_gfx_pipeline_state_d3d11* pipeline_state = rjd_slotmap_get(context->slotmap_pipeline_states, slot);

	ID3D11InputLayout_Release(pipeline_state->vertex_layout);
	ID3D11RasterizerState_Release(pipeline_state->rasterizer_state);
	ID3D11DepthStencilState_Release(pipeline_state->depthstencil_state);
	rjd_strref_release(pipeline_state->debug_name);

	rjd_slotmap_erase(context->slotmap_pipeline_states, slot);
}

static inline void rjd_gfx_mesh_destroy_d3d11(struct rjd_gfx_context_d3d11* context, struct rjd_slot slot)
{
	struct rjd_gfx_mesh_d3d11* mesh = rjd_slotmap_get(context->slotmap_meshes, slot);

	for (size_t i = 0; i < mesh->count_buffers; ++i) {
		ID3D11Buffer_Release(mesh->buffers[i].buffer);
	}
	rjd_mem_free(mesh->buffers);

	rjd_slotmap_erase(context->slotmap_meshes, slot);
}

static inline void rjd_gfx_command_buffer_destroy_d3d11(struct rjd_gfx_context_d3d11* context, struct rjd_slot slot)
{
	struct rjd_gfx_command_buffer_d3d11* cmd_buffer = rjd_slotmap_get(context->slotmap_command_buffers, slot);
	if (cmd_buffer->render_target_view) {
		ID3D11RenderTargetView_Release(cmd_buffer->render_target_view);
	}
	if (cmd_buffer->depthstencil_view) {
		ID3D11RenderTargetView_Release(cmd_buffer->depthstencil_view);
	}
	if (cmd_buffer->deferred_context) {
		ID3D11DeviceContext_Release(cmd_buffer->deferred_context);
	}

	rjd_slotmap_erase(context->slotmap_command_buffers, slot);
}

#endif // RJD_IMPL && RJD_PLATFORM_WINDOWS

